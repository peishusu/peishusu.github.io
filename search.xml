<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell编程</title>
      <link href="/posts/e5954c2f.html"/>
      <url>/posts/e5954c2f.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>🖋 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>🖊 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>🖌 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p><p>🖍 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>📃 Linux 的 Shell 种类众多，常见的有：</p><p>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）<br>Bourne Again Shell（&#x2F;bin&#x2F;bash）  Linux默认使用的<br>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）<br>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）<br>Shell for Root（&#x2F;sbin&#x2F;sh）<br><strong>📃 Linux 提供的 Shell 解析器有</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo ~]$ cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><p><strong>📃 bash 和 sh 的关系</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo bin]$ ll | grep bash</span><br><span class="line">-rwxr-xr-x. 1 root root 941880 5 月 11 2016 bash</span><br><span class="line">lrwxrwxrwx. 1 root root 4 5 月 27 2017 sh -&gt; bash</span><br></pre></td></tr></table></figure><p><strong>📃 Centos 默认的解析器是 bash</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo bin]$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h1 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h1><p>脚本以 #!&#x2F;bin&#x2F;bash 开头（指定解析器）</p><p>#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><p>打开文本编辑器(可以使用 vi&#x2F;vim 命令来创建文件)，新建一个文件 helloworld.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ touch helloworld.sh</span><br><span class="line">[root@Demo shells]$ vim helloworld.sh</span><br><span class="line"></span><br><span class="line">// 在 helloworld.sh 中输入如下内容</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;helloworld&quot;</span><br></pre></td></tr></table></figure><p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p><code>echo</code> 命令用于向窗口输出文本。</p><h1 id="脚本的常用执行方式"><a href="#脚本的常用执行方式" class="headerlink" title="脚本的常用执行方式"></a>脚本的常用执行方式</h1><p><strong>📝 采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限）</strong>,这种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执权限。</p><p>📃 sh+脚本的相对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ sh ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>📃 sh+脚本的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ sh /home/shells/helloworld.sh</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>📃 bash+脚本的相对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ bash ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>📃 bash+脚本的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ bash /home/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p><strong>📝 采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</strong>,这种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p><p>📃 首先要赋予 helloworld.sh 脚本的+x 权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ chmod +x helloworld.sh</span><br></pre></td></tr></table></figure><p>📃 相对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>📃 绝对路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ /home/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>📍 变量类型：运行shell时，会同时存在三种变量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">👉 局部变量： 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</span><br><span class="line"></span><br><span class="line">👉 环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</span><br><span class="line"></span><br><span class="line">👉 shell变量： shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</span><br></pre></td></tr></table></figure><p>📍 只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>📍 删除变量：使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><p>📍 定义变量时，变量名不加美元符号</p><p>📍 变量名和等号之间不能有空格</p><p>📍 变量名的命名须遵循规则：</p><pre><code>👉 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。👉 中间不能有空格，可以使用下划线 _。👉 不能使用标点符号。👉 不能使用bash里的关键字（可用help命令查看保留关键字）。</code></pre><p>📍 使用一个定义过的变量，只要在变量名前面加美元符号即可。</p><p>📍 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界 (推荐给所有变量加上花括号)。</p><p>📍 已定义的变量，可以被重新定义</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量 A</span></span><br><span class="line">[root@Demo shells]$ A=5</span><br><span class="line">[root@Demo shells]$ echo $A</span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给变量 A 重新赋值</span></span><br><span class="line">[root@Demo shells]$ A=8</span><br><span class="line">[root@Demo shells]$ echo $A</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销变量 A</span></span><br><span class="line">[root@Demo shells]$ unset A</span><br><span class="line">[root@Demo shells]$ echo $A</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">声明静态的变量 B=2，不能 <span class="built_in">unset</span></span></span><br><span class="line">[root@Demo shells]$ readonly B=2</span><br><span class="line">[root@Demo shells]$ echo $B</span><br><span class="line">2</span><br><span class="line">[root@Demo shells]$ B=9</span><br><span class="line">-bash: B: readonly variable </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</span></span><br><span class="line">[root@Demo shells]$ C=1+2</span><br><span class="line">[root@Demo shells]$ echo $C</span><br><span class="line">1+2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量的值如果有空格，需要使用双引号或单引号括起来</span></span><br><span class="line">[root@Demo shells]$ D=I love you</span><br><span class="line">-bash: world: command not found</span><br><span class="line">[root@Demo shells]$ D=&quot;I love you&quot;</span><br><span class="line">[root@Demo shells]$ echo $D</span><br><span class="line">I love you</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可把变量提升为全局环境变量，可供其他 Shell 程序使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 helloworld.sh 文件中增加 <span class="built_in">echo</span> <span class="variable">$B</span></span></span><br><span class="line">[root@Demo shells]$ vim helloworld.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld&quot;</span><br><span class="line">echo $B</span><br><span class="line"></span><br><span class="line">[root@Demo shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现并没有打印输出变量 B 的值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="built_in">export</span> 变量名</span></span><br><span class="line">[root@Demo shells]$ export B</span><br><span class="line">[root@Demo shells]$ ./helloworld.sh</span><br><span class="line">helloworld</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="SHELL注释"><a href="#SHELL注释" class="headerlink" title="SHELL注释"></a>SHELL注释</h1><p>以 # 开头的行就是注释，会被解释器忽略，通过每一行加一个 # 号设置多行注释。</p><p>多行注释：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h1 id="SHELL字符串"><a href="#SHELL字符串" class="headerlink" title="SHELL字符串"></a>SHELL字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号</p><p>单引号：</p><pre><code>👉 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；👉 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</code></pre><p>双引号</p><pre><code>👉 双引号里可以有变量。👉 双引号里可以出现转义字符。</code></pre><p>📃 拼接字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&quot;runoob&quot;</span><br><span class="line"></span><br><span class="line"># 使用双引号拼接,输出结果为：hello, runoob ! hello, runoob !</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"></span><br><span class="line"># 使用单引号拼接,输出结果为：hello, runoob ! hello, $&#123;your_name&#125; !</span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📃 获取字符串长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125;   # 输出 4</span><br><span class="line"></span><br><span class="line"># 变量为数组时，$&#123;#string&#125; 等价于 $&#123;#string[0]&#125;:</span><br><span class="line"></span><br><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string[0]&#125;   # 输出 4</span><br><span class="line"></span><br><span class="line"># 计算字符长度也可是使用 length。</span><br><span class="line">string=&quot;hello,everyone my name is mingming&quot;  # string字符串里边有空格,所以需要添加双引号</span><br><span class="line">expr length &quot;$string&quot;   # 输出:34</span><br><span class="line"></span><br><span class="line"># 使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身</span><br><span class="line">expr 5+6     # 直接输出 5+6</span><br><span class="line">expr 5 + 6   # 输出 11</span><br><span class="line"></span><br><span class="line"># 对于某些运算符，还需要我们使用符号&quot;\&quot;进行转义，否则就会提示语法错误</span><br><span class="line">expr 5 * 6       # 输出错误</span><br><span class="line">expr 5 \* 6      # 输出30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📃 提取子字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以下实例从字符串第 2 个字符开始截取 4 个字符</span><br><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125;   # 输出 unoo，下标从0开始的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📃 查找子字符串的索引位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)</span><br><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure><p>📃 字符串截取</p><p>0️⃣ 定义字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var=http://www.aaa.com/123.htm</span><br></pre></td></tr></table></figure><p>1️⃣ <code># </code>号截取，删除左边字符，保留右边字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var#*//&#125; # 结果是 ：www.aaa.com/123.htm</span><br></pre></td></tr></table></figure><p>📎 <code>#</code> 其中 var 是变量名，# 号是运算符，*&#x2F;&#x2F; 表示从左边开始删除第一个 &#x2F;&#x2F; 号及左边的所有字符，即删除 http:&#x2F;&#x2F;</p><p>2️⃣**##** 号截取，删除左边字符，保留右边字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var##*/&#125; # 结果是 123.htm</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📎 <code>##*/</code> 表示从左边开始删除最后（最右边）一个 &#x2F; 号及左边的所有字符，即删除 <a href="http://www.aaa.com/">http://www.aaa.com/</a></p><p>3️⃣ %号截取，删除右边字符，保留左边字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var%/*&#125; # 结果是：http://www.aaa.com</span><br></pre></td></tr></table></figure><p>📎 <code>%/* </code>表示从右边开始，删除第一个 &#x2F; 号及右边的字符</p><p>4️⃣ %% 号截取，删除右边字符，保留左边字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var%%/*&#125; # 结果是：http:</span><br></pre></td></tr></table></figure><p>📎 <code>%%/* </code>表示从右边开始，删除最后（最左边）一个 &#x2F; 号及右边的字符</p><p>5️⃣ 从左边第几个字符开始，及字符的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var:0:5&#125; # 结果是：http:</span><br></pre></td></tr></table></figure><p>📎 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。</p><p>6️⃣ 从左边第几个字符开始，一直到结束。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var:7&#125; # 从第7个个数，结果是 ：www.aaa.com/123.htm</span><br></pre></td></tr></table></figure><p>7️⃣ 从右边第几个字符开始，及字符的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var:0-7&#125; # 结果是：123.htm</span><br></pre></td></tr></table></figure><p>📎 其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。</p><p>8️⃣ 从右边第几个字符开始，一直到结束。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;var:0-7&#125; # 结果是：123.htm</span><br></pre></td></tr></table></figure><p>📎 表示从右边第七个字符开始，一直到结束。</p><p>📍 左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示。</p><p>📃 read 命令用于获取键盘输入信息</p><p>🔦 它的语法形式一般是：<code>read [-options] [variable...]</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -p 参数由于设置提示信息</span><br><span class="line">read -p &quot;input a val:&quot; a    #获取键盘输入的 a 变量数字</span><br><span class="line">read -p &quot;input b val:&quot; b    #获取键盘输入的 b 变量数字</span><br><span class="line">r=$[a+b]                    #计算a+b的结果 赋值给r  不能有空格</span><br><span class="line">echo &quot;result = $&#123;r&#125;&quot;        #输出显示结果 r</span><br></pre></td></tr></table></figure><h1 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h1><p>向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，其中 $0 为执行的文件名（包含文件路径），1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br><span class="line"></span><br><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure><p>参数说明<br>$#传递到脚本的参数个数<br>$*以一个单字符串显示所有向脚本传递的参数。如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$$脚本运行的当前进程ID号<br>$!后台运行的最后一个进程的ID号<br>$@与∗ 相同，但是使用时加引号，并在引号中返回每个参数。如 “ *相同，但是使用时加引号，并在引号中返回每个参数。如”∗相同，但是使用时加引号，并在引号中返回每个参数。如”@“用「”」括起来的情况、以”$1” “2 “ … “ 2” … “2”…”n” 的形式输出所有参数。<br>$-显示Shell使用的当前选项，与set命令功能相同。<br>$?显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;参数个数为：$#&quot;;</span><br><span class="line">echo &quot;传递的参数作为一个字符串显示：$*&quot;;</span><br><span class="line"></span><br><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure><p>**着重说一下 $*与 $@ **</p><p>  👉 都是引用所有参数。</p><p>  👉 只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;-- \$* 演示 ---&quot;</span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$@ 演示 ---&quot;</span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="SHELL数组"><a href="#SHELL数组" class="headerlink" title="SHELL数组"></a>SHELL数组</h1><p>bash支持<strong>一维数组（不支持多维数组）</strong>，并且<strong>没有限定数组的大小</strong>。</p><p>数组元素的下标<strong>由 0 开始编号</strong>。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 数组名&#x3D;(值1 值2 … 值n)</p><h2 id="📃-数组的定义："><a href="#📃-数组的定义：" class="headerlink" title="📃 数组的定义："></a>📃 数组的定义：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"># 或者</span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"># 还可以单独定义数组的各个分量。可以不使用连续的下标，而且下标的范围没有限制。</span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><h2 id="📃读取数组"><a href="#📃读取数组" class="headerlink" title="📃读取数组"></a>📃读取数组</h2><p>读取数组元素值的一般格式是：<code>$&#123;数组名[下标]&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br><span class="line"></span><br><span class="line"># 使用 @ 符号可以获取数组中的所有元素</span><br><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure><h2 id="📃获取数组的长度"><a href="#📃获取数组的长度" class="headerlink" title="📃获取数组的长度"></a>📃获取数组的长度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取数组长度的方法与获取字符串长度的方法相同</span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><h2 id="📃关联数组"><a href="#📃关联数组" class="headerlink" title="📃关联数组"></a>📃<strong>关联数组</strong></h2><p>Bash 支持关联数组，可以使用<strong>任意的字符串、或者整数作为下标</strong>来<strong>访问数组元素</strong>。关联数组使用 <strong>declare</strong> 命令来声明。</p><p>🔦 <strong>语法格式：</strong><code>declare -A array_name</code></p><ul><li>-A 选项就是用于声明一个关联数组。</li><li>关联数组的键是唯一的。</li></ul><p>📃 创建一个关联数组 site，同时创建不同的键值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare -A site=([&quot;google&quot;]=&quot;www.google.com&quot; [&quot;runoob&quot;]=&quot;www.runoob.com&quot; [&quot;taobao&quot;]=&quot;www.taobao.com&quot;)</span><br></pre></td></tr></table></figure><p>我们也可以先声明一个关联数组，然后再设置键和值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare -A site</span><br><span class="line">site[&quot;google&quot;]=&quot;www.google.com&quot;</span><br><span class="line">site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;</span><br><span class="line">site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过键来访问关联数组的元素：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;site[&quot;runoob&quot;]&#125;</span><br></pre></td></tr></table></figure><h2 id="📃获取数组中的所有元素"><a href="#📃获取数组中的所有元素" class="headerlink" title="📃获取数组中的所有元素"></a>📃获取数组中的所有元素</h2><p>使用 <strong>@</strong> 或 ***** 可以获取数组中的所有元素，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare -A site</span><br><span class="line">site[&quot;google&quot;]=&quot;www.google.com&quot;</span><br><span class="line">site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;</span><br><span class="line">site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;数组的元素为: $&#123;site[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;site[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p>在数组前加一个感叹号 <strong>!</strong> 可以获取数组的所有键，例如：对于普通数组，获取的键是索引，对于关联数组，获取的键是自己写的key</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare -A site</span><br><span class="line">site[&quot;google&quot;]=&quot;www.google.com&quot;</span><br><span class="line">site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;</span><br><span class="line">site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;数组的键为: $&#123;!site[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的键为: $&#123;!site[@]&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 输出结果如下：</span><br><span class="line">数组的键为: google runoob taobao</span><br><span class="line">数组的键为: google runoob taobao</span><br></pre></td></tr></table></figure><h1 id="shell-运算符"><a href="#shell-运算符" class="headerlink" title="shell 运算符"></a>shell 运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法</td><td align="left"><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left"><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left"><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法</td><td align="left"><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td align="left">%</td><td align="left">取余</td><td align="left"><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td align="left">&#x3D;</td><td align="left">赋值</td><td align="left">a&#x3D;$b 把变量 b 的值赋给 a。</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td align="left">相等。用于比较两个数字，相同则返回 true。</td><td align="left">[ $a &#x3D;&#x3D; $b ] 返回 false。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不相等。用于比较两个数字，不相同则返回 true。</td><td align="left">[ $a !&#x3D; $b ] 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a&#x3D;&#x3D;$b]</strong> 是错误的，必须写成 **[ $a &#x3D;&#x3D; $b ]**。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br></pre></td></tr></table></figure><ul><li><p>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</p></li><li><p>完整的表达式要被 **&#96;&#96;**包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p></li><li><p>乘号(*)前边必须加反斜杠()才能实现乘法运算；</p></li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-eq</td><td align="left">检测两个数是否相等，相等返回 true。</td><td align="left">[ $a -eq $b ] 返回 false。</td></tr><tr><td align="left">-ne</td><td align="left">检测两个数是否不相等，不相等返回 true。</td><td align="left">[ $a -ne $b ] 返回 true。</td></tr><tr><td align="left">-gt</td><td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td align="left">[ $a -gt $b ] 返回 false。</td></tr><tr><td align="left">-lt</td><td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td align="left">[ $a -lt $b ] 返回 true。</td></tr><tr><td align="left">-ge</td><td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -ge $b ] 返回 false。</td></tr><tr><td align="left">-le</td><td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -le $b ] 返回 true。</td></tr></tbody></table><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td align="left">[ ! false ] 返回 true。</td></tr><tr><td align="left">-o</td><td align="left">或运算，有一个表达式为 true 则返回 true。</td><td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td align="left">-a</td><td align="left">与运算，两个表达式都为 true 才返回 true。</td><td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑的 AND</td><td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td align="left">||</td><td align="left">逻辑的 OR</td><td align="left">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">检测两个字符串是否相等，相等返回 true。</td><td align="left">[ $a &#x3D; $b ] 返回 false。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检测两个字符串是否不相等，不相等返回 true。</td><td align="left">[ $a !&#x3D; $b ] 返回 true。</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true。</td><td align="left">[ -z $a ] 返回 false。</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td align="left">[ -n “$a” ] 返回 true。</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否不为空，不为空返回 true。</td><td align="left">[ $a ] 返回 true。</td></tr></tbody></table><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr></tbody></table><p>其他检查符：</p><ul><li><strong>-S</strong>: 判断某文件是否 socket。</li><li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/posts/b73e5edc.html"/>
      <url>/posts/b73e5edc.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/posts/9211474f.html"/>
      <url>/posts/9211474f.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录相关的命令"><a href="#目录相关的命令" class="headerlink" title="目录相关的命令"></a>目录相关的命令</h2><h3 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h3><ul><li><code>cd usr</code>：切换到该目录下 usr 目录</li><li><code>cd ..（或cd../）</code>：切换到上一层目录</li><li><code>cd /</code>：切换到系统根目录</li><li><code>cd ~</code>：切换到用户主目录</li><li>**<code>cd -</code>*<em>*<em>：</em></em> 切换到上一个操作所在目录</li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><code>ls</code>：显示目录中的文件和子目录的列表。例如：<code>ls /home</code>，显示 <code>/home</code> 目录下的文件和子目录列表</p><ul><li><code>ll</code>：<code>ll</code> 是 <code>ls -l</code> 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息</li><li><code>mkdir [选项] 目录名</code>：创建新目录（增）。例如：<code>mkdir -m 755 my_directory</code>，创建一个名为 <code>my_directory</code> 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。</li><li><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li><li><code>pwd</code>：显示当前工作目录的路径。</li><li><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</li><li><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</li><li><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。例如：<code>cp file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件复制到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>cp -r source destination</code>，将 <code>source</code> 目录及其下的所有子目录和文件复制到 <code>destination</code> 目录下，并保留源文件的属性和目录结构。</li><li><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。例如：<code>mv file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件移动到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>mv</code> 与 <code>cp</code> 的结果不同，<code>mv</code> 好像文件“搬家”，文件个数并未增加。而 <code>cp</code> 对文件进行复制，文件个数增加了。</li></ul><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul><li><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。例如：<code>touch file1.txt file2.txt file3.txt</code> ，创建 3 个文件。</li><li><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。例如：<code>ln -s file.txt file_link</code>，创建名为 <code>file_link</code> 的软链接，指向 <code>file.txt</code> 文件。<code>-s</code> 选项代表的就是创建软链接，s 即 symbolic（软链接又名符号链接） 。</li><li><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><code>vim 文件名</code>：修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li></ul><hr><h1 id="文件解压缩的命令"><a href="#文件解压缩的命令" class="headerlink" title="文件解压缩的命令"></a>文件解压缩的命令</h1><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以 <code>.tar</code> 结尾的，压缩的命令一般是以 <code>.gz</code> 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 <code>.tar.gz</code>。</p><p>命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code> 。</p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中 x 代表解压</p><p>示例：</p><ul><li>将 <code>/test</code> 下的 <code>test.tar.gz</code> 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></li><li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:<code>tar -xvf test.tar.gz -C /usr</code>（<code>-C</code> 代表指定解压的位置）</li></ul><hr><h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ul><li><code>scp [选项] 源文件 远程文件</code> （scp 即 secure copy，安全复制）：用于通过 SSH 协议进行安全的文件传输，可以实现从本地到远程主机的上传和从远程主机到本地的下载。例如：<code>scp -r my_directory user@remote:/home/user</code> ，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。<code>scp -r user@remote:/home/user/my_directory</code> ，将远程服务器的 <code>/home/user</code> 目录下的<code>my_directory</code>目录下载到本地。需要注意的是，<code>scp</code> 命令需要在本地和远程系统之间建立 SSH 连接进行文件传输，因此需要确保远程服务器已经配置了 SSH 服务，并且具有正确的权限和认证方式。</li><li><code>rsync [选项] 源文件 远程文件</code> : 可以在本地和远程系统之间高效地进行文件复制，并且能够智能地处理增量复制，节省带宽和时间。例如：<code>rsync -r my_directory user@remote:/home/user</code>，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。</li><li><code>ftp</code> (File Transfer Protocol)：提供了一种简单的方式来连接到远程 FTP 服务器并进行文件上传、下载、删除等操作。使用之前需要先连接登录远程 FTP 服务器，进入 FTP 命令行界面后，可以使用 <code>put</code> 命令将本地文件上传到远程主机，可以使用<code>get</code>命令将远程主机的文件下载到本地，可以使用 <code>delete</code> 命令删除远程主机的文件。这里就不进行演示了。</li></ul><hr><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><code>ls -lc</code>查看某个目录下的文件或目录的权限</p><p>第一列的信息如下：</p><p>文件类型：</p><ul><li>d：代表目录</li><li>-：代表文件</li><li>l：代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中的权限：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p><ul><li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用<code>ls ‐ahl</code>命令可以看到文件的所有者 ，也可以使用 <code>chown 用户名 文件名</code>来修改文件的所有者 。</li><li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组，也可以使用 <code>chgrp 组名 文件名</code>来修改文件所在的组。</li><li>其它组(o)：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><p>修改文件或目录的权限：利用<code>chmod</code>命令</p><p><code>chmod +x file.name </code>&#x3D;&#x3D; <code>chmod a+x file.name</code> a代表所有用户</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux 系统是一个<code>多用户多任务的分时操作系统</code>，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>相关命令：</p><ul><li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li><li><code>userdel [选项] 用户名</code>:删除用户帐号。</li><li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li><li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li><li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li></ul><hr><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd [选项] 用户组</code> :增加一个新的用户组。</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组。</li><li><code>groupmod [选项] 用户组</code> : 修改用户组的属性。</li></ul><h1 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h1><ul><li><code>top [选项]</code>：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。</li><li><code>htop [选项]</code>：类似于 <code>top</code>，但提供了更加交互式和友好的界面，可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</li><li><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</li><li><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</li><li><code>free [选项]</code>：用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等。</li><li><code>df [选项] [文件系统]</code>：用于查看系统的磁盘空间使用情况，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</li><li><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</li><li><code>sar [选项] [时间间隔] [重复次数]</code>：用于收集、报告和分析系统的性能统计信息，包括系统的 CPU 使用、内存使用、磁盘 I&#x2F;O、网络活动等详细信息。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</li><li><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</li><li><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</li></ul><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><ul><li><code>ping [选项] 目标主机</code>：测试与目标主机的网络连接。</li><li><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</li><li><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</li><li><code>ss [选项]</code>：比 <code>netstat</code> 更好用，提供了更快速、更详细的网络连接信息。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="#%E5%85%B6%E4%BB%96">其他</a></h1><ul><li><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</li><li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，–color 代表高亮显示。</li><li><code>kill -9 进程的pid</code>：杀死进程（-9 表示强制终止）先用 ps 查找进程，然后用 kill 杀掉。</li><li><code>shutdown</code>：<code>shutdown -h now</code>：指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</li><li><code>reboot</code>：<code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</li></ul><h1 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h1><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的主目录（HOME）。</p><h2 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h2><p>按照作用域来分，环境变量可以简单的分成:</p><ul><li>用户级别环境变量 : <code>~/.bashrc</code>、<code>~/.bash_profile</code>。</li><li>系统级别环境变量 : <code>/etc/bashrc</code>、<code>/etc/environment</code>、<code>/etc/profile</code>、<code>/etc/profile.d</code>。</li></ul><p>上述配置文件执行先后顺序为：<code>/etc/environment</code> –&gt; <code>/etc/profile</code> –&gt; <code>/etc/profile.d</code> –&gt; <code>~/.bash_profile</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>~/.bashrc</code></p><p>如果要修改系统级别环境变量文件，需要管理员具备对该文件的写入权限。</p><p>建议用户级别环境变量在 <code>~/.bash_profile</code>中配置，系统级别环境变量在 <code>/etc/profile.d</code> 中配置。</p><p>按照生命周期来分，环境变量可以简单的分成:</p><ul><li>永久的：需要用户修改相关的配置文件，变量永久生效。</li><li>临时的：用户利用 <code>export</code> 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</li></ul><h2 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h2><p>输出当前系统定义的所有环境变量：<code>export -p</code>  or <code>env</code></p><p>输出指定的环境变量的值：<code>echo $环境变量名  </code></p><h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><p>1⃣️ 只针对当前shell终端生效，关闭终端就会失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>2⃣️ 修改环境永久有效</p><p>利用<code>vim命令</code>修改；如果修改的是系统级别环境变量，对所有用户生效；修改的是用户级别环境，只针对当前用户生效</p><p>修改完之后，利用<code>source</code> 命令让其生效   或者。关闭shell终端重新登录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dockerfile的讲解</title>
      <link href="/posts/11b561ff.html"/>
      <url>/posts/11b561ff.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algrothrim/tree</title>
      <link href="/posts/7b209e6f.html"/>
      <url>/posts/7b209e6f.html</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h2 id="Pro-144-二叉树的前序遍历"><a href="#Pro-144-二叉树的前序遍历" class="headerlink" title="Pro 144 二叉树的前序遍历"></a>Pro 144 二叉树的前序遍历</h2><p>利用栈来解决这个问题</p><h2 id="Pro94-二叉树的中序遍历（难点）"><a href="#Pro94-二叉树的中序遍历（难点）" class="headerlink" title="Pro94 二叉树的中序遍历（难点）"></a>Pro94 二叉树的中序遍历（难点）</h2><p>因为先访问的是中节点，但是我们要先处理的是左节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// stack.push(root);  错误的地方，相当于把cur加入了两次</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-145-二叉树的后序遍历"><a href="#Pro-145-二叉树的后序遍历" class="headerlink" title="Pro 145 二叉树的后序遍历"></a>Pro 145 二叉树的后序遍历</h2><p>前序遍历：中左右   </p><p>后序遍历：左右中</p><p>利用前序遍历的一点变化再通过反转结果得到后序遍历的结果</p><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="Pro-102-二叉树的层序遍历"><a href="#Pro-102-二叉树的层序遍历" class="headerlink" title="Pro 102 二叉树的层序遍历"></a>Pro 102 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep用来记录当前遍历的c</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(TreeNode root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; deep)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(deep - <span class="number">1</span>).add(root.val);</span><br><span class="line">        levelOrder1(root.left,deep);</span><br><span class="line">        levelOrder1(root.right,deep);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装常用的软件</title>
      <link href="/posts/ffabeda8.html"/>
      <url>/posts/ffabeda8.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络--HTTP</title>
      <link href="/posts/9610dfa.html"/>
      <url>/posts/9610dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>超文本传输协议</p><h2 id="状态码有哪些？"><a href="#状态码有哪些？" class="headerlink" title="状态码有哪些？"></a>状态码有哪些？</h2><img src="/posts/9610dfa/image-20240506144111577.png" class title="五大类HTTP状态码"><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h2><p>① Host字段</p><p>将请求发往「同一台」服务器上的不同网站。</p><img src="/posts/9610dfa/image-20240506144439951.png" class title="如图"><p>② Content-length字段</p><p>本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>HTTP协议是基于TCP协议的，这个方法解决了TCP 粘包 的问题</p><p>③ Connection字段</p><p>最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。长连接机制指的是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><img src="/posts/9610dfa/image-20240506144934539.png" class title="如图"><p>④ Content-Type字段</p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><img src="/posts/9610dfa/image-20240506145230659.png" class title="如图"><p>上述图片中：</p><p>客户端请求：Accept: * &#x2F; * 代表可以接收任何格式的数据</p><p>服务器端响应： Content-Type : text&#x2F;html;Charset&#x3D;utf-8 代表服务器端响应的数据格式</p><p>⑤ Content-Encoding 字段</p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><img src="/posts/9610dfa/image-20240506145550150.png" class title="如图"><h1 id="GTE和POST"><a href="#GTE和POST" class="headerlink" title="GTE和POST"></a>GTE和POST</h1><h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h2><p>根据RFC规范，</p><p>GET用于从服务器请求资源，请求的参数是写在URL中可见的，并且有长度限制。</p><p>POST用于对服务器的资源进行修改，内容写在报文body中，这个是不可见的。</p><h2 id="GET和POST方式是安全、幂等的嘛？"><a href="#GET和POST方式是安全、幂等的嘛？" class="headerlink" title="GET和POST方式是安全、幂等的嘛？"></a>GET和POST方式是安全、幂等的嘛？</h2><p>安全：请求方法不会破坏服务器上的资源</p><p>幂等：多次执行相同的请求，响应的结果是一致的</p><ul><li>对于RFC的GET和POST请求方式而言，<ul><li>GET是安全、幂等的，所以可以对GET请求的数据进行缓存到本地磁盘上。同时还可以作为书签</li><li>POST是非安全、不幂等的。</li></ul></li></ul><h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>用于避免发送缓存，对于一些重复性的http请求，直接将【请求-响应】的数据缓存在本地磁盘，下次可以直接读取本地磁盘中的数据。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>只要浏览器判断本地缓存没有过期，直接使用本地磁盘上的缓存。</p><p>通过设置在HTTP响应头部的2个字段来实现的：Cache-Control(相对时间，优先级高)；Expires（绝对时间）</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>服务器端向客户端发送304 的响应，通知客户端可以继续使用本地缓存。</p><p>协商缓存是在强制缓存发现本地缓存已经过期的情况下，开展的。主要流程如下</p><img src="/posts/9610dfa/image-20240506171152086.png" class title="如图"><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="HTTP和HTTPS有哪些区别？"><a href="#HTTP和HTTPS有哪些区别？" class="headerlink" title="HTTP和HTTPS有哪些区别？"></a>HTTP和HTTPS有哪些区别？</h2><ul><li>HTTP是明文传输，HTTPS在TCP和HTTP之间加了一个SSL&#x2F;TLS安全协议，进行加密传输</li><li>HTTP需要通过TCP三次握手建立连接，而HTTPS除了TCP三次握手后，还要进行SSL&#x2F;TLS的四次握手</li><li>HTTPS协议需要向CA申请数字证书，来保证服务器的身份是可信的</li></ul><h2 id="HTTPS解决了HTTP的哪些问题？"><a href="#HTTPS解决了HTTP的哪些问题？" class="headerlink" title="HTTPS解决了HTTP的哪些问题？"></a>HTTPS解决了HTTP的哪些问题？</h2><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容</li></ul><p>​<img src="/posts/9610dfa/image-20240506182200049.png" class title="如图"></p><p>​在通信建立前，采用非对称加密的方式交换会话密钥，后续就不再使用非对称加密</p><p>​在通信过程中全部使用对称加密的会话密钥加密明文数据</p><ul><li><strong>篡改风险</strong>，比如服务器端返回的数据被植入垃圾广告</li></ul><p>​摘要算法（利用哈希运算得到哈希值）+ 数字签名（避免在传输过程中的内容会被替换掉，利用私钥加密、公钥解密）</p><p>​<img src="/posts/9610dfa/image-20240506184356572.png" class title="如图"></p><ul><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>将服务器的公钥注册到数字证书中，数字证书认证机构CA利用自己的私钥将服务器的公钥数字签名并颁发数字证书（服务器的公钥+ CA的数字签名）给客户端。</p><p>客户端拿到数字证书后，利用CA的公钥进行解密确认数字证书的合法性，然后才能获取服务器的公钥。使用它对报文加密后发送。</p><p>服务器利用私钥进行解密。</p><img src="/posts/9610dfa/image-20240507144616740.png" class title="如图"><h2 id="HTTPS是如何建立连接的？"><a href="#HTTPS是如何建立连接的？" class="headerlink" title="HTTPS是如何建立连接的？"></a>HTTPS是如何建立连接的？</h2><p>① 首先进行TCP的三次握手</p><p>② 然后可以基于<strong>RSA或者ECHDE</strong>进行<strong>SSL&#x2F;TLS</strong>的四次握手通信。客户端向服务器端索要并且验证服务器的公钥（验证数字签名的合法性）；客户端和服务器端协商生产【会话密钥】。</p><ul><li><p>第一次握手：</p><ul><li>客户端向服务器发送加密通信请求，也就是<strong>ClientHello</strong>请求，请求内容为TLS协议版本+客户端的随机数+支持的密码套件列表</li></ul></li><li><p>第二次握手：</p><ul><li>服务器端给客户端返回响应，确认的TLS协议版本+ 服务器端的随机数 + 确定的密码套件列表 + 数字证书（通过CA的私钥对服务器的公钥加密后得到数字签名 + 服务器端的公钥）</li></ul></li><li><p>第三次握手：</p><ul><li><p>客户端收到服务器端的回应之后，通过CA的公钥进行解密，确认数字证书的合法性，然后利用数字证书中传递过来的服务器的公钥对一个<strong>随机数pre-master-key</strong>进行加密发送给服务器端。</p></li><li><img src="/posts/9610dfa/image-20240508152033447.png" class title="如图"></li><li><p>服务器端利用 服务器的私钥 对发送过来的pre-master-key进行解密得到pre-master-key</p></li><li><p>客户端、服务器端   分别利用 客户端随机数 + 服务器端随机数 + pre-master-key得到会话密钥</p></li><li><p>紧接着，客户端会通知服务器端使用加密方式进行通信，并且对之前发送的所有信息做个摘要并且进行加密，让服务器做个验证</p></li></ul></li><li><p>第四次握手：</p><ul><li>服务器如果验证双方加解密都没有问题，那么返回相同的响应，代表握手正式完成。</li></ul></li></ul><p>③ 接下来，就是利用http的方式请求和响应消息，只不过这个消息是经过会话密钥加密之后的</p><h2 id="HTTPS一定是安全可靠的吗？"><a href="#HTTPS一定是安全可靠的吗？" class="headerlink" title="HTTPS一定是安全可靠的吗？"></a>HTTPS一定是安全可靠的吗？</h2><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h1 id="HTTP-1-1-、HTTP-2、-HTTP-3演变"><a href="#HTTP-1-1-、HTTP-2、-HTTP-3演变" class="headerlink" title="HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变"></a>HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变</h1><h2 id="HTTPS-1-1-的优化？"><a href="#HTTPS-1-1-的优化？" class="headerlink" title="HTTPS&#x2F;1.1 的优化？"></a>HTTPS&#x2F;1.1 的优化？</h2><ul><li>优点<ul><li>长连接</li><li>管道传输</li></ul></li><li>缺点：<ul><li>服务器端存在队头阻塞的现象</li><li>请求只能从客户端发起，服务器端只能被动接受冰箱并响应</li></ul></li></ul><h2 id="HTTPS-2的优化？"><a href="#HTTPS-2的优化？" class="headerlink" title="HTTPS&#x2F;2的优化？"></a>HTTPS&#x2F;2的优化？</h2><p>基于HTTPS进行优化的</p><ul><li><p>优点</p><ul><li>是安全的</li><li>l利用HPACK算法实现头部压缩，因为对于很多请求而言，他们的头部是一样，我们在客户端和服务器端共同维护一个头部表</li><li>内部使用二进制格式，比如说响应http状态吗200原来是三个字符‘2’0‘0’保存的，现在利用二进制进行保存</li><li>利用stream解决HTTP服务器端的队头阻塞问题，以及实现了服务器端的主动推送功能</li></ul></li><li><p>缺点</p><ul><li>仍然存在这个TCP层的队头阻塞问题</li></ul></li></ul><h2 id="HTTPS-3的优化"><a href="#HTTPS-3的优化" class="headerlink" title="HTTPS&#x2F;3的优化"></a>HTTPS&#x2F;3的优化</h2><ul><li>优点：<ul><li>UDP替换TCP，彻底解决了队头阻塞的问题</li><li>没有TCP 的三次握手，建立连接更快。对于之前的连接：先进行TCP三次握手和四次挥手，以及TLS的四次握手；而现在QUIC协议包含TLS协议，只需要根据<strong>连接id</strong>进行QUIC三次握手即可</li><li>便于连接迁移，基于TCP的是通过一个TCP四元组（源ip,源port,目的ip，目的端口）确定一个TCP连接的，如果一旦网络发生变化，就需要重新建立连接。对于基于UDP，只需要通过连接ID标记通信的两个端点即可。</li></ul></li></ul><h1 id="HTTP1-1如何优化？"><a href="#HTTP1-1如何优化？" class="headerlink" title="HTTP1.1如何优化？"></a>HTTP1.1如何优化？</h1><ul><li>分为三个方面进行优化：<ul><li>缓存方面：利用  强制缓存   和    协商缓存   这2个技术实现避免发送http请求</li><li>减少http请求的次数<ul><li>将原本有客户端的处理的重定向请求，交给中间的代理服务器进行处理，减少重定向带来的请求的次数</li><li>将访问多个小文件的请求合并成一个大的请求，和并请求就是合并资源，以一个大资源的请求替换多个小资源的请求</li><li>请求网页的时候，没必要一口气将所有的资源都获取到，只需要先获取当前用户所看到的页面资源即可。</li></ul></li><li>减少HTTP响应的数据大小<ul><li>无损压缩：解压之后能够完全恢复到压缩前的原样，比如说gzip</li><li>有所压缩：通过牺牲一定的质量来提高压缩比，</li></ul></li></ul></li></ul><h1 id="HTTPS如何进行优化？"><a href="#HTTPS如何进行优化？" class="headerlink" title="HTTPS如何进行优化？"></a>HTTPS如何进行优化？</h1><h1 id="HTTPS的RSA握手解析"><a href="#HTTPS的RSA握手解析" class="headerlink" title="HTTPS的RSA握手解析"></a>HTTPS的RSA握手解析</h1><p>握手过程参考前面的内容</p><p>一般不使用它，因为它不可以前向加密的操作。</p><p>意思就是：客户端再通过验证数字证书的合法性之后，取出数字签名中的公钥，对新生成的随机数pre-master-key进行加密发送给服务器端，如果说服务器端的这个私钥被窃取了，那么回到发送的全部TSL消息全都被解密。</p><h1 id="HTTPS的ECDHE握手解析"><a href="#HTTPS的ECDHE握手解析" class="headerlink" title="HTTPS的ECDHE握手解析"></a>HTTPS的ECDHE握手解析</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器卷</title>
      <link href="/posts/e0d41e40.html"/>
      <url>/posts/e0d41e40.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是容器卷"><a href="#什么是容器卷" class="headerlink" title="什么是容器卷?"></a>什么是容器卷?</h1><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><ul><li><p>一句话：有点类似我们Redis里面的rdb和aof文件</p></li><li><p>·将docker容器内的数据保存进宿主机的磁盘中</p></li><li><p>那么如何运行一个带有容器卷存储功能的容器实例？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</span><br></pre></td></tr></table></figure></li></ul><h1 id="容器卷的作用？"><a href="#容器卷的作用？" class="headerlink" title="容器卷的作用？"></a>容器卷的作用？</h1><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p>为了能保存数据，在docker中我们使用卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据</p><p>2：卷中的更改可以直接实时生效，爽</p><p>3：数据卷中的更改不会包含在镜像的更新中</p><p>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h1 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h1><ul><li><p>默认是<strong>rw</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</span><br></pre></td></tr></table></figure></li><li><p><strong>ro</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</span><br></pre></td></tr></table></figure><p>容器自己只能读取不能写 </p><p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p></li></ul><h1 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h1><ul><li>容器1完成和宿主机的映射</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure><ul><li>容器2继承容器1的卷规则</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu</span><br></pre></td></tr></table></figure><p>注意：这里继承的是规则，代表即使容器1挂了，容器了还是能够和宿主机进行同步的。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像</title>
      <link href="/posts/890cc775.html"/>
      <url>/posts/890cc775.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是镜像？"><a href="#什么是镜像？" class="headerlink" title="什么是镜像？"></a>什么是镜像？</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><h2 id="联合文件系统UnionFS"><a href="#联合文件系统UnionFS" class="headerlink" title="联合文件系统UnionFS"></a>联合文件系统UnionFS</h2><p><strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="Docker镜像的加载原理"><a href="#Docker镜像的加载原理" class="headerlink" title="Docker镜像的加载原理"></a>Docker镜像的加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p><img src="/posts/890cc775/image-20240504225354426.png" class title="docker镜像的分层"><p>&#x3D;&#x3D;平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？？&#x3D;&#x3D;</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="Docker镜像采用分层结构的好处"><a href="#Docker镜像采用分层结构的好处" class="headerlink" title="Docker镜像采用分层结构的好处"></a>Docker镜像采用分层结构的好处</h2><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><p><strong>Docker镜像层都是只读的，容器层是可写的</strong> 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p>通俗来讲：</p><p>​Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>​新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建docker私有仓库</title>
      <link href="/posts/4f71e385.html"/>
      <url>/posts/4f71e385.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><p><a href="https://www.yuque.com/tmfl/cloud/zbegdm">https://www.yuque.com/tmfl/cloud/zbegdm</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/posts/749ad7d8.html"/>
      <url>/posts/749ad7d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、启动类命令"><a href="#1、启动类命令" class="headerlink" title="1、启动类命令"></a>1、启动类命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">//查看状态</span><br><span class="line">systemctl status docker</span><br><span class="line">//设为开机自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看docker版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="2、镜像相关的命令"><a href="#2、镜像相关的命令" class="headerlink" title="2、镜像相关的命令"></a>2、镜像相关的命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//列出本地主机上的镜像</span><br><span class="line">docker images</span><br><span class="line">//在远程仓库中搜索镜像</span><br><span class="line">docker search 镜像名称 (-f 过滤 --limit 只展示前几项)</span><br><span class="line">//下载镜像   不加 tag 时，默认下载最新的镜像（即tag为latest）。</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line">//查看占据的空间 查看镜像/容器/数据卷所占的空间：</span><br><span class="line">docker system df</span><br><span class="line">//删除镜像</span><br><span class="line">docker rmi 镜像名称/ID</span><br><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br><span class="line">docker rmi -f $&#123;docker images -qa&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h1><h2 id="3-1-新建启动容器"><a href="#3-1-新建启动容器" class="headerlink" title="3.1 新建启动容器"></a>3.1 新建启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：指定端口映射，具有几种不同形式</p><ul><li><p><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code> </p></li><li><p><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></p></li><li><p><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></p></li><li><p><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></p></li></ul></li></ul><h3 id="3-1-1-启动、退出-交互式容器"><a href="#3-1-1-启动、退出-交互式容器" class="headerlink" title="3.1.1 启动、退出 交互式容器"></a>3.1.1 启动、退出 交互式容器</h3><p>① 启动交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>② 退出交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit;  //退出后，容器会停止；</span><br><span class="line"></span><br><span class="line">使用快捷键 ctrl + P + Q  //退出后容器仍然在运行</span><br></pre></td></tr></table></figure><h3 id="3-1-2-启动、退出守护式容器"><a href="#3-1-2-启动、退出守护式容器" class="headerlink" title="3.1.2 启动、退出守护式容器"></a>3.1.2 启动、退出守护式容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：</span></span><br><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h2 id="3-2-列出正在运行的容器"><a href="#3-2-列出正在运行的容器" class="headerlink" title="3.2 列出正在运行的容器"></a>3.2 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><h2 id="3-3-容器其他启动、停止操作"><a href="#3-3-容器其他启动、停止操作" class="headerlink" title="3.3 容器其他启动、停止操作"></a>3.3 容器其他启动、停止操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已经停止的容器</span></span><br><span class="line">docker start 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已经停止的容器：</span></span><br><span class="line">docker rm 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器：</span></span><br><span class="line">docker rm -f 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次删除多个容器实例：</span></span><br><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line">或者</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="3-5-查看容器的日志"><a href="#3-5-查看容器的日志" class="headerlink" title="3.5  查看容器的日志"></a>3.5  查看容器的日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-6-查看容器内运行的进程"><a href="#3-6-查看容器内运行的进程" class="headerlink" title="3.6 查看容器内运行的进程"></a>3.6 查看容器内运行的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-7-查看容器内部细节"><a href="#3-7-查看容器内部细节" class="headerlink" title="3.7 查看容器内部细节"></a>3.7 查看容器内部细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-8-进入正在运行的容器"><a href="#3-8-进入正在运行的容器" class="headerlink" title="3.8 进入正在运行的容器"></a>3.8 进入正在运行的容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入正在运行的容器，并以命令行交互：</span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"># 重新进入</span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p><ul><li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p></li><li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p></li></ul><p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="3-9-容器和宿主机文件拷贝"><a href="#3-9-容器和宿主机文件拷贝" class="headerlink" title="3.9 容器和宿主机文件拷贝"></a>3.9 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>宿主机文件拷贝到容器中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure><h2 id="3-10-导入和导出容器"><a href="#3-10-导入和导出容器" class="headerlink" title="3.10 导入和导出容器"></a>3.10 导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p><p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"># docker export 容器ID &gt; tar文件名</span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"></span><br><span class="line"># 导入</span><br><span class="line"># cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure><h2 id="3-11-将容器生成新镜像"><a href="#3-11-将容器生成新镜像" class="headerlink" title="3.11 将容器生成新镜像"></a>3.11 将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure><p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p><p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="3-12-容器数据卷"><a href="#3-12-容器数据卷" class="headerlink" title="3.12 容器数据卷"></a>3.12 容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>●数据卷可以在容器之间共享或重用数据<br>●卷中的更改可以直接实施生效<br>●数据卷中的更改不会包含在镜像的更新中<br>●数据卷的生命周期一直持续到没有容器使用它为止</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p><p>权限：</p><ul><li><p><code>rw</code>：读写 </p></li><li><p><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</p></li></ul><p>容器卷的继承：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动一个容器</span><br><span class="line">docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"># 使用 --volumes-from 继承 u1的容器卷映射配置</span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h1 id="4、所有命令示意图"><a href="#4、所有命令示意图" class="headerlink" title="4、所有命令示意图"></a>4、所有命令示意图</h1><img src="/posts/749ad7d8/image-20240504210851162.png" class title="所有命令示意图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、centos安装docker"><a href="#1、centos安装docker" class="headerlink" title="1、centos安装docker"></a>1、centos安装docker</h1><h2 id="1-1-配置yum资源库"><a href="#1-1-配置yum资源库" class="headerlink" title="1.1 配置yum资源库"></a>1.1 配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>配置docker的资源库地址：阿里云镜像地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><strong>创建缓存（可选）：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="1-2-安装Docker引擎"><a href="#1-2-安装Docker引擎" class="headerlink" title="1.2 安装Docker引擎"></a>1.2 安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>此时，默认安装的docker引擎、客户端都是最新版本。</p><p>如果要安装指定版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="1-3-启动Docker引擎"><a href="#1-3-启动Docker引擎" class="headerlink" title="1.3 启动Docker引擎"></a>1.3 启动Docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。启动Docker引擎：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="1-4-卸载docker"><a href="#1-4-卸载docker" class="headerlink" title="1.4 卸载docker"></a>1.4 卸载docker</h2><ol><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>使用&#x3D;&#x3D;yum&#x3D;&#x3D;删除docker引擎</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="3"><li>删除镜像、容器、卷、自定义配置等文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="1-5-运行Hello-world-进行测试"><a href="#1-5-运行Hello-world-进行测试" class="headerlink" title="1.5 运行Hello world 进行测试"></a>1.5 运行Hello world 进行测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h1 id="2、docker-下载加速"><a href="#2、docker-下载加速" class="headerlink" title="2、docker 下载加速"></a>2、docker 下载加速</h1><p>我这里使用的是阿里云加速</p><p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。</p><p>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务生态技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1-Docker概述"></a>1-Docker概述</h1><h2 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 Docker简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>   –&gt; 将源码 + 配置 + 环境 + 版本打包成为一个镜像文件</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>传统虚拟机（virtual machine）：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与<strong>系统其他部分分隔开的一系列进程</strong>，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><img src="/posts/f255ffad/image-20240504144850924.png" class title="虚拟机和容器的区别"><p>对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>大小</td><td>一般为Mb</td><td>一般为Gb</td></tr><tr><td>速度</td><td>接近原生</td><td>比较慢</td></tr><tr><td>系统支持数量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="1-3-Docker运行快的原因"><a href="#1-3-Docker运行快的原因" class="headerlink" title="1.3 Docker运行快的原因"></a>1.3 Docker运行快的原因</h2><p>Docker<strong>利用的是宿主机的内核</strong>，而不需要加载操作系统OS内核：</p><p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p><p>Docker容器的<strong>本质就是一个进程</strong>。</p><h2 id="1-4-Docker的组成"><a href="#1-4-Docker的组成" class="headerlink" title="1.4 Docker的组成"></a>1.4 Docker的组成</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分：</p><ul><li><p>镜像（image）</p></li><li><p>容器（container）</p></li><li><p>仓库（repository）</p></li></ul><h3 id="1-4-1-镜像"><a href="#1-4-1-镜像" class="headerlink" title="1.4.1 镜像"></a>1.4.1 镜像</h3><p>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><h3 id="1-4-2-容器"><a href="#1-4-2-容器" class="headerlink" title="1.4.2 容器"></a>1.4.2 容器</h3><p>Docker利用<strong>容器</strong>独立运行的一个或一组应用，应用程序或服务运行在容器里面，<strong>容器就类似于一个虚拟化的运行环境</strong>，容器是用镜像创建的<strong>运行实例</strong>。</p><h3 id="1-4-3-仓库"><a href="#1-4-3-仓库" class="headerlink" title="1.4.3 仓库"></a>1.4.3 仓库</h3><p>Docker仓库是<strong>集中存放镜像文件</strong>的场所。</p><p>仓库分为<strong>公开仓库</strong>和<strong>私有仓库</strong>两种。</p><p>最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><img src="/posts/f255ffad/image-20240504145832567.png" class title="docker架构图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务生态技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job_基础学习</title>
      <link href="/posts/2b2e40e1.html"/>
      <url>/posts/2b2e40e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1什么是任务调度"><a href="#1-1什么是任务调度" class="headerlink" title="1.1什么是任务调度"></a>1.1什么是任务调度</h3><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="1-2-为什么需要分布式调度"><a href="#1-2-为什么需要分布式调度" class="headerlink" title="1.2 为什么需要分布式调度"></a>1.2 为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能</p><p>在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>感觉Spring给我们提供的这个注解可以完成任务调度的功能，好像已经完美解决问题了，为什么还需要分布式呢?</p><p>主要有如下这几点原因:</p><ol><li>高可用：单机版的定式任务调度只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用。</li><li>防止重复执行: 在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，这时，定时执行的结果就可能存在混乱和错误了</li><li>单机处理极限：原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。你也许会说，你也可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况。</li></ol><h3 id="1-3-XXL-JOB介绍"><a href="#1-3-XXL-JOB介绍" class="headerlink" title="1.3 XXL-JOB介绍"></a>1.3 XXL-JOB介绍</h3><p>XXL-Job：是大众点评的分布式任务调度平台，是一个**<code>轻量级分布式任务调度平台,</code>** 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p>大众点评目前已接入XXL-JOB，该系统在内部已调度约100万次，表现优异。</p><p>目前已有多家公司接入xxl-job，包括比较知名的大众点评，京东，优信二手车，360金融 (360)，联想集团 (联想)，易信 (网易)等等</p><p>官网地址 <a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><p><strong>系统架构图</strong></p><img src="/posts/image.png" width="75%" height="75%"><p><strong>设计思想</strong></p><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><h3 id="2-1-下载源码"><a href="#2-1-下载源码" class="headerlink" title="2.1 下载源码"></a>2.1 下载源码</h3><p><strong>源码下载地址:</strong></p><p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p><a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><h3 id="2-1-初始化调度数据库"><a href="#2-1-初始化调度数据库" class="headerlink" title="2.1 初始化调度数据库"></a>2.1 初始化调度数据库</h3><p>请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。</p><p>“调度数据库初始化SQL脚本” 位置为:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/xxl-job/doc/db/tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h3 id="2-2-编译源码"><a href="#2-2-编译源码" class="headerlink" title="2.2 编译源码"></a>2.2 编译源码</h3><p>解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558831.png" alt="img"></p><h3 id="2-3-配置部署调度中心"><a href="#2-3-配置部署调度中心" class="headerlink" title="2.3 配置部署调度中心"></a>2.3 配置部署调度中心</h3><h4 id="2-3-1-调度中心配置"><a href="#2-3-1-调度中心配置" class="headerlink" title="2.3.1 调度中心配置"></a>2.3.1 调度中心配置</h4><p>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### web</span><br><span class="line">server.port=8080    ###配置了端口号</span><br><span class="line">server.servlet.context-path=/xxl-job-admin</span><br><span class="line"></span><br><span class="line">### actuator</span><br><span class="line">management.server.servlet.context-path=/actuator</span><br><span class="line">management.health.mail.enabled=false</span><br><span class="line"></span><br><span class="line">### resources</span><br><span class="line">spring.mvc.servlet.load-on-startup=0</span><br><span class="line">spring.mvc.static-path-pattern=/static/**</span><br><span class="line">spring.resources.static-locations=classpath:/static/</span><br><span class="line"></span><br><span class="line">### freemarker</span><br><span class="line">spring.freemarker.templateLoaderPath=classpath:/templates/</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.request-context-attribute=request</span><br><span class="line">spring.freemarker.settings.number_format=0.##########</span><br><span class="line"></span><br><span class="line">### mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml</span><br><span class="line">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span><br><span class="line"></span><br><span class="line">### xxl-job, datasource</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.202.200:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">### datasource-pool</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.auto-commit=true</span><br><span class="line">spring.datasource.hikari.idle-timeout=30000</span><br><span class="line">spring.datasource.hikari.pool-name=HikariCP</span><br><span class="line">spring.datasource.hikari.max-lifetime=900000</span><br><span class="line">spring.datasource.hikari.connection-timeout=10000</span><br><span class="line">spring.datasource.hikari.connection-test-query=SELECT 1</span><br><span class="line">spring.datasource.hikari.validation-timeout=1000</span><br><span class="line"></span><br><span class="line">### xxl-job, email</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.username=xxx@qq.com</span><br><span class="line">spring.mail.from=xxx@qq.com</span><br><span class="line">spring.mail.password=xxx</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory</span><br><span class="line"></span><br><span class="line">### xxl-job, access token</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line"></span><br><span class="line">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span><br><span class="line">xxl.job.i18n=zh_CN</span><br><span class="line"></span><br><span class="line">## xxl-job, triggerpool max size</span><br><span class="line">xxl.job.triggerpool.fast.max=200</span><br><span class="line">xxl.job.triggerpool.slow.max=100</span><br><span class="line"></span><br><span class="line">### xxl-job, log retention days</span><br><span class="line">xxl.job.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-3-2-部署项目"><a href="#2-3-2-部署项目" class="headerlink" title="2.3.2 部署项目"></a>2.3.2 部署项目</h4><p>运行<code>XxlJobAdminApplication</code>程序即可.</p><p>调度中心访问地址: <a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a></p><p>默认登录账号 “admin&#x2F;123456”, 登录后运行界面如下图所示。</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558842.png" alt="img"></p><p>至此“调度中心”项目已经部署成功。</p><h3 id="2-4-配置部署执行器项目"><a href="#2-4-配置部署执行器项目" class="headerlink" title="2.4 配置部署执行器项目"></a>2.4 配置部署执行器项目</h3><h4 id="2-4-1-添加Maven依赖"><a href="#2-4-1-添加Maven依赖" class="headerlink" title="2.4.1 添加Maven依赖"></a>2.4.1 添加Maven依赖</h4><p>创建SpringBoot项目并且添加如下依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-执行器配置"><a href="#2-4-2-执行器配置" class="headerlink" title="2.4.2 执行器配置"></a>2.4.2 执行器配置</h4><p>在配置文件中添加如下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span><br><span class="line">xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin</span><br><span class="line">### 执行器通讯TOKEN [选填]：非空时启用；</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span><br><span class="line">xxl.job.executor.appname=xxl-job-executor-sample</span><br><span class="line">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span><br><span class="line">xxl.job.executor.address=</span><br><span class="line">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span><br><span class="line">xxl.job.executor.ip=127.0.0.1</span><br><span class="line">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span><br><span class="line">xxl.job.executor.port=9999</span><br><span class="line">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span><br><span class="line">xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler</span><br><span class="line">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span><br><span class="line">xxl.job.executor.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-4-3-添加执行器配置"><a href="#2-4-3-添加执行器配置" class="headerlink" title="2.4.3 添加执行器配置"></a>2.4.3 添加执行器配置</h4><p>创建<code>XxlJobConfig</code>配置对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-添加任务处理类"><a href="#2-4-4-添加任务处理类" class="headerlink" title="2.4.4 添加任务处理类"></a>2.4.4 添加任务处理类</h4><p>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-运行HelloWorld程序"><a href="#2-5-运行HelloWorld程序" class="headerlink" title="2.5 运行HelloWorld程序"></a>2.5 运行HelloWorld程序</h3><h4 id="2-5-1-任务配置-触发执行"><a href="#2-5-1-任务配置-触发执行" class="headerlink" title="2.5.1 任务配置&amp;触发执行"></a>2.5.1 任务配置&amp;触发执行</h4><p>登录调度中心,在任务管理中新增任务,配置内容如下:</p><img src="/posts/image-17147915558843.png"><p>新增后界面如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558844.png" alt="img"></p><p>接着启动定时调度任务</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558845.png" alt="img"></p><h4 id="2-5-2-查看日志"><a href="#2-5-2-查看日志" class="headerlink" title="2.5.2 查看日志"></a>2.5.2 查看日志</h4><p>在调度中心的调度日志中就可以看到，任务的执行结果.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558846.png" alt="img"></p><p>管控台也可以看到任务的执行信息.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558857.png" alt="img"></p><h3 id="2-6-GLUE模式-Java"><a href="#2-6-GLUE模式-Java" class="headerlink" title="2.6 GLUE模式(Java)"></a>2.6 GLUE模式(Java)</h3><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定**<code>JobHandler</code>**。</p><p>（ “GLUE模式(Java)” 运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，可使用<a href="https://github.com/Resource">@Resource</a>&#x2F;<a href="https://github.com/Autowire">@Autowire</a>注入执行器里中的其他服务.</p><p><strong>添加Service</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodB的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加任务配置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558858.png" alt="img"></p><p><strong>通过GLUE IDE在线编辑代码</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558859.png" alt="img"></p><hr><p>编写内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.service.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.wolfcode.xxljobdemo.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.IJobHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGlueJobHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        helloService.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动并执行程序</strong></p><h3 id="2-6-执行器集群"><a href="#2-6-执行器集群" class="headerlink" title="2.6 执行器集群"></a>2.6 执行器集群</h3><h4 id="2-6-1-集群环境搭建"><a href="#2-6-1-集群环境搭建" class="headerlink" title="2.6.1 集群环境搭建"></a>2.6.1 集群环境搭建</h4><p>在IDEA中设置SpringBoot项目运行开启多个集群</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588510.png" alt="img"></p><p>启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588511.png" alt="img"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><ul><li><p>8090端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588512.png" alt="img"></p></li><li><p>8091端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588513.png" alt="img"></p></li></ul><h4 id="2-6-2-调度路由算法讲解"><a href="#2-6-2-调度路由算法讲解" class="headerlink" title="2.6.2 调度路由算法讲解"></a>2.6.2 调度路由算法讲解</h4><p>当执行器集群部署时，提供丰富的路由策略，包括:</p><ol><li><code>FIRST（第一个）：固定选择第一个机器</code></li><li><code>LAST（最后一个）：固定选择最后一个机器；</code></li><li><code>ROUND（轮询）：依次的选择在线的机器发起调度</code></li><li><code>RANDOM（随机）：随机选择在线的机器；</code></li><li><code>CONSISTENT_HASH（一致性HASH）：</code> <code>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</code></li><li><code>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</code></li><li><code>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</code></li><li><code>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>SHARDING_BROADCAST(分片广播)：</code> <code>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</code></li></ol><h2 id="3-分片功能讲解"><a href="#3-分片功能讲解" class="headerlink" title="3. 分片功能讲解"></a>3. 分片功能讲解</h2><h3 id="3-1-案例需求讲解"><a href="#3-1-案例需求讲解" class="headerlink" title="3.1 案例需求讲解"></a>3.1 案例需求讲解</h3><p>需求:我们现在实现这样的需求，在指定节假日，需要给平台的所有用户去发送祝福的短信.</p><h4 id="3-1-1-初始化数据"><a href="#3-1-1-初始化数据" class="headerlink" title="3.1.1 初始化数据"></a>3.1.1 初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="3-1-2-集成Druid-MyBatis"><a href="#3-1-2-集成Druid-MyBatis" class="headerlink" title="3.1.2 集成Druid&amp;MyBatis"></a>3.1.2 集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-业务功能实现"><a href="#3-1-3-业务功能实现" class="headerlink" title="3.1.3 业务功能实现"></a>3.1.3 业务功能实现</h4><p><strong>任务处理方法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务配置信息</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588514.png" alt="img"></p><h3 id="3-2-分片概念讲解"><a href="#3-2-分片概念讲解" class="headerlink" title="3.2 分片概念讲解"></a>3.2 分片概念讲解</h3><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务.</p><p>如果采取<code>分片广播</code>的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度.</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h3 id="3-3-案例改造成任务分片"><a href="#3-3-案例改造成任务分片" class="headerlink" title="3.3 案例改造成任务分片"></a>3.3 案例改造成任务分片</h3><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务设置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588515.png" alt="img"></p><h2 id="4-项目集成XXL-JOB"><a href="#4-项目集成XXL-JOB" class="headerlink" title="4. 项目集成XXL-JOB"></a>4. 项目集成XXL-JOB</h2>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog-introduction</title>
      <link href="/posts/7574726c.html"/>
      <url>/posts/7574726c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、解决HEXO图片无法显示问题"><a href="#1、解决HEXO图片无法显示问题" class="headerlink" title="1、解决HEXO图片无法显示问题"></a>1、解决HEXO图片无法显示问题</h1><p>版本：Hexo 3以上　　</p><p>最近搭建hexo博客时遇到了图片部署后不显示的问题，如图：</p><p>上网找了很多方式都没有完美解决问题，后来查看了官方文档后终于解决了问题（完美解决），现在贴出来如下。建议以后大家遇到了问题也先去看看官方文档：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p><p>解决方案如下：</p><p>　　1. 在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。</p><p>　　2. git bash安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</p><p>　　3. 插入图片时用这种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img jpg文件 文件描述 %&#125;</span><br></pre></td></tr></table></figure><img src="/posts/7574726c/image-20240503162414559.png" class title="图片描述"><p>　　4. 这样就能成功显示了，测试下吧：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
