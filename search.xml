<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring-security</title>
      <link href="/posts/a750524a.html"/>
      <url>/posts/a750524a.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> spring security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> spring security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/posts/aa55683f.html"/>
      <url>/posts/aa55683f.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="说一说进程和线程"><a href="#说一说进程和线程" class="headerlink" title="说一说进程和线程"></a>说一说进程和线程</h2><ul><li><p>基本概念</p><ul><li>进程：进程是程序运行的实例。程序是可以存在一个或者多个进程实例的</li><li>线程：线程属于进程，一个进程拥有多个线程，线程共享进程的内存，是进程中的一条指令流</li></ul></li><li><p>调度单位</p><ul><li>进程：是<strong>资源分配</strong>的基本单位</li><li>线程：是<strong>CPU调度</strong>的基本单位</li></ul></li><li><p>如何实现通信</p><ul><li>进程：<ul><li>同一个计算机<ul><li>信号量</li><li>管道，半双工</li><li>消息队列，全双工</li></ul></li><li>不同计算机之间<ul><li>遵守网络协议，套接字</li></ul></li></ul></li><li>线程：<ul><li>java中通信机制：volatile、wait&#x2F;notifyall()、join、ThreadLocal</li></ul></li></ul></li></ul><h2 id="并行、并发"><a href="#并行、并发" class="headerlink" title="并行、并发"></a>并行、并发</h2><p>并行：多核CPU，在同一时刻执行多个任务</p><p>并发：单核CPU，在同一时间段内交替执行多个任务。CPU给每个任务分配时间片</p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>① 继承Thread类</p><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 实现Runnable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 实现Callable接口</p><p>定义一个<strong>线程任务类</strong>实现 <strong>Callable 接口</strong>，重写线程任务类的 call 方法，这个方法可以直接返回执行的结果。</p><ol><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装进FutureTask</strong></li><li>把未来任务对象包装成<strong>Thread类里面</strong></li><li>调用线程的 start() 方法启动线程</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get(); <span class="comment">// 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//重写线程任务类方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规划</title>
      <link href="/posts/c4ddf82e.html"/>
      <url>/posts/c4ddf82e.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 每日学习进度安排 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试开发相关面试题</title>
      <link href="/posts/bbabc603.html"/>
      <url>/posts/bbabc603.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、软件测试的方法"><a href="#1、软件测试的方法" class="headerlink" title="1、软件测试的方法"></a>1、软件测试的方法</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>① 概念</p><p>功能测试或者性能测试，程序的内部结构不用了解，主要负责检查软件功能是否符合软件需求说明书</p><p>② 测试方法？</p><ul><li><p>等价类划分</p><ul><li>主要划分为有效等价类、无效等价类，</li><li>有效等价类主要用来检验 软件是否实现了需求文档所要求的功能</li><li>无效等价类主要用来校验软件的容错性</li></ul></li><li><p>边界值</p><ul><li>设计一些测试用例，使得软件恰好在边界附近</li></ul></li><li><p>错误推测</p><ul><li>推测用户可能的错误输入，来设计测试用例。来测试系统能否处理这种错误输入，依次提高系统的鲁棒性</li></ul></li></ul><p>③ 优缺点</p><ul><li><p>简单无需了解程序内部结构</p></li><li><p>方便对比软件开发文档</p></li><li><p>内部代码覆盖测试率低</p></li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>① 概念</p><p>结构测试，需要了解程序的内部结构和代码逻辑，主要检查程序的执行路线是否按照预期正常执行</p><p>② 测试方法</p><ul><li>程序结构分析<ul><li>画出流程图</li></ul></li><li>逻辑覆盖测试<ul><li>语句覆盖</li><li>判定覆盖</li><li>条件覆盖</li></ul></li></ul><h1 id="2、软件测试理论和方法"><a href="#2、软件测试理论和方法" class="headerlink" title="2、软件测试理论和方法"></a>2、软件测试理论和方法</h1>]]></content>
      
      
      <categories>
          
          <category> 测试开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/posts/7b25d017.html"/>
      <url>/posts/7b25d017.html</url>
      
        <content type="html"><![CDATA[<h1 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li><p>现象</p><ul><li>大量的用户请求，请求redis查询不到，于是全部请求都直接访问数据库。严重的会导致数据库宕机</li></ul></li><li><p>发生的原因以及解决策略</p><ul><li>缓存的大量数据同时过期<ul><li>大量数据的过期时间均匀设置</li><li>互斥锁：当发现访问的数据不在redis中，就加一个互斥锁。保证只有一个线程能够更新缓存，其余未拿到锁的线程要么等待锁释放，要么直接返回空值或者默认值。当然设置互斥锁要添加超时时间，不然某个线程拿到了锁，发生某种意外导致一直不释放锁，其余请求一直等待或者返回不了真实的值</li></ul></li><li>redis故障宕机<ul><li>避免故障宕机，主从节点的方式构建集群以及哨兵机制</li><li>发生故障宕机，服务熔断：请求不在访问数据库；请求限流：只允许一部分请求给数据库</li></ul></li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>现象<ul><li>有几个频繁访问的数据热点数据（比如说秒杀活动的数据）</li></ul></li><li>原因以及解决策略<ul><li>热点数据过期<ul><li>互斥锁方案。保证只有一个线程能够更新缓存。</li><li>不给热点数据设置过期时间，由后台异步更新缓存</li></ul></li></ul></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>现象：<ul><li>用户访问的数据既不在redis中，又不在数据库中</li></ul></li><li>原因及其解决方案：<ul><li>非法请求<ul><li>提前判断请求参数是否合法，不让这些恶意请求访问数据库和redis</li></ul></li><li>误删除redis和数据库中的数据<ul><li>在redis针对对应的key设置空值或者默认值，后序的请求就不会再访问数据库了</li><li>在redis和mysql之间加一个<strong>布隆过滤器</strong>：<ul><li>组成一个初始值都为0的位图数组、n个哈希函数</li><li>步骤：<ul><li>每个哈希函数分别对这个数据进行hash求值，然后除以这个位图数组的长度。</li><li>得到对应位图数组的索引，并将其置为1</li><li>只要我们判断有一个对应的索引不为1，那么坑定不存在，就不用再去找数据库了；但是因为哈希冲突的原因，即使都为1了，也不代表数据库就有这个</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="数据库和redis如何保持一致性？"><a href="#数据库和redis如何保持一致性？" class="headerlink" title="数据库和redis如何保持一致性？"></a>数据库和redis如何保持一致性？</h1><h2 id="导致不一致性的根本原因？"><a href="#导致不一致性的根本原因？" class="headerlink" title="导致不一致性的根本原因？"></a>导致不一致性的根本原因？</h2><p>并发问题，<strong>当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</strong>。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>① 先更新数据库，再更新缓存</p><img src="/posts/7b25d017/image-20240616161505686.png" class title="如图"><p>② 先更新缓存，再更新数据库</p><img src="/posts/7b25d017/image-20240616161656774.png" class title="如图"><p>③ 先删除缓存，再更新数据库</p><img src="/posts/7b25d017/image-20240616162142929.png" class title="如图"><p><strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p><p>④ 先更新数据库，在删除缓存</p><p><strong>在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题。</strong>但是在实际中，这个问题出现的概率并不高。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong></p><p>这四种方案都存在缓存读写不一致的问题，主要是2个操作是互相独立的，我们可以通过分布式锁来实现2个操作的原子性。</p><p>接着为了保证2个操作都能执行成功，我们采用消息队列的重试机制：</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>退役军人在线培训app项目</title>
      <link href="/posts/2c0e2adc.html"/>
      <url>/posts/2c0e2adc.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础框架搭建"><a href="#基础框架搭建" class="headerlink" title="基础框架搭建"></a>基础框架搭建</h1><h2 id="构建父工程以及基础base工程"><a href="#构建父工程以及基础base工程" class="headerlink" title="构建父工程以及基础base工程"></a>构建父工程以及基础base工程</h2><h3 id="git相关的问题"><a href="#git相关的问题" class="headerlink" title="git相关的问题"></a>git相关的问题</h3><p>① git产生冲突的原因，以及如何解决？</p><p>② 你是在哪个分支上面工作的？</p><p>不是在主分支上面开发的，而是在技术经理创建的独立的开发分支上面进行开发的，最后由技术经理将开发分支合并到主分支。</p><p>③ 数据库建表注意的点</p><img src="/posts/2c0e2adc/image-20240529230220128.png" class title="如图"><h1 id="内容管理模块"><a href="#内容管理模块" class="headerlink" title="内容管理模块"></a>内容管理模块</h1><h2 id="主要对课程及相关内容进行管理："><a href="#主要对课程及相关内容进行管理：" class="headerlink" title="主要对课程及相关内容进行管理："></a>主要对课程及相关内容进行管理：</h2><p>包括课程的基本信息、课程图片、课程师资信息、课程的授课计划、课程视频、课程文档等。</p><h2 id="数据库设计的逻辑模型（用到哪些看哪些）"><a href="#数据库设计的逻辑模型（用到哪些看哪些）" class="headerlink" title="数据库设计的逻辑模型（用到哪些看哪些）"></a>数据库设计的逻辑模型（用到哪些看哪些）</h2><img src="/posts/2c0e2adc/image-20240601094034171.png" class title="如图"><h2 id="内容管理模块的模块结构划分"><a href="#内容管理模块的模块结构划分" class="headerlink" title="内容管理模块的模块结构划分"></a>内容管理模块的模块结构划分</h2><img src="/posts/2c0e2adc/image-20240601100617843.png" class title="如图"><p><strong>xuecheng-plus-content-api</strong>：接口工程，为前端提供接口。</p><p><strong>xuecheng-plus-content-service</strong>: 业务工程，为接口工程提供业务支撑。</p><p><strong>xuecheng-plus-content-model</strong>: 数据模型工程，存储数据模型类、数据传输类型等。</p><p><strong>xuecheng-plus-content</strong>：内容管理模块工程，负责聚合xuecheng-plus-content-api、xuecheng-plus-content-service、xuecheng-plus-content-model。</p><h2 id="课程查询功能"><a href="#课程查询功能" class="headerlink" title="课程查询功能"></a>课程查询功能</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>点击 “课程管理” - 》 “课程查询” 页面</p><img src="/posts/2c0e2adc/image-20240601105150089.png" class title="如图"><img src="/posts/2c0e2adc/image-20240601105228021.png" class title="如图"><ul><li><p>在课程进行列表查询页面输入查询条件查询课程信息</p><ul><li><p>当不输入查询条件时输入全部课程信息。</p></li><li><p>输入查询条件查询符合条件的课程信息。</p></li><li><p>约束：本教学机构查询本机构的课程信息。</p></li></ul></li></ul><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>下边从查询条件、查询结果两个方面分析数据模型</p><p>1、查询条件：</p><ul><li><p>包括：<strong>课程名称、课程审核状态、课程发布状态</strong></p><ul><li><p>课程名称：可以模糊搜索</p></li><li><p>课程审核状态：未提交、已提交、审核通过、审核未通过</p></li><li><p>课程发布状态：未发布、已发布、已下线</p></li></ul></li><li><p>因为是分页查询所以查询条件中还要包括<strong>当前页码</strong>、<strong>每页显示记录数</strong>。</p></li></ul><p>2、查询结果：</p><ul><li><p>查询结果中包括：</p><ul><li><p>课程id、课程名称、任务数、创建时间、是否付费、审核状态、类型，操作</p></li><li><p>任务数：该课程所包含的课程计划数，即课程章节数。</p></li><li><p>是否付费：课程包括免费、收费两种。</p></li><li><p>类型：录播、直播。</p></li></ul></li><li><p>因为是分页查询所以查询结果中还要包括<strong>总记录数</strong>、<strong>当前页</strong>、<strong>每页显示记录数</strong>。</p></li></ul><h3 id="创建数据库表和PO类型"><a href="#创建数据库表和PO类型" class="headerlink" title="创建数据库表和PO类型"></a>创建数据库表和PO类型</h3><h4 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h4><ul><li><strong>创建 xcplus-content表</strong></li></ul><img src="/posts/2c0e2adc/image-20240601114432593.png" class title="如图"><h4 id="生成PO类"><a href="#生成PO类" class="headerlink" title="生成PO类"></a>生成PO类</h4><p>利用mybatis-plus的代码生成器自动生成</p><p><strong>PO代表持久对象，对应数据库中的表</strong>。并且将其存放到 <strong>xuecheng-plus-content-model模块</strong>中</p><img src="/posts/2c0e2adc/image-20240601114951214.png" class title="如图"><h3 id="接口设计（Controller层）"><a href="#接口设计（Controller层）" class="headerlink" title="接口设计（Controller层）"></a>接口设计（Controller层）</h3><h4 id="接口设计分析"><a href="#接口设计分析" class="headerlink" title="接口设计分析"></a>接口设计分析</h4><p>1）协议 </p><p>2）分析请求参数</p><p>3）分析响应结果</p><p>4）分析完成，使用SpringBoot注解开发一个Http接口。</p><p>5）使用接口文档工具查看接口的内容。</p><p>6）接口中调用Service方法完成业务处理。</p><p>课程查询接口设计</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /content/course/list?pageNo=<span class="number">2</span>&amp;pageSize=<span class="number">1</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;auditStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;202002&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;courseName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;publishStatus&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">###成功响应结果</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;companyId&quot;</span><span class="punctuation">:</span> <span class="number">1232141425</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;companyName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spring cloud实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="string">&quot;所有人&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1-3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mtName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;st&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1-3-2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200003&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;teachmode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;201001&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring Boot 4.注册中心eureka。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;createDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2019-09-04 09:56:19&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;changeDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-12-26 22:10:38&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;createPeople&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;changePeople&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auditStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;202002&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auditMind&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auditNums&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auditDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auditPeople&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;coursePubId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;coursePubDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;counts&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="定义模型类以及模型类的作用"><a href="#定义模型类以及模型类的作用" class="headerlink" title="定义模型类以及模型类的作用"></a>定义模型类以及模型类的作用</h4><p>现在项目中有两类模型类：DTO数据传输对象、PO持久化对象，DTO用于接口层向业务层之间传输数据，PO用于业务层与持久层之间传输数据，有些项目还会设置VO对象，VO对象用在前端与接口层之间传输数据，如下图：</p><img src="/posts/2c0e2adc/image-20240601164008003.png" class title="如图"><p>当前端有多个平台且接口存在差异时就需要设置VO对象用于前端和接口层传输数据。</p><p>比如：如下图</p><ul><li>课程列表查询接口，根据需求用户在手机端也要查询课程信息，此时课程查询接口是否需要编写手机端和PC端两个接口呢？如果用户要求通过手机和PC的查询条件或查询结果不一样，此时就需要定义两个Controller课程查询接口，每个接口定义VO对象与前端传输数据。</li><li>手机查询：根据课程状态查询，查询结果只有课程名称和课程状态。</li><li>PC查询：可以根据课程名称、课程状态、课程审核状态等条件查询，查询结果也比手机查询结果内容多。</li><li>此时，Service业务层尽量提供一个业务接口，即使两个前端接口需要的数据不一样，Service可以提供一个最全查询结果，由Controller进行数据整合。</li></ul><img src="/posts/2c0e2adc/image-20240601164126857.png" class title="如图"><ul><li><strong>分页查询模型类</strong><ul><li>由于分页查询这一类的接口在项目较多，这里针对分页查询的参数（当前页码、每页显示记录数）单独在xuecheng-plus-base基础工程中定义。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageParams</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//每页显示记录数</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;每页记录数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageParams</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageParams</span><span class="params">(Long pageNo, Long pageSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNo = pageNo;</span><br><span class="line">        <span class="built_in">this</span>.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>查询条件模型类</strong><ul><li>除了分页查询参数，剩下的就是课程查询的特有参数，此时需要在内容管理的model工程中定义课程查询参数模型类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 课程查询条件模型类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/11 15:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryCourseParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//审核状态</span></span><br><span class="line">    <span class="keyword">private</span> String auditStatus;</span><br><span class="line">    <span class="comment">//课程名称</span></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="comment">//发布状态</span></span><br><span class="line">    <span class="keyword">private</span> String publishStatus;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>响应模型类<ul><li>针对分页查询结果经过分析也存在固定的数据和格式，所以在base工程定义一个基础的模型类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 分页查询结果模型类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/11 15:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 数据列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items;</span><br><span class="line">    <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> counts;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="comment">//每页记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> pageSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">(List&lt;T&gt; items, <span class="type">long</span> counts, <span class="type">long</span> page, <span class="type">long</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">        <span class="built_in">this</span>.counts = counts;</span><br><span class="line">        <span class="built_in">this</span>.page = page;</span><br><span class="line">        <span class="built_in">this</span>.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><p>参考源码的编写</p><h3 id="生成接口文档"><a href="#生成接口文档" class="headerlink" title="生成接口文档"></a>生成接口文档</h3><p>利用<strong>swagger</strong>生成在线的接口文档</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>：修饰整个类，描述Controller的作用</span><br><span class="line"><span class="meta">@ApiOperation</span>：描述一个类的一个方法，或者说一个接口</span><br><span class="line"><span class="meta">@ApiParam</span>：单个参数描述</span><br><span class="line"><span class="meta">@ApiModel</span>：用对象来接收参数</span><br><span class="line"><span class="meta">@ApiModelProperty</span>：用对象接收参数时，描述对象的一个字段</span><br><span class="line"><span class="meta">@ApiResponse</span>：HTTP响应其中<span class="number">1</span>个描述</span><br><span class="line"><span class="meta">@ApiResponses</span>：HTTP响应整体描述</span><br><span class="line"><span class="meta">@ApiIgnore</span>：使用该注解忽略这个API</span><br><span class="line"><span class="meta">@ApiError</span> ：发生错误返回的信息</span><br><span class="line"><span class="meta">@ApiImplicitParam</span>：一个请求参数</span><br><span class="line"><span class="meta">@ApiImplicitParams</span>：多个请求参数</span><br></pre></td></tr></table></figure><h3 id="持久层开发（Dao层）"><a href="#持久层开发（Dao层）" class="headerlink" title="持久层开发（Dao层）"></a>持久层开发（Dao层）</h3><p>本项目使用MyBatis-Plus开发持久层，需要创建PO类、Mapper接口、Mapper的xml文件，<strong>每个PO类对应数据库的每张表</strong>，<strong>每张表需要创建一个Mapper接口和Mapper的xml映射文件 。</strong></p><p>比如说有一个表是’course_base’，对应的PO类就是‘CourseBase’，其对应的mapper接口和mapper.xml文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CourseBaseMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;CourseBase&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于持久的查询，还需要我们额外定义分页拦截器，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xuecheng.content.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义分页拦截器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">      interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">      <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页插件的工作原理：</p><p>首先将分页参数存放到ThreadLocal中，然后PaginationInterceptor拦截到sql语句后，会先判断这个语句需要进行分页查询。需要的话，从ThreadLocal中取出分页参数重写sql语句，分为select count(*) 和 Limit ，将这2个语句传递给mybatis的执行器进行执行,返回结果</p><h3 id="业务层开发（Service）"><a href="#业务层开发（Service）" class="headerlink" title="业务层开发（Service）"></a>业务层开发（Service）</h3><h4 id="创建数字字典表"><a href="#创建数字字典表" class="headerlink" title="创建数字字典表"></a>创建数字字典表</h4><ul><li><p>关于课程的审核状态、查询状态在查询条件和查询结果中都存在，一个课程的审核状态如果是“审核未通过”那么在课程基本信息表记录“审核未通过”三个字合适吗？</p><ul><li><p>如果将“审核未通过”五个字记录在课程基本信息表中，显示出来的审核状态就是“审核未通过”这五个字，看起来没有什么问题，如果有一天客户想要将审核未通过的记录在显示时改为“未通过”三个字，怎么办？</p><p>这时你可以需要批量处理数据库中记录了，写一个 update 语句，审核状态等于“审核未通过”的全部更新 为“未通过”。看起来解决了问题，如果有一天客户又让改了呢？</p></li><li><p>和审核状态同类的有好多这样的信息，比如：课程状态、课程类型、用户类型等等，这一类数据有一个<strong>共同点</strong>就是它有一些分类项，且这些<strong>分类项较为固定</strong>。针对这些数据，为了提高系统的可扩展性，专门定义数据字典表去维护。</p></li></ul></li></ul><img src="/posts/2c0e2adc/image-20240602161947857.png" class title="如图"><h4 id="编写Service"><a href="#编写Service" class="headerlink" title="编写Service"></a>编写Service</h4><p>参考源码</p><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p>利用postman&#x2F;apifox&#x2F;jmeter测试，也可以使用IDEA自带的<strong>httpclient</strong>进行测试</p><p>这里介绍下httpclient是如何使用的？</p><p>进入controller类，找到http接口对应的方法</p><img src="/posts/2c0e2adc/image-20240602164151145.png" class title="如图"><p>可以看到自己生成了一个.http结尾的文件（即测试用例文档 ），我们可以添加请求参数进行测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 课程查询</span><br><span class="line">POST http://localhost:63040/content/course/list?pageNo=1&amp;pageSize=30</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;auditStatus&quot;: &quot;202004&quot;,</span><br><span class="line">  &quot;courseName&quot;: &quot;JAVA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便保存.http文件 ，我们单独在项目工程的根目录创建一个目录单独存放它们。同时，我们以模块为单位创建.http文件。</p><img src="/posts/2c0e2adc/image-20240602164358399.png" class title="如图"><h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><p>我作为后端人员，设计好接口文档交给前端人员，前后端人员进行并行开发</p><h4 id="前后端跨域问题"><a href="#前后端跨域问题" class="headerlink" title="前后端跨域问题"></a>前后端跨域问题</h4><p>跨域问题的出现-》基于浏览器的同源策略，这个是浏览器的一种安全策略，当从一个地址请求到另一个地址，只要协议、ip、端口号有一个不同，就存在这个跨域问题</p><h4 id="如何解决前后端跨域问题？"><a href="#如何解决前后端跨域问题？" class="headerlink" title="如何解决前后端跨域问题？"></a>如何解决前后端跨域问题？</h4><p>① JSONP</p><p>利用srcipt的src标签实现跨域请求</p><p>② 添加响应头</p><p><strong>服务端在响应头</strong>添加 Access-Control-Allow-Origin：*</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 跨域过虑器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/7 11:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 允许跨域调用的过滤器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">   <span class="comment">//允许白名单域名进行跨域调用</span></span><br><span class="line">   config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">   <span class="comment">//允许跨越发送cookie</span></span><br><span class="line">   config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//放行全部原始头信息</span></span><br><span class="line">   config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">   <span class="comment">//允许所有请求方法跨域调用</span></span><br><span class="line">   config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">   <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">   source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>③ 通过nginx代理</p><p>由于<strong>服务端之间没有跨域</strong>，浏览器通过nginx去访问跨域地址。</p><img src="/posts/2c0e2adc/image-20240602203844755.png" class title="如图"><h3 id="课程分类查询"><a href="#课程分类查询" class="headerlink" title="课程分类查询"></a>课程分类查询</h3>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 退役军人在线培训app项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 退役军人在线培训app项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC项目</title>
      <link href="/posts/8968071b.html"/>
      <url>/posts/8968071b.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/posts/98e6f621.html"/>
      <url>/posts/98e6f621.html</url>
      
        <content type="html"><![CDATA[<h1 id="美团一面凉经（面试时长：1小时14分钟-java开发岗）"><a href="#美团一面凉经（面试时长：1小时14分钟-java开发岗）" class="headerlink" title="美团一面凉经（面试时长：1小时14分钟,java开发岗）"></a>美团一面凉经（面试时长：1小时14分钟,java开发岗）</h1><ul><li>数据库方面：<ul><li>mysql的慢查询优化<ul><li>一个场景题，如何实现分页查询（limit 1,100）到后面查到100万条的数据</li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_54574094/article/details/139253568">MySQL 慢查询优化指南-CSDN博客</a></p><ul><li><h2 id="mysql的死锁如何发生并且如何解决呢？"><a href="#mysql的死锁如何发生并且如何解决呢？" class="headerlink" title="mysql的死锁如何发生并且如何解决呢？"></a>mysql的死锁如何发生并且如何解决呢？</h2></li><li><h2 id="线程池：-实现线程的多种方式，哪种线程能够返回值"><a href="#线程池：-实现线程的多种方式，哪种线程能够返回值" class="headerlink" title="线程池：- 实现线程的多种方式，哪种线程能够返回值"></a>线程池：<br>- 实现线程的多种方式，哪种线程能够返回值</h2></li><li><h2 id="Springboot底层是如何调用tomcat的？"><a href="#Springboot底层是如何调用tomcat的？" class="headerlink" title="Springboot底层是如何调用tomcat的？"></a>Springboot底层是如何调用tomcat的？</h2></li><li><p>消息队列rabbitmq</p><ul><li>你说使用到消息队列，你消息队列为什么只是用rabbitmq呢？你说利用redission解决了分布式事务，那么你又如何通过rabbitmq如何解决这个的呢？</li></ul></li><li><p>redis</p><ul><li>redis的哪些数据类型还可以实现分布式事务？除了你说的setnx</li><li>你说一说redission分布式锁的基本原理，以及其中你说的那个看门狗机制存在的意义？</li></ul></li><li><p>springcloud alibaba那一块关于nacos、feigin、seata的底层原理是啥？</p></li><li><p>手撕一道算法题，合并有序数组？(要求不允许自定义额外的数组用于存放)</p><ul><li>fw，我没写出来写了半天md，我真的是废物属于是</li></ul></li></ul><img src="/posts/98e6f621/image-20240527152721802.png" class title="如图"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接将B里面的数据存储到A里面</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">                A[i] = B[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> A.length;<span class="comment">//数组A的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">indexA</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexB</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i代表数组A的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lengthA - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(indexA &gt;= <span class="number">0</span> &amp;&amp; indexB &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[indexA] &gt;= B[indexB])&#123;</span><br><span class="line">                    A[i] = A[indexA];</span><br><span class="line">                    indexA--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    A[i] = B[indexB];</span><br><span class="line">                    indexB--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(indexA &gt;= <span class="number">0</span> &amp;&amp; indexB &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                A[i] = A[indexA];</span><br><span class="line">                indexA--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(indexA &lt; <span class="number">0</span> &amp;&amp; indexB &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                A[i] = B[indexB];</span><br><span class="line">                indexB--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-tcp/udp</title>
      <link href="/posts/ed70c248.html"/>
      <url>/posts/ed70c248.html</url>
      
        <content type="html"><![CDATA[<h1 id="TCP格式的重要字段"><a href="#TCP格式的重要字段" class="headerlink" title="TCP格式的重要字段"></a>TCP格式的重要字段</h1><img src="/posts/ed70c248/image-20240528150718905.png" class title="如图"><p>序列号：在建立连接时随机生成的数字。解决网络包乱序问题</p><p>确认应答号：下一次期望收到的序号，发送端收到这个确认应答后可以认为在这个序号以前的阿数据都已经被正常接收了，用于解决包丢失的问题</p><p>ACK：除了建立连接时发送的SYN包之外，必须都为1，表示确认收到</p><p>RST：TCP连接发生异常，必须强制断开连接</p><p>SYN：希望建立连接</p><p>FIN：希望断开连接</p><h1 id="谈一谈TCP和UDP（★★★★★）"><a href="#谈一谈TCP和UDP（★★★★★）" class="headerlink" title="谈一谈TCP和UDP（★★★★★）"></a>谈一谈TCP和UDP（★★★★★）</h1><ul><li>相同点<ul><li>都是传输层的2个传输协议</li></ul></li><li>不同点：<ul><li>TCP可靠的，UDP不可靠</li><li>TCP面向连接的，传输数据前建立连接；UDP即刻发送数据</li><li>TCP可以实现拥塞控制、流量控制;UDP没有</li><li>TCP是基于字节流，UDP是按照包的形式</li><li>TCP分片是在传输层，UDP分片是在IP层</li></ul></li><li>各自的适用场景：<ul><li>TCP：FTP文件传输,HTTP&#x2F;HTTPS</li><li>UDP：DNS、视频、音频多媒体通信之类的</li></ul></li></ul><h1 id="说一说TCP的三次握手（★★★★★）"><a href="#说一说TCP的三次握手（★★★★★）" class="headerlink" title="说一说TCP的三次握手（★★★★★）"></a>说一说TCP的三次握手（★★★★★）</h1><p>① 一开始client和服务端都处于closed状态，server打开主动监听某个端口，处于<strong>LISTEN状态</strong></p><p>② client向server发送一个SYN请求,随机初始化自己的client_isn，便进入SYN_SENT状态</p><p>③ server接收到SYN请求后，发送一个响应，随机初始化自己的serve_isn,ack为client_isn+1，并且设置SYN和ACK为1，便进入SYN_RECEIVED状态</p><p>④ client收到服务器的响应后，再给服务器发送一个报文，这个报文ACK为1，且这一次client可以携带数据。client便进入ESTABLISHED状态；server收到后便进入ESTABLISHERD状态</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP/UDP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql题目</title>
      <link href="/posts/4fe508cd.html"/>
      <url>/posts/4fe508cd.html</url>
      
        <content type="html"><![CDATA[<h1 id="高频sql50题目（基础版）"><a href="#高频sql50题目（基础版）" class="headerlink" title="高频sql50题目（基础版）"></a>高频sql50题目（基础版）</h1><p>① sql语句的执行顺序</p><ol><li>FROM：确定数据来源。</li><li>JOIN：连接表。</li><li>ON：指定连接条件。</li><li>WHERE：应用过滤条件来缩小结果集。</li><li>GROUP BY：根据指定的列对结果集进行分组。 如果select中有聚合函数，也会接着执行，代表having就可以使用group by中的聚合函数生成的列</li><li>HAVING：在分组的基础上，应用过滤条件来进一步筛选分组。   但是<strong>HAVING</strong>是过滤聚合值</li><li>SELECT：选择最终需要的列，包括聚合函数和表达式。</li><li>UNION：合并两个或多个SELECT语句的结果集。</li><li>ORDER BY：对结果集进行排序。</li><li>LIMIT：最后，限制返回的记录数量。</li></ol><p>示例：</p><img src="/posts/4fe508cd/image-20240522160644646.png" class title="如图"><p>首先，我们先看下如上<strong>SQL</strong>的执行顺序，如下：</p><ol><li>首先执行 FROM 子句, 从<strong>学生成绩表</strong>中组装数据源的数据。</li><li>执行 WHERE 子句, 筛选<strong>学生成绩表</strong>中所有学生的数学成绩不为 NULL 的数据 。</li><li>执行 GROUP BY 子句, 把<strong>学生成绩表</strong>按 “<strong>班级</strong>“ 字段进行分组。</li><li>计算 avg 聚合函数, 按找每个班级分组求出 <strong>数学平均成绩</strong>。</li><li>执行 HAVING 子句, 筛选出班级 <strong>数学平均成绩</strong>大于 75 分的。</li><li>执行SELECT语句，返回数据，但别着急，还需要执行后面几个步骤。</li><li>执行 ORDER BY 子句, 把最后的结果按 “数学平均成绩” 进行排序。</li><li>执行LIMIT ，限制仅返回3条数据。结合ORDER BY 子句，即返回所有班级中数学平均成绩的前三的班级及其数学平均成绩</li></ol><p>② </p><p>group by 中的字段可以使用别名</p><p>count()和sum()的区别：<a href="https://blog.csdn.net/white_ice/article/details/81451136">https://blog.csdn.net/white_ice/article/details/81451136</a></p><p>count()是无法统计字段为null的行数的</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java相关的知识点</title>
      <link href="/posts/b847b063.html"/>
      <url>/posts/b847b063.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识（1）"><a href="#基础知识（1）" class="headerlink" title="基础知识（1）"></a>基础知识（1）</h1><h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><p>面向对象，三大特性：封装、继承、多态</p><p>利用jvm实现跨平台</p><p>支持多线程</p><p>编译和解释并存</p><h2 id="JVM-和-JDK-和-JRE"><a href="#JVM-和-JDK-和-JRE" class="headerlink" title="JVM 和 JDK 和 JRE"></a>JVM 和 JDK 和 JRE</h2><ul><li>JVM对于不同的系统有不同的JV M实现。使用相同的.class字节码文件，会得到相同的运行结果。实现了跨平台</li><li>J RE 是java运行时环境，他包含JVM和java基础类库</li><li>JDK ，它是提供给开发者进行开发的，它包含了JRE，同时也包含了其他的一些java开发者工具，比如说java源码的编译器javac等</li></ul><h2 id="java是编译和解释并存？"><a href="#java是编译和解释并存？" class="headerlink" title="java是编译和解释并存？"></a>java是编译和解释并存？</h2><ul><li>编译性：将源代码一次性翻译成机器码，开发效率高，执行效率低</li><li>解释性：将源代码一句一句的翻译成机器码，开发效率高，执行效率低</li></ul><img src="/posts/b847b063/image-20240520143239948.png" class title="如图"><h2 id="AOT和JIT"><a href="#AOT和JIT" class="headerlink" title="AOT和JIT"></a>AOT和JIT</h2><ul><li>AOT属于静态编译器，JIT是运行时编译器，在程序执行前就将字节码文件翻译成机器码，JIT是在程序执行时将字节码文件翻译成机器码</li><li>AOT解决了对JIT热点代码预热的开销，同时AOT编译后的代码不容易被反编译和修改，特别适合云原生的场景</li><li>JIT相较于AOT ，它支持反射、动态代理等特性</li></ul><h2 id="JAVA-和-C-的比较"><a href="#JAVA-和-C-的比较" class="headerlink" title="JAVA 和 C++的比较"></a>JAVA 和 C++的比较</h2><ul><li>相同点：<ul><li>都是面向对象的，支持封装、继承、多态</li></ul></li><li>不同点：<ul><li>c++支持多继承，java支持单继承</li><li>java具有垃圾自动回收机制</li><li>java 不提供指针来直接访问内存，安全</li><li>java仅支持方法重载，c++支持方法和操作符重载</li></ul></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>① 有哪几种数据的基本类型</p><p>整数型：byte  short  int long</p><p>浮点型：float  double</p><p>字符型：char</p><p>布尔型：boolean</p><p>② 包装类型的缓存机制</p><p>Byte   Short  Integer  Double  这4个都是[-128,127]  Character[0,127]  Boolean(false    true  )都存在对应的缓存区间</p><p>③ 自动装箱和拆箱</p><ul><li>自动装箱<ul><li>基本数据类型  –&gt; 引用类型   调用包装类的valueOf()</li></ul></li><li>自动拆箱<ul><li>引用类型  –&gt; 基本数据类型  调用了基本数据类型的xxxValue()</li></ul></li></ul><p>④ 浮点数精度丢失问题产生的原因？如何解决？</p><p>计算机底层能采用的是二进制的方式，对于无限循环的小数超过位数就会截断，因此导致精度丢失</p><p>可以利用BigDecimal来解决这个问题</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>① 重写和重载</p><ul><li>重载<ul><li>发生同一个类中，方法名必须相同，但是参数列表、方法返回值类型、访问修饰符可以不同</li></ul></li><li>重写<ul><li>当子类继承父类，子类实现接口的时候，重写其中的方法，要求方法名、参数列表必须相同，返回值类型、抛出的异常大小要小于父类，访问修饰符权限要大于父类</li></ul></li></ul><h1 id="基础知识（2）"><a href="#基础知识（2）" class="headerlink" title="基础知识（2）"></a>基础知识（2）</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>① 面向对象和面向过程</p><ul><li>面向对象：将问题抽象出一个对象，然后通过对象调用方法来解决问题（可扩展、可复用）</li><li>面向过程：将问题直接分解成一个一个的方法，然后利用方法解决问题</li></ul><p>② 面向对象的三大特征</p><ul><li><p>封装</p><ul><li>把一个对象的状态信息隐藏在对象内部，对外只提供一些方法来访问这些属性</li></ul></li><li><p>继承</p><ul><li>子类拥有父类的全部属性和方法，但是对于private修饰的方法和属性，只是拥有，但是不可以访问</li><li>子类可以扩展自己的属性和方法</li><li>子类可以重写父类中的方法</li></ul></li><li><p>多态</p><ul><li>子类继承父类或者子类实现接口，实际上就是父类的引用指向子类的实例对象</li><li>在编译期间，不能调用存在于子类而不存在于父类中的方法</li><li>在运行期间，如果子类中重写该方法，调用的是子类中重写的方法；否则调用的是父类中的方法</li></ul></li></ul><p>③ 接口和抽象类</p><ul><li>相同点<ul><li>都不能被实例化</li><li>都由抽象方法和default实现的方法</li></ul></li><li>区别：<ul><li>接口一般是一种模板的行为规范，抽象类一般用于代码复用</li><li>接口可以多实现，抽象类只能单继承</li><li>构造方法：接口没有，抽象类有</li><li>成员变量：接口都是public static final 修饰的常量，抽象类中默认是default的</li><li>方法：接口默认是public abstract修饰，抽象类则是可以使用其他的权限修饰符</li></ul></li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>① 常见方法有哪些？</p><p>toString()  equals()  hashcode() getClass()等</p><p>② &#x3D;&#x3D; 和 equals()</p><p>&#x3D;&#x3D; 可以用于基本数据类型（比较值是否相等）和引用类型（比较地址是否相同）</p><p>equals 只鞥用于比较引用类型，如果没有重写Object类中的equals()，实际上就是比较两个对象的地址</p><p>重写了的话，实际上比较的是两个对象中的属性是否相等</p><p>③ hashcode() 和 equals()</p><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p><h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String \ StringBuffer \ StringBuilder"></a>String \ StringBuffer \ StringBuilder</h2><p>① 三者的比较</p><ul><li>可变性<ul><li>String是不可变的，StringBuffer 和 StringBuilder是不可变的。这个可变性在于底层的byte[] 是否被final修饰</li></ul></li><li>线程安全<ul><li>String是线程安全的；</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的。前者对于后者在方法上加了同步锁</li></ul></li><li>性能<ul><li>String每次对对象操作，都会产生一个新的对象，然后将指针指向这个新的对象</li><li>StringBuffer 和 StringBuilder 只是对对象本身操作</li></ul></li></ul><p>② String st1 &#x3D; new String(“abc”)  创建了几个对象？</p><p> 当常量池中已经存在abc这个字符串时，就创建一个；不存在的话，创建两个</p><p>③ 常见面试题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = &quot;str&quot;;</span><br><span class="line">String str2 = &quot;ing&quot;;</span><br><span class="line">String str3 = &quot;str&quot; + &quot;ing&quot;;   //常量池中的对象</span><br><span class="line">String str4 = str1 + str2;   //堆中新创建的对象</span><br><span class="line">String str5 = &quot;string&quot;;    //常量池中的对象</span><br><span class="line">System.out.println(str3 == str4);//false</span><br><span class="line">System.out.println(str3 == str5);//true</span><br><span class="line">System.out.println(str4 == str5);//false</span><br><span class="line"></span><br><span class="line">对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。</span><br><span class="line">String str4 = new StringBuilder().append(str1).append(str2).toString();</span><br><span class="line"></span><br><span class="line">不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理</span><br><span class="line">final String str1 = &quot;str&quot;;</span><br><span class="line">final String str2 = &quot;ing&quot;;</span><br><span class="line">// 下面两个表达式其实是等价的</span><br><span class="line">String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象</span><br><span class="line">String d = str1 + str2; // 常量池中的对象</span><br><span class="line">System.out.println(c == d);// true</span><br><span class="line"></span><br><span class="line">如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</span><br><span class="line">final String str1 = &quot;str&quot;;</span><br><span class="line">final String str2 = getStr();</span><br><span class="line">String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象</span><br><span class="line">String d = str1 + str2; // 在堆上创建的新的对象</span><br><span class="line">System.out.println(c == d);// false</span><br><span class="line">public static String getStr() &#123;</span><br><span class="line">      return &quot;ing&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>④ String 的 intern()方法的作用？</p><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将   字符串对象的引用  保存在  字符串常量池</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><h1 id="基础知识（3）"><a href="#基础知识（3）" class="headerlink" title="基础知识（3）"></a>基础知识（3）</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>异常首先分为Exception和Error<ul><li>Error指的是错误，比如说内存溢出，JVM会直接终止程序</li><li>Exception分为编译时异常、运行时异常<ul><li>编译时异常：需要我们在编译时显示的进行处理：try-catch-finally、try-with-resources（用于很多资源需要关闭的时候）或者throw抛出异常</li><li>运行时异常：不需要我们显示处理，一般是我们写的代码逻辑出现问题，比如说空指针异常、数组越界之类的</li></ul></li></ul></li></ul><p>Throwable的常用方法</p><ul><li>getMessage() \ printStackTrace() \ toString()</li></ul><p>finally中的语句一定会执行吗？</p><ul><li>当程序被提前终止的时候，比如System.exit(1)之类的</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li><p>反射大量的运用在框架中，同时使得我们在运行时能够分析类，获取类中的属性和方法，并且可以调用他们</p></li><li><p>在框架中，比如说spring框架和mybatis之类的，都用到了动态代理，这个代理也是依赖于这个反射的。同时注解功能的实现也是依赖于这个反射的</p></li><li><p>优缺点：</p><ul><li>优点：使得代码更加灵活，框架的基础</li><li>缺点：存在安全性的风险，无视了泛型的类型编译，同时反射的话性能差点</li></ul></li><li><p>如何获得这个Class对象？</p><ul><li>类名.class   </li><li>类的实例.getCLass()</li><li>Class.forName()</li><li>通过类加载器.loadClass()</li></ul></li></ul><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>什么时序列化和反序列化？</p><ul><li>序列化：将对象转化为二进制字节流的过程；</li><li>反序列化：将二进制字节流转化为对象的过程</li></ul><p>如何实现序列化</p><ul><li><p>利用JDK自带的序列化机制，实现Seriable接口，</p><ul><li>对于某些属性不想序列化的话，利用static和transient进行修饰</li><li>但是一般不使用，不支持跨语言调用 、序列化后传输的二进制字节流比较大、存在安全问题</li></ul></li><li><p>利用第三方的基于二进制的序列化协议Kryo</p></li></ul><h1 id="集合（底层结构、线程是否安全、）"><a href="#集合（底层结构、线程是否安全、）" class="headerlink" title="集合（底层结构、线程是否安全、）"></a>集合（底层结构、线程是否安全、）</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li>底层的数据结构：Object[]动态数组</li><li>线程安全性：不安全的，可以使用CopyOnWriteArrayList</li><li>增删查的效率<ul><li>查：天然数组，支持随机访问，O(1)</li><li>增：头部O(n)  尾部需要看是否要扩容，o(1)orO(n)   中间O(N)</li><li>删：头部和中间O(N) 尾部o（1）</li></ul></li><li>ArrayList的扩容机制<ul><li>首先从构造器讲起，无参构造器，给Object[]数组初始化为空数组。其他两种的构造器是指定容量和集合</li><li>当我们add第一个元素时，数组容量扩容为10；</li><li>当数组添加的元素知道超过10的时候，会再次进行扩容，因为采用的是&gt;&gt;进行扩容，偶数是1.5倍，奇数约为1.5倍。</li><li>最后利用Arrays.copyof()将原有数组内容复制到新的数组中去</li></ul></li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li>底层的数据结构：双向链表</li><li>线程安全性：不安全的</li><li>增删查的效率：<ul><li>查：O(N)</li><li>增&#x2F;删：头部尾部O(1)，中间先查询在增删O(N)</li></ul></li></ul><h4 id="Vector（线程安全的，其他和arrayList没什么区别）"><a href="#Vector（线程安全的，其他和arrayList没什么区别）" class="headerlink" title="Vector（线程安全的，其他和arrayList没什么区别）"></a>Vector（线程安全的，其他和arrayList没什么区别）</h4><p>底层也是Object[]数组</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>底层数据结构：基于HashMap实现的，所以就转移到讲HashMap的底层</li><li>线程安全：线程不安全的</li><li>元素的插入和取出都是无序、不可重复的</li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>底层数据结构：底层基于LinekdHashMap实现的，所以就转移到LinkedHashMap来讲</li><li>线程安全：线程不安全的</li><li>元素的插入和取出满足FIFO</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li>底层 的数据结构：底层是红黑树</li><li>线程安全：线程不安全的</li><li>可以通过自然排序和定制排序设置自定义排序规则</li></ul><h3 id="Queue（队列，先不看）"><a href="#Queue（队列，先不看）" class="headerlink" title="Queue（队列，先不看）"></a>Queue（队列，先不看）</h3><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li><p><strong>底层的数据结构</strong>：数组+链表+红黑树</p><ul><li>当发生哈希冲突时，添加链表上面，如果此时判断链表的长度&gt;8并且当前数组的长度&lt;64，先进行数组的扩容（扩容为当前数组的2倍），否则，将链表转化为红黑树。</li></ul></li><li><p><strong>线程安全</strong>：不安全的，可以使用<strong>ConcurrentHashMap</strong></p><ul><li>为什么说是线程不安全的？<ul><li>在多线程环境下，进行扩容时会出现<strong>死循环</strong>（jdk8的头插法、换成尾插法就解决了）和<strong>数据覆盖</strong>的问题<ul><li>死循环：jdk7的头插法会导致出现环形链表的情况</li><li>数据覆盖：线程1和线程2同时插入数据，产生哈希冲突，次数就会产生数据覆盖的问题</li></ul></li></ul></li></ul></li><li><p>遍历方式有哪些？</p><ul><li>迭代器interator遍历</li><li>ForEach进行遍历</li><li>streamAPI进行遍历</li></ul></li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li>底层：<strong>HashMap + 双向链表（保证了迭代的顺序）</strong></li><li>相较于HashMap的Entry结构，LinkedHashMap新加了两个元素 before 和 after,用于维护Entry插入的先后顺序</li><li>可以用来实现LRU算法（最近最少使用算法），取决于构造器的标志位accessOrder<ul><li>默认这个accessOrder是false的，采用的是元素的先后到达顺序。</li><li>当我们主动设置为true的时候，采用的是元素访问的先后顺序</li><li>使用LinkedHashMap实现LRU的必要前提是将accessOrder标志位设为true以便开启按访问顺序排序的模式。我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此就把该Entry加入到了双向链表的末尾：get方法通过调用recordAccess方法来实现；put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现。这样，我们便把最近使用的Entry放入到了双向链表的后面。多次操作后，双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除最前面的Entry(head后面的那个Entry)即可，因为它就是最近最少使用的Entry。</li></ul></li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>实现了<strong>NavigableMap接口和SortedMap接口</strong><ul><li>NavigableMap接口的重写方法，可以按照指定的需要来搜索集合内的元素</li><li>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序</li></ul></li></ul><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的</p><p>红黑树（自平衡的排序二叉树）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包工具--fiddler</title>
      <link href="/posts/7b05ffcb.html"/>
      <url>/posts/7b05ffcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="Fiddler简介"><a href="#Fiddler简介" class="headerlink" title="Fiddler简介"></a>Fiddler简介</h1><ul><li>位于客户端和服务器端的HTTP代理</li><li>最常用的http抓包工具</li><li>便于web调试<ul><li>监控浏览器的http&#x2F;https的所有流量</li><li>查看分析请求内容细节</li><li>伪造客户端请求和响应</li><li>解密HTTPS的web会话</li><li>全局、局部断点功能</li></ul></li><li>常用场景：<ul><li>接口调试、接口测试、线上环境测试、web性能分析</li><li>判断前后端bug、开发环境hosts配置、mock、弱网断网测试</li></ul></li></ul><h1 id="Fiddler工作原理"><a href="#Fiddler工作原理" class="headerlink" title="Fiddler工作原理"></a>Fiddler工作原理</h1><p>   主要要去理解HTTP协议，也就是计算机网络关于HTTPS和HTTP那一块的内容</p><h1 id="Fiddler工具详解"><a href="#Fiddler工具详解" class="headerlink" title="Fiddler工具详解"></a>Fiddler工具详解</h1><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p>① 如何抓取HTTPS请求？</p><img src="/posts/7b05ffcb/image-20240521105213847.png" class title="如图"><p>参考链接 ： <a href="https://blog.csdn.net/Mubei1314/article/details/122389950">Fiddler抓包工具保姆级使用教程（超详细）_抓包软件怎么使用-CSDN博客</a></p><p>② 工具栏的详细使用教程</p><ul><li><p>Replay ：  用来重新发送一次请求（多次请求接口）</p><ul><li>R 快捷键：重新发送一次</li><li>SHIFT + R 快捷键 ： 重新发送指定次数</li></ul></li><li><p>× ： 用于移除</p><ul><li>crtl + x ：删除所有的会话</li><li>也可以删除图片的相关请求连接</li></ul></li><li><h2 id="Go"><a href="#Go" class="headerlink" title="Go "></a>Go </h2></li><li><p>Online </p><ul><li>代表本机的一些ip信息</li></ul></li></ul><h2 id="会话列表"><a href="#会话列表" class="headerlink" title="会话列表"></a>会话列表</h2><img src="/posts/7b05ffcb/image-20240521111916172.png" class title="如图"><ul><li>Fiddler抓取到的每条http请求，都称其为一个session</li><li>主要包含请求的ID编号、状态码、协议、主机名、URL、body大小、Caching(是否做了缓存)、内容类型（请求从服务器返回的内容类型）、进程信息、自定义备注信息等</li></ul><img src="/posts/7b05ffcb/image-20240521112203959.png" class title="如图"><h2 id="命令行-状态栏"><a href="#命令行-状态栏" class="headerlink" title="命令行+状态栏"></a>命令行+状态栏</h2><img src="/posts/7b05ffcb/image-20240521114151220.png" class title="如图"><ul><li>首先是这个黑色的框框，用于命令行执行：<ul><li>输入 quick </li><li>高亮包含某个字符的请求 ： ?字符串</li></ul></li></ul><p>更多命令查看官方文档：</p><ul><li><p><a href="https://docs.telerik.com/fiddler/knowledge-base/quickexec">QuickExec Reference - Fiddler Classic (telerik.com)</a></p></li><li><p>Capturing：我们正在捕获会话，</p><ul><li>出现了，表示设置代理</li><li>点击取消消失掉了，表示不设置代理。无法捕捉到会话</li></ul></li><li><p>设置端点</p><ul><li>点击一下，出现的是请求前断点</li><li>点击2下，代表的是响应后断点</li></ul></li></ul><h1 id="辅助标签-工具"><a href="#辅助标签-工具" class="headerlink" title="辅助标签+工具"></a>辅助标签+工具</h1><img src="/posts/7b05ffcb/image-20240521145833258.png" class title="如图"><h2 id="statics统计分析"><a href="#statics统计分析" class="headerlink" title="statics统计分析"></a>statics统计分析</h2><ul><li>HTTP请求的性能和其他数据分析，如DNS解析的时间，建立TCP&#x2F;IP连接的时间消耗等信息</li></ul><img src="/posts/7b05ffcb/image-20240521150507670.png" class title="如图"><h2 id="inspectors检查器"><a href="#inspectors检查器" class="headerlink" title="inspectors检查器"></a>inspectors检查器</h2><ul><li>可以多种方式查看请求的请求报文和响应报文相关信息</li></ul><img src="/posts/7b05ffcb/image-20240521151557017.png" class title="如图"><h2 id="AutoResponder自动响应器"><a href="#AutoResponder自动响应器" class="headerlink" title="AutoResponder自动响应器"></a>AutoResponder自动响应器</h2><ul><li>用于拦截某一请求，进行如下操作<ul><li>重定向到本地的资源 （）</li><li>使用Fiddler的内置响应（fiddler已经提供的一些响应：比如说404 403之类的）</li><li>自定义响应  （右击指定的规则，选择<strong>edit response</strong>）</li></ul></li></ul><h2 id="Composer设计器"><a href="#Composer设计器" class="headerlink" title="Composer设计器"></a>Composer设计器</h2><ul><li>用于设计请求（<strong>简单的接口测试工具</strong>）</li><li>也可以用于回放请求<ul><li>操作步骤：将现有的请求拖动到这个Composer中，会自动填充这个请求的请求方式、url、请求体</li></ul></li></ul><img src="/posts/7b05ffcb/image-20240521160154989.png" class title="如图"><h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><ul><li>用于过滤出你想调试的请求</li></ul><img src="/posts/7b05ffcb/image-20240521161303710.png" class title="如图"><h1 id="断点应用"><a href="#断点应用" class="headerlink" title="断点应用"></a>断点应用</h1><ul><li>应用场景：<ul><li>当我们设置响应后断点， 如我们查询列表，但列表很多数据，我们不想删除，即可把返回的 response 进行截取，删掉返回的信息，观察无数据返回，前端如何显示（<strong>实际上就是可以篡改响应后的内容，放行后在返回给前端</strong>）</li><li>当我们设置响应后中断，这个响应迟迟没有返回给客户都安，我们模拟的便是网络中断这种场景</li></ul></li></ul><h2 id="全局断点"><a href="#全局断点" class="headerlink" title="全局断点"></a>全局断点</h2><ul><li>特点：将所有的请求都会进行断点</li></ul><p>我们一般不使用他</p><h2 id="局部断点"><a href="#局部断点" class="headerlink" title="局部断点"></a>局部断点</h2><ul><li>特点：针对特定的请求设置断点</li></ul><p>利用   <strong>bpu 字符串</strong>  设置   请求前断点  ，再次输入 <strong>bpu</strong> 取消请求前断点</p><p>利用   <strong>bpafter 字符串</strong>  设置   请求前断点  ，再次输入 <strong>bpafter</strong> 取消请求前断点</p><h1 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h1><p>在 rules -&gt; performance -&gt; simulate modem speeds 模拟弱网测试，导致请求的网速非常的慢</p><p>当然，我们自定义设置请求和响应的延迟时间。</p><img src="/posts/7b05ffcb/image-20240521163649302.png" class title="如图"><h1 id="HTTPS抓包"><a href="#HTTPS抓包" class="headerlink" title="HTTPS抓包"></a>HTTPS抓包</h1><img src="/posts/7b05ffcb/image-20240521220647508.png" class title="如图"><h1 id="APP抓包"><a href="#APP抓包" class="headerlink" title="APP抓包"></a>APP抓包</h1><h2 id="抓IOS设备的包"><a href="#抓IOS设备的包" class="headerlink" title="抓IOS设备的包"></a>抓IOS设备的包</h2><img src="/posts/7b05ffcb/image-20240521222305737.png" class title="如图"><img src="/posts/7b05ffcb/image-20240521222648526.png" class title="如图"><img src="/posts/7b05ffcb/image-20240521222911689.png" class title="如图"><h2 id="抓Android设备的包"><a href="#抓Android设备的包" class="headerlink" title="抓Android设备的包"></a>抓Android设备的包</h2><img src="/posts/7b05ffcb/image-20240521221821298.png" class title="如图"><h1 id="fiddler安装一些常用的插件"><a href="#fiddler安装一些常用的插件" class="headerlink" title="fiddler安装一些常用的插件"></a>fiddler安装一些常用的插件</h1><p>fiddler的插件安装中心：</p><p><a href="https://www.telerik.com/fiddler/add-ones">https://www.telerik.com/fiddler/add-ones</a></p><p>比如说我们安装willow插件，这个个插件一般是tools-&gt;hosts 或者说   autoReponder   的加强版</p>]]></content>
      
      
      <categories>
          
          <category> 测试开发 </category>
          
          <category> 抓包工具 </category>
          
          <category> fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试开发 </tag>
            
            <tag> 抓包工具 </tag>
            
            <tag> fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件结构</title>
      <link href="/posts/77d399.html"/>
      <url>/posts/77d399.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPU是如何执行程序的？"><a href="#CPU是如何执行程序的？" class="headerlink" title="CPU是如何执行程序的？"></a>CPU是如何执行程序的？</h1><h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><img src="/posts/77d399/image-20240518152718576.png" class title="如图"><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>存储数据的基本单位是<strong>字节（*byte*）</strong>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p><p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>分为32位和64位：主要区别在于计算机一次能够处理多少个字节数据</p><ul><li>32 位 CPU 一次可以计算 4 个字节；</li><li>64 位 CPU 一次可以计算 8 个字节；</li></ul><p>分为三部分组成：控制器、运算器、寄存器</p><ul><li>控制器：控制CPU工作</li><li>运算器：负责计算</li><li>寄存器：因为CPU离存储器很远，寄存器紧挨着控制器和运算器，加快计算速度<ul><li>通用寄存器：用来存放运算时的数据</li><li>程序计数器：存储下一条指令所在的内存地址</li><li>指令寄存器：存放当前正在执行的指令</li></ul></li></ul><h3 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h3><p>用于CPU和内存、输入输出设备的交互</p><ul><li>地址总线：指定CPU将要操作的内存地址</li><li>控制总线：指定CPU是读操作还是写操作</li><li>数据总线：指定传输的数据</li></ul><h3 id="输入和输出设备"><a href="#输入和输出设备" class="headerlink" title="输入和输出设备"></a>输入和输出设备</h3><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。</p><h2 id="线路位宽和CPU位宽"><a href="#线路位宽和CPU位宽" class="headerlink" title="线路位宽和CPU位宽"></a>线路位宽和CPU位宽</h2><p>线路位宽：最好能够覆盖所有的内存地址，那么实际上就是总线的条数</p><p>CPU位宽：就是CPU的位数，cpu的位数最好能够和线路位宽一致</p><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><img src="/posts/77d399/image-20240518161835654.png" class title="如图"><ul><li>取指令的阶段，我们的指令是存放在<strong>存储器</strong>里的，实际上，通过程序计数器和指令寄存器取出指令的过程，是由<strong>控制器</strong>操作的；</li><li>指令的译码过程，也是由<strong>控制器</strong>进行的；</li><li>指令执行的过程，无论是进行算术操作、逻辑操作，还是进行数据传输、条件分支操作，都是由<strong>算术逻辑单元</strong>操作的，也就是由<strong>运算器</strong>处理的。但是如果是一个简单的无条件地址跳转，则是直接在<strong>控制器</strong>里面完成的，不需要用到运算器。</li></ul><h1 id="存储器的层次关系？"><a href="#存储器的层次关系？" class="headerlink" title="存储器的层次关系？"></a>存储器的层次关系？</h1><p>寄存器、CPU 高速Cache(L1（数据缓存和指令缓存）-&gt;L2-&gt;L3) 、内存、硬盘</p><p>前2个是在CPU内</p><h1 id="如何让CPU跑得更快？"><a href="#如何让CPU跑得更快？" class="headerlink" title="如何让CPU跑得更快？"></a>如何让CPU跑得更快？</h1><p>实际上问的是：<strong>如何提高CPU缓存命中率，</strong>而第一层的L1缓存分为：数据缓存、指令缓存</p><h2 id="如何提高数据缓存的命中率"><a href="#如何提高数据缓存的命中率" class="headerlink" title="如何提高数据缓存的命中率?"></a>如何提高数据缓存的命中率?</h2><p>CPU Cache从内存加载数据时，会一次性顺序加载64字节大小的数据。</p><p>比如说当我们遍历数组时，按照内存布局顺序访问，会提高数据缓存的命中率。</p><h2 id="如何提高指令缓存的命中率？"><a href="#如何提高指令缓存的命中率？" class="headerlink" title="如何提高指令缓存的命中率？"></a>如何提高指令缓存的命中率？</h2><p>有规律的条件分支语句  让CPU 的分支预测器发挥作用。</p><p>这个分支预测器：是可以提前预测到接下来是执行if指令，还是else指令，那么就会将这些指令提前放到指令缓存中，CPU就可以直接从Cache中读取到指令，于是执行速度就会变快。</p><h2 id="如何提高多核CPU-的缓存命中率？"><a href="#如何提高多核CPU-的缓存命中率？" class="headerlink" title="如何提高多核CPU 的缓存命中率？"></a>如何提高多核CPU 的缓存命中率？</h2><p>L1和L2缓存都是每个核所独有的，L3是多个核共享的，但是如果一个线程在多个核之间频繁切换的话，就会导致缓存命中率的降低。</p><p>我们只需要将这个线程绑定到某一个CPU核心上。</p><h1 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h1><p>实际上讲的就是  CPU 高级Cache  和 内存中数据的一致性问题，当我们将数据写入到Cache中，如何及时的将数据也写入到内存中。</p><h2 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h2><p>将数据同时写入到Cache和内存中</p><ul><li>先判断数据是否已经存在于Cache中，先对Cache中的数据进行更新，在将数据写入到内存中</li><li>如果数据没在Cache中，直接把数据写入到内存中</li></ul><p>存在的问题：无论Cache是否存在数据，都会写入到内存中，耗费时间</p><h2 id="写回（没怎么看懂，先记住）"><a href="#写回（没怎么看懂，先记住）" class="headerlink" title="写回（没怎么看懂，先记住）"></a>写回（没怎么看懂，先记住）</h2><p>当CPU写入数据</p><ul><li>观察Cache是否存在该数据<ul><li>存在的话，<strong>将当前数据写入到Cache Block中，并标记为脏的</strong></li><li>不存在的话，定位器对应的Cache Block<ul><li>如果Cache Block为脏的话，将Cache Block中的数据写回到内存中，再将内存中的数据写回到Cchae Bolck中</li><li>Cache Block数据不为脏的话，将内存中的数据读取到Cache Bolock中</li><li><strong>再将当前数据写入到Cache Block中，并标记为脏的</strong></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 硬件结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 硬件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker_portainer管理docker环境</title>
      <link href="/posts/bcb39b5.html"/>
      <url>/posts/bcb39b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Portainer"><a href="#什么是Portainer" class="headerlink" title="什么是Portainer?"></a>什么是Portainer?</h1><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h1 id="Portainer的安装？"><a href="#Portainer的安装？" class="headerlink" title="Portainer的安装？"></a>Portainer的安装？</h1><p>① 在官网下载</p><p>· <a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p>· <a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p><p>② 利用命令配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name portainer     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v portainer_data:/data     portainer/portainer</span><br></pre></td></tr></table></figure><img src="/posts/bcb39b5/image-20240517124453765.png" class title="如图"><p>③ 访问地址</p><p>· 第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> portainer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose容器编排</title>
      <link href="/posts/2e448a15.html"/>
      <url>/posts/2e448a15.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是compose容器编排？"><a href="#什么是compose容器编排？" class="headerlink" title="什么是compose容器编排？"></a>什么是compose容器编排？</h1><p>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排。可以管理多个容器组成一个应用。你需要定义一个YAML格式的配置文件docer-compose.yml，写好各个容器之间的调用关系。只需要一个命令，就能同时启动&#x2F;关闭这些容器</p><h1 id="为什么引入compose容器编排？"><a href="#为什么引入compose容器编排？" class="headerlink" title="为什么引入compose容器编排？"></a>为什么引入compose容器编排？</h1><p> docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h1 id="下载docker-compose"><a href="#下载docker-compose" class="headerlink" title="下载docker-compose"></a>下载docker-compose</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//安装步骤</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br><span class="line"></span><br><span class="line">//卸载docker-compose</span><br><span class="line">sudo rm /user/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1 id="docker-compose核心概念"><a href="#docker-compose核心概念" class="headerlink" title="docker-compose核心概念"></a>docker-compose核心概念</h1><ul><li>文件<ul><li>docker-compose.yml</li></ul></li><li>两要素<ul><li>服务：· 一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</li><li>工程：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</li></ul></li></ul><h1 id="docker-compose使用步骤"><a href="#docker-compose使用步骤" class="headerlink" title="docker-compose使用步骤"></a>docker-compose使用步骤</h1><ul><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 <strong>docker-compose.yml</strong> 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>最后，执行<strong>docker-compose up</strong>命令 来启动并运行整个应用程序，完成一键部署上线</li></ul><h1 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h1><p>Compose常用命令</p><p>docker-compose -h              # 查看帮助</p><p><strong>docker-compose up              # 启动所有docker-compose服务</strong></p><p><strong>docker-compose up -d             # 启动所有docker-compose服务并后台运行</strong></p><p><strong>docker-compose down             # 停止并删除容器、网络、卷、镜像。</strong></p><p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</p><p>docker-compose ps            # 展示当前docker-compose编排过的运行的所有容器</p><p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p><p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p><p>docker-compose config   # 检查配置</p><p>docker-compose config -q # 检查配置，有问题才有输出</p><p>docker-compose restart  # 重启服务</p><p>docker-compose start   # 启动服务</p><p>docker-compose stop    # 停止服务</p><h1 id="docker-compose-yaml文件的基本格式"><a href="#docker-compose-yaml文件的基本格式" class="headerlink" title="docker-compose.yaml文件的基本格式"></a>docker-compose.yaml文件的基本格式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"> </span><br><span class="line">services:</span><br><span class="line">  microService:</span><br><span class="line">    image: zzyy_docker:1.6</span><br><span class="line">    container_name: ms01</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6001:6001&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/microService:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net </span><br><span class="line">    depends_on: </span><br><span class="line">      - redis</span><br><span class="line">      - mysql</span><br><span class="line"> </span><br><span class="line">  redis:</span><br><span class="line">    image: redis:6.0.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/redis/redis.conf:/etc/redis/redis.conf</span><br><span class="line">      - /app/redis/data:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: redis-server /etc/redis/redis.conf</span><br><span class="line"> </span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: &#x27;123456&#x27;</span><br><span class="line">      MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;</span><br><span class="line">      MYSQL_DATABASE: &#x27;db2021&#x27;</span><br><span class="line">      MYSQL_USER: &#x27;zzyy&#x27;</span><br><span class="line">      MYSQL_PASSWORD: &#x27;zzyy123&#x27;</span><br><span class="line">    ports:</span><br><span class="line">       - &quot;3306:3306&quot;</span><br><span class="line">    volumes:</span><br><span class="line">       - /app/mysql/db:/var/lib/mysql</span><br><span class="line">       - /app/mysql/conf/my.cnf:/etc/my.cnf</span><br><span class="line">       - /app/mysql/init:/docker-entrypoint-initdb.d</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password #解决外部无法访问</span><br><span class="line"> </span><br><span class="line">networks: </span><br><span class="line">   atguigu_net: </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker_network</title>
      <link href="/posts/d90544d5.html"/>
      <url>/posts/d90544d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker是什么？"><a href="#docker是什么？" class="headerlink" title="docker是什么？"></a>docker是什么？</h1><h2 id="docker未启动的时候的网络情况"><a href="#docker未启动的时候的网络情况" class="headerlink" title="docker未启动的时候的网络情况"></a>docker未启动的时候的网络情况</h2><img src="/posts/d90544d5/image-20240515150711669.png" class title="如图"><ul><li>virbr0</li></ul><p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，<strong>yum remove libvirt-libs.x86_64</strong></p><h2 id="docker启动后的网络情况"><a href="#docker启动后的网络情况" class="headerlink" title="docker启动后的网络情况"></a>docker启动后的网络情况</h2><p>额外产生一个名为docker0的虚拟网桥</p><img src="/posts/d90544d5/image-20240515150950961.png" class title="如图"><h1 id="docker网络的常用命令"><a href="#docker网络的常用命令" class="headerlink" title="docker网络的常用命令"></a>docker网络的常用命令</h1><ul><li>查看docker 网络模式命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br></pre></td></tr></table></figure><ul><li>查看网络命令的相关帮助</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network --help</span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line">Manage networks</span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br></pre></td></tr></table></figure><p>① 创建一个docker网络(如果未显示指定的话，默认为bridge模式的)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network create aa_network</span><br><span class="line">b4547ce02dd53c330c57cd69ea0b3308656d29079d21491005af278005ca4e03</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class="line">b4547ce02dd5   aa_network   bridge    local</span><br><span class="line">809aef73100e   bridge       bridge    local</span><br><span class="line">edd2f9cef171   host         host      local</span><br><span class="line">248254a65046   none         null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 删除一个docker网络</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network rm aa_network</span><br><span class="line">aa_network</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>③ 查看网络源数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network inspect XXX网络名字</span><br></pre></td></tr></table></figure><h1 id="docker网络的作用"><a href="#docker网络的作用" class="headerlink" title="docker网络的作用"></a>docker网络的作用</h1><p>① 容器间的互联和通信以及端口映射</p><p>② 容器IP变动时候可以通过<strong>服务名</strong>直接网络通信而不受到影响</p><h1 id="docker网络模式有哪几种？"><a href="#docker网络模式有哪几种？" class="headerlink" title="docker网络模式有哪几种？"></a>docker网络模式有哪几种？</h1><p>一共有五种，除了下面常用的<strong>bridge、host、null</strong>,还有<strong>容器模式、自定义模式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br></pre></td></tr></table></figure><img src="/posts/d90544d5/image-20240515155306298.png" class title="如图"><ul><li><p>在运行容器的时候，docker run -d -p 宿主机端口号:容器端口号 –network 网络模式 –name 容器名 镜像名</p><ul><li><p>bridge模式：使用–network  bridge指定，默认使用docker0</p></li><li><p>host模式：使用**–network host**指定</p></li><li><p>none模式：使用–network none指定</p></li><li><p>container模式：使用–network container:NAME或者容器ID指定</p></li><li><p>自定义模式：使用 –network 自定义网络名</p></li></ul></li></ul><h2 id="容器实例内默认网络IP的生产规则"><a href="#容器实例内默认网络IP的生产规则" class="headerlink" title="容器实例内默认网络IP的生产规则"></a>容器实例内默认网络IP的生产规则</h2><p>① 首先启动两个ubuntu容器实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name u1 ubuntu bash</span><br><span class="line">docker run -it --name u1 ubuntu bash</span><br></pre></td></tr></table></figure><p>② docker inspect 容器ID or 容器名字</p><p>主要关注GateWay 和 IPAddress</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker inspect u1 | tail -n 20</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:05&quot;,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;809aef73100e83c199ebb5c8f5eaaf29760e95bfaef5cd35e9e1f470ed77a083&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;0022bb94ab788053271c0763769124bb5ab52da44d04a7b057764e2eea5bce47&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.5&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;DriverOpts&quot;: null,</span><br><span class="line">                    &quot;DNSNames&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>③ 当我们关闭u2,创建u3，发现ip发生了变化</p><p>​docker容器内部的ip是有可能会发生改变的</p><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><img src="/posts/d90544d5/image-20240516085838064.png" class title="如图"><p>每个宿主机上面都会虚拟出一个Docker容器网桥docker0，docker每启动一个容器，根据docjer网桥的网段分配给容器一个IP地址（docker网桥也就是每个容器的默认网关）。</p><p>docker0容器网桥类似一个交换机，上面有一堆接口veth，对应于各自容器的eth0接口，两两匹配</p><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><img src="/posts/d90544d5/image-20240516102952757.png" class title="如图"><ul><li>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</li><li>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于host模式，如何自己在额外设置port映射，会出现警告。 -p 已经不起作用了，端口号会以主机端口号为主，重复时递增</span><br><span class="line"></span><br><span class="line">docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d  --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><ul><li><p>没有之前的端口映射了，那么如何访问启动的tomcat83呢？</p><ul><li><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p></li></ul></li></ul><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>在容器内部查看：</p><img src="/posts/d90544d5/image-20240516110451685.png" class title="如图"><p>在容器外部查看：</p><img src="/posts/d90544d5/image-20240516110520278.png" class title="如图"><h2 id="container网络模式"><a href="#container网络模式" class="headerlink" title="container网络模式"></a>container网络模式</h2><p>新建的容器和<strong>已经存在的一个容器</strong>共享一个网络ip配置而不是和宿主机共享。</p><p>新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p><p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><img src="/posts/d90544d5/image-20240516110856641.png" class title="如图"><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it                                                    --name alpine1  alpine /bin/sh</span><br><span class="line">docker run -it --network container:alpine1 --name alpine2  alpine /bin/sh</span><br></pre></td></tr></table></figure><img src="/posts/d90544d5/image-20240516111113201.png" class title="如图"><p>此时关闭alpine1容器，再查看alpine2的内部网路情况：</p><img src="/posts/d90544d5/image-20240516111326755.png" class title="如图"><h2 id="自定义网络模式"><a href="#自定义网络模式" class="headerlink" title="自定义网络模式"></a>自定义网络模式</h2><p>之前的问题：当我们采用 默认的bridge模式时，各个容器间可以通过ip地址进行相互通信，但是通过服务名无法进行通信。这样存在的问题：一旦网络发生变动，写死ip就无法通信了</p><p>那么采用自定义网络的方式：</p><p>① 创建自定义网络</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network create define-network1</span><br><span class="line">afb5e8dc9025d3bf1e7957b2ccc1fd018651d1a9d90b8f0552c24480f613ddc0</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">b743c8a41ece   bridge            bridge    local</span><br><span class="line">afb5e8dc9025   define-network1   bridge    local</span><br><span class="line">edd2f9cef171   host              host      local</span><br><span class="line">248254a65046   none              null      local</span><br></pre></td></tr></table></figure><p>② 将容器加入到自定义网络</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>③ 容器之间通过服务名可以相互ping通的</p><p>自定义网络本身就维护好了<strong>主机名和ip的对应关系</strong>（ip和域名都能通）</p><h1 id="docker-平台架构图解"><a href="#docker-平台架构图解" class="headerlink" title="docker 平台架构图解"></a>docker 平台架构图解</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="/posts/d90544d5/image-20240516112440017.png" class title="如图"><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><ul><li>整体说明</li></ul><p>从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p><p>Docker 运行的基本流程为：</p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p><p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p><p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p><p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</p><p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p><p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p><p>7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker_network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务实战</title>
      <link href="/posts/a219ce80.html"/>
      <url>/posts/a219ce80.html</url>
      
        <content type="html"><![CDATA[<p>步骤1：利用maven的package打包生成jar包文件（springboot达成的jar天生内嵌了tomcat）</p><p>步骤2：将jar包上传到docker所在的宿主机上面</p><p>步骤3：利用dockerfile（要打包的jar包最好和我们的dockerfile在同一个路径下面）将宿主机中的jar包进行发布，并且部署到docker容器中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dockerfile的内容</span><br><span class="line">#the basis use of java8</span><br><span class="line">FROM openjdk:17</span><br><span class="line">#author</span><br><span class="line">MAINTAINER shenpei</span><br><span class="line"># VOLUME</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># add jar</span><br><span class="line">ADD jwlz-application-sjjczstp.jar zstp.jar</span><br><span class="line"># run jar</span><br><span class="line">RUN bash -c &#x27;touch /zstp.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zstp.jar&quot;]</span><br><span class="line"># expose port</span><br><span class="line">EXPOSE 8897</span><br></pre></td></tr></table></figure><p>​构建镜像（docker build -t 镜像名称:版本号 **.**） ,将其打包成镜像文件</p><p>步骤四：启动镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8897:8897（端口映射） 022e7ef5a58b（镜像id）</span><br></pre></td></tr></table></figure><p>步骤五：测试微服务</p><img src="/posts/a219ce80/image-20240515144412844.png" class title="如图"><p>​</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程</title>
      <link href="/posts/e5954c2f.html"/>
      <url>/posts/e5954c2f.html</url>
      
        <content type="html"><![CDATA[<p>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的<code>运维自动化语言</code>就是 <code>Shell</code> 和 <code>Python</code> 了。</p><p>Shell在运维工作中的服务监控、业务迅速部署、数据备份及其处理中，shell是不可或缺的。</p><p>shell是一个命令解释器，解释执行用户所输入的命令和程序，一输入命令，就立即回应的交互的对话方式。</p><h1 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h1><p>Shell 编程就是对一堆 Linux 命令的逻辑化处理</p><p><img src="/shell%E7%BC%96%E7%A8%8B/image.png" alt="img"></p><h1 id="shell编程的hello-world"><a href="#shell编程的hello-world" class="headerlink" title="shell编程的hello world"></a>shell编程的hello world</h1><p>1⃣️ <a href="http://创建一个helloworld.sh/">创建一个helloworld.sh</a>,扩展名随便写并不影响脚本执行，见名知意就好。</p><p>2⃣️ 使脚本具有执行权限： <code>chmod +x helloworld.sh</code></p><p>3⃣️ 修改helloworld.sh的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 表示单行注释</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><p>shell 中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以</strong>**<code>#!</code>**<strong>开始来指定使用的 shell 类型。在 linux 中，除了 bash shell 以外，还有很多版本的 shell， 例如 zsh、dash 等等…不过 bash shell 还是我们使用最多的。</strong></p><p>4⃣️ 运行脚本文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure><p>（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 <a href="http://helloworld.sh/">helloworld.shopen in new window</a> 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p><h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><p>1⃣️ 分类</p><ul><li><code>自己在shell实例中定义的变量：</code>仅在当前shell实力中有效，其他shell启动的程序</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#自定义变量hello</span></span><br><span class="line">hello=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld!&quot;</span></span><br><span class="line">**Shell 编程中的变量名的命名的注意事项：**</span><br><span class="line"></span><br><span class="line">- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</span><br><span class="line">- 中间不能有空格，可以使用下划线（_）。</span><br><span class="line">- 不能使用标点符号。</span><br><span class="line">- 不能使用 bash 里的关键字（可用 <span class="built_in">help</span> 命令查看保留关键字）。</span><br></pre></td></tr></table></figure><ul><li><p><code>linux已经定义好的环境变量：</code>比如说PATH、HOME等…使用env查看所有的环境变量、set命令既可以查看所有的环境变量又可以查看自定义变量。</p><p><strong>常用的环境变量：</strong></p><p>PATH 决定了 shell 将到哪些目录中寻找命令或程序<br> HOME 当前用户主目录<br> HISTSIZE 　历史记录数<br> LOGNAME 当前用户的登录名<br> HOSTNAME 　指主机的名称<br> SHELL 当前用户 Shell 类型<br> LANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br> MAIL 　当前用户的邮件存放目录<br> PS1 　基本提示符，对于 root 用户是#，对于普通用户是$</p></li><li><p><code>shell变量</code>：shell变量是由shell程序内部提前设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量。</p></li></ul><h1 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h1><ul><li>字符串是shell中最有用的数据类型，字符串可以是单引号，也可以用双引号。</li><li>单引号字符串</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&#x27;SnailClimb&#x27;</span></span><br><span class="line">hello=<span class="string">&#x27;Hello, I am $name!&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">Hello, I am <span class="variable">$name</span>!</span><br></pre></td></tr></table></figure><ul><li>双引号字符串</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&#x27;SnailClimb&#x27;</span></span><br><span class="line">hello=<span class="string">&quot;Hello, I am <span class="variable">$name</span>!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure><ul><li><p>字符串常见操作</p><p>1⃣️ 拼接字符串</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;SnailClimb&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;name&#125; !&#x27;</span>   输出原样</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br><span class="line">2⃣️ 获取字符串长度</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#获取字符串长度</span></span><br><span class="line">name=<span class="string">&quot;SnailClimb&quot;</span></span><br><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span> <span class="comment">#输出 10</span></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line"><span class="built_in">expr</span> length <span class="string">&quot;<span class="variable">$name</span>&quot;</span>;  <span class="comment">#输出10</span></span><br><span class="line">其中，关于这个`<span class="built_in">expr</span>`命令，表达式中的运算符必须包含空格，如果不包含空格，将会输出表达式本身。同时，对于某些运算符，我们需要利用 `符号\ ` 进行转义，否则提示语法错误</span><br><span class="line"><span class="built_in">expr</span> 5 \* 6 <span class="comment">#输出30</span></span><br><span class="line"><span class="built_in">expr</span> 5*6 <span class="comment">#输出5*6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">expr</span> 5 + 6 <span class="comment"># 输出11</span></span><br><span class="line"><span class="built_in">expr</span> 5+6 <span class="comment"># 输出5+6</span></span><br><span class="line">3⃣️ 截取子字符串</span><br><span class="line"></span><br><span class="line">根据下标进行截取</span><br><span class="line"></span><br><span class="line">string：表示源字符串</span><br><span class="line"></span><br><span class="line">start：截取字符串的起始位置，注意第一个字符下标为0</span><br><span class="line"></span><br><span class="line">length：截取字符串的长度</span><br><span class="line"><span class="comment">#从字符串第 1 个字符开始往后截取 10 个字符</span></span><br><span class="line">str=<span class="string">&quot;SnailClimb is a great man&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0:10&#125;</span> <span class="comment">#输出:SnailClimb</span></span><br><span class="line">根据表达式进行截取</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h1><p>1⃣️ 显示普通字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>2⃣️ 显示转义字符</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\&quot;It is a test\&quot;&quot;</span>   <span class="comment"># 结果将是:&quot;It is a test&quot;  同样，双引号也可以省略</span></span><br></pre></td></tr></table></figure><p>3⃣️ 显示变量</p><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span> It is a test&quot;</span></span><br><span class="line"><span class="comment"># 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span></span><br><span class="line">[root@www ~]<span class="comment"># sh test.sh</span></span><br><span class="line">OK                     <span class="comment">#标准输入</span></span><br><span class="line">OK It is a <span class="built_in">test</span>        <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>4⃣ 显示换行 、不换行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \n&quot;</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \c&quot;</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"><span class="comment"># 输出结果：OK! It is a test</span></span><br></pre></td></tr></table></figure><p>5⃣ 将显示结果重定向到文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内容&quot;</span> &gt; 文件名</span><br></pre></td></tr></table></figure><p>6⃣️ 原样输出字符串，不进行转义或者取变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$name\&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果： $name\&quot;</span></span><br></pre></td></tr></table></figure><p>7⃣️ 显示命令执行结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">cat</span> test.sh`</span><br></pre></td></tr></table></figure><h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p>read 命令<code>一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔</code>；如果<code>输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。</code></p><p>测试文件 <a href="http://test.sh/">test.sh</a> 代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> firstStr secondStr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数:<span class="variable">$firstStr</span>; 第二个参数:<span class="variable">$secondStr</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行测试：</span></span><br><span class="line">$ sh test.sh </span><br><span class="line">一 二 三 四</span><br><span class="line">第一个参数:一; 第二个参数:二 三 四</span><br></pre></td></tr></table></figure><p>read常用参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一段文字:&quot;</span> -n 6 -t 5 -s password</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\npassword is <span class="variable">$password</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>-p 输入提示文字</li><li>-n 输入字符长度限制(达到6位，自动结束)</li><li>-t 输入限时</li><li>-s 隐藏输入内容</li></ul><h1 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h1><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p><p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，可以手动添加 \n。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">🔦 printf 命令的语法： printf format-string [arguments...]</span><br></pre></td></tr></table></figure><p>%s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。</p><p>%-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中 .2 指保留2位小数</p><h1 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><p><strong>数值</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p><strong>字符串</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于则为真</td></tr><tr><td>!&#x3D;</td><td>不相等则为真</td></tr><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><p><strong>文件</strong></p><p>参数  说明 -e 文件名  如果文件存在则为真 -r 文件名  如果文件存在且可读则为真 -w 文件名  如果文件存在且可写则为真 -x 文件名  如果文件存在且可执行则为真 -s 文件名  如果文件存在且至少有一个字符则为真 -d 文件名  如果文件存在且为目录则为真 -f 文件名  如果文件存在且为普通文件则为真 -c 文件名  如果文件存在且为字符型特殊文件则为真 -b 文件名  如果文件存在且为块特殊文件则为真</p><h1 id="IF判断"><a href="#IF判断" class="headerlink" title="IF判断"></a>IF判断</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>📍 if else 的 […] 判断语句中大于使用 -gt，小于使用 -lt。</p><p>📍 如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $(ps -ef | grep -c <span class="string">&quot;ssh&quot;</span>) -gt 1 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;true&quot;</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if-else语法格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if-elseif-else语法格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> condition</span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line">   commond1</span><br><span class="line">   commond2</span><br><span class="line"> elseif condition</span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">   commond3</span><br><span class="line"> elseif condition</span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">   commond4</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  commond5</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &gt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &lt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="while语法"><a href="#while语法" class="headerlink" title="while语法"></a>while语法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=<span class="number">5</span> ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;int++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h1><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p><strong>until 语法格式</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> condition  <span class="comment">#condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>📃 参考实例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为：</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>case 取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;; 。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;输入 1 到 4 之间的数字:&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;你输入的数字为:&#x27;</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 1&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 2&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 3&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 4&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">&#x27;你没有输入 1 到 4 之间的数字&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h1 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h1><p>break 命令允许跳出所有循环（终止执行后面的所有循环）。</p><p>continue 命令与 break 命令类似，它不会跳出所有循环，仅仅跳出当前循环。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字:&quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;结束&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>basename 基本语法： <strong>basename [string &#x2F; pathname] [suffix]</strong></p><p>basename 命令会删掉所有的前缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。</p><p>basename 可以理解为取路径里的文件名称.</p><p>suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 截取该/home/user1/banzhang.txt 路径的文件名称</span></span><br><span class="line">[root@Demo shells]$ <span class="built_in">basename</span> /home/user1/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[root@Demo shells]$ <span class="built_in">basename</span> /home/user1/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname 文件绝对路径</span><br></pre></td></tr></table></figure><p>从给定的包含绝对路径的文件名中去除文件名，然后返回剩下的路径。</p><p><code>dirname</code> 可以理解为<strong>取文件路径的绝对路径名称。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 banzhang.txt 文件的路径</span></span><br><span class="line">[atguigu@hadoop101 ~]$ <span class="built_in">dirname</span> /home/user1/banzhang.txt</span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>带function</strong> fun() 定义，也可以<strong>直接fun() 定义</strong>,不带任何参数。</p><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这个函数会对输入的两个数字进行相加运算...&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第一个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第二个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入的两个数字之和为 $? !&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类似下面：</span></span><br><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br><span class="line"></span><br><span class="line"><span class="comment"># $10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当n&gt;=10时，需要使用$&#123;n&#125;来获取参数。</span></span><br></pre></td></tr></table></figure><p><img src="/shell%E7%BC%96%E7%A8%8B/image-17155867092981.png" alt="img"></p><h1 id="输入、输出重定向"><a href="#输入、输出重定向" class="headerlink" title="输入、输出重定向"></a>输入、输出重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p><strong>语法：</strong><code>command1 &gt; file1</code></p><p>上面这个命令执行command1然后将输出的内容存入file1。</p><p>任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;AAAAA&quot;</span> &gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">AAAAA</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;AAAAA&quot;</span> &gt;&gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">AAAAA</span><br><span class="line">AAAAA</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p><strong>语法：</strong> <code>command1 &lt; file1</code></p><p>📃 参考实例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</span></span><br><span class="line">$ <span class="built_in">wc</span> -l <span class="built_in">users</span></span><br><span class="line">       2 <span class="built_in">users</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">#也可以将输入重定向到 users 文件：</span></span><br><span class="line"></span><br><span class="line">$  <span class="built_in">wc</span> -l &lt; <span class="built_in">users</span></span><br><span class="line">       2        </span><br><span class="line"><span class="comment"># 上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</span></span><br><span class="line">command1 &lt; infile &gt; outfile </span><br></pre></td></tr></table></figure><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><p>👉 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</p><p>👉 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</p><p>👉 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;file</span><br></pre></td></tr></table></figure><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;&gt;file</span><br></pre></td></tr></table></figure><p>表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><p>$ command &gt; file 2&gt;&amp;1</p><p>$ command &gt;&gt; file 2&gt;&amp;1</p><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><p>$ command &lt; file1 &gt;file2</p><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><h1 id="简单正则式"><a href="#简单正则式" class="headerlink" title="简单正则式"></a>简单正则式</h1><p>正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在 Linux 中，grep，sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。</p><p><strong>^匹配一行的开头字母</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep ^a </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会匹配出所有以 a 开头的行</span></span><br></pre></td></tr></table></figure><p><strong>$匹配一行的结束</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep t$</span><br><span class="line"># 会匹配出所有以 t 结尾的行</span><br></pre></td></tr></table></figure><p><strong>.匹配一个任意的字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep r..t</span><br><span class="line"># 会匹配包含 rabt,rbbt,rxdt,root 等的所有行</span><br></pre></td></tr></table></figure><p>*<strong>不单独使用，他和上一个字符连用，表示匹配上一个字符0次或多次</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep ro*t</span><br><span class="line"># 会匹配 rt, rot, root, rooot, roooot 等所有行</span><br></pre></td></tr></table></figure><p><strong>字符区间（中括号）：[ ]</strong></p><ul><li><code>[ ] 表示匹配某个范围内的一个字符</code></li><li>[6,8] —— 匹配 6 或者 8</li><li>[0-9] —— 匹配一个 0-9 的数字</li><li>[0-9]* —— 匹配任意长度的数字字符串</li><li>[a-z] ——匹配一个 a-z 之间的字符</li><li>[a-z]* —— 匹配任意长度的字母字符串</li><li>[a-c, e-f] —– 匹配 a-c 或者 e-f 之间的任意字符</li></ul><p><strong>\代表转义</strong></p><p>由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep ‘a\$b’ </span><br><span class="line"># 就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来</span><br></pre></td></tr></table></figure><h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a><strong>cut命令</strong></h2><p>cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。</p><p>cut 命令：从文件的每一行剪切<strong>字节、字符和字段</strong>并将这些字节、字符和字段<strong>输出</strong>。</p><p>🌊 <strong>语法：</strong> <code>cut [参数] [file]</code></p><p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p><ul><li>-b   以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<ul><li>-n 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li></ul></li><li>-c 以字符为单位进行分割。</li><li>-d 自定义分隔符 ，默认为制表符<ul><li>-f 与-d一起使用，指定显示哪个区域</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当执行<span class="built_in">who</span>命令时，会输出类似如下的内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span></span></span><br><span class="line">rocrocket :0           2009-01-08 11:07</span><br><span class="line">rocrocket pts/0        2009-01-08 11:23 (:0.0)</span><br><span class="line">rocrocket pts/1        2009-01-08 14:15 (:0.0)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我们想提取每一行的第3个字节，如下：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>|<span class="built_in">cut</span> -b 3</span></span><br><span class="line">c</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><strong>文件包含（被包含的文件不需要具有可执行权限）</strong></p><p>Shell 脚本文件内部也可以<strong>包含外部脚本</strong>。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. filename # 注意 . 和 文件名之间有一个空格</span><br><span class="line">source filename c</span><br></pre></td></tr></table></figure><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a><strong>sed命令</strong></h2><p>作用：利用脚本文件或者脚本指令 来处理输入的<strong>文本文件</strong></p><p>🌊 <strong>语法：</strong> <code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e &lt;script脚本命令&gt;</td><td>以选项中指定的script来处理输入的文本文件,如果省略的话，默认采用’ ‘</td></tr><tr><td>-f&lt;script文件&gt;</td><td>以选项中指定的script文件来处理输入的文本文件</td></tr><tr><td>-h</td><td>显示帮助</td></tr><tr><td>-n</td><td>仅显示script处理后的结果</td></tr><tr><td>-V</td><td>显示版本信息</td></tr></tbody></table><p>动作说明<br>a           新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>c           取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d    删除，因为是删除，所以 d 后面通常不接任何东西；<br>i插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)<br>p打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行<br>s取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式</p><p>① 行为单位进行新增 &#x2F; 删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -e 4a\newLine 输入的文件名</span><br><span class="line">nl testfile | sed &#x27;2a drink tea&#x27; # 在第2行加入一行内容为 drink tea</span><br><span class="line">nl testfile | sed &#x27;2a drink tea or ...\drink bean&#x27; #在第2行加入2行</span><br><span class="line"># 在文件的第4行新增一行内容--newline</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sed 的动作为 2,5d， d 是删除的意思，因为删除了 2-5 行，所以显示的数据就没有 2-5 行，原本应该是要下达 sed -e 才对，但没有 -e 也是可以的，同时也要注意的是， sed 后面接的动作，请以 ‘…’ 两个单引号括住</span><br><span class="line">nl testfile | sed &#x27;2,5d&#x27;  # 将testfile的内容列出并且列出行号，同时将2，5行的内容删除</span><br><span class="line">nl testfile | sed &#x27;2d&#x27;</span><br><span class="line">nl testfile | sed &#x27;2,$d&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 以行为单位进行替换和显示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed &#x27;2,5c 替换的内容&#x27;</span><br><span class="line">nl testfile | sed -n &#x27;5,7p&#x27;</span><br></pre></td></tr></table></figure><p>③ 数据的搜索并  显示 || 删除 || 执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed -n &#x27;/oo/p&#x27;  #搜索testfile有oo关键字的行</span><br><span class="line">nl testfile | sed -n &#x27;/oo/d&#x27; #搜索testfile所有包含oo的行并且删除，其他行进行显示</span><br><span class="line">nl testfile | sed -n &#x27;/oo&#123;s/oo/kk/;p;q&#125;&#x27;  # 所有所有包含oo的内容。利用kk替换oo，在执行p;在执行q退出命令</span><br></pre></td></tr></table></figure><p>④ 数据的查找和替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sed 的查找与替换的与 vi 命令类似，语法格式如下</span><br><span class="line">sed &#x27;s/要被取代的字串/新的字串/g&#x27;  </span><br><span class="line"></span><br><span class="line"># 将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换</span><br><span class="line">sed -e &#x27;s/oo/kk/&#x27; testfile</span><br><span class="line"></span><br><span class="line"># 将 testfile 文件中所有符合条件出现的 oo 用字符串 kk 替换</span><br><span class="line">sed -e &#x27;s/oo/kk/g&#x27; testfile </span><br><span class="line"></span><br><span class="line"># 选项i使sed 修改文件</span><br><span class="line">sed -i &#x27;s/oo/kk/g&#x27; testfile</span><br><span class="line">sed -i &#x27;s/oo/kk/g&#x27; ./test*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⑤ 多点编辑 （-e）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed -e &#x27;3,$d&#x27; -e &#x27;s/HEELO/RUNOOB/&#x27; # 先删除第三行到末尾的数据，再进行指定内容的替换</span><br></pre></td></tr></table></figure><p>⑥ 直接修改文件内容 (-i)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\.$/\!/g&#x27; testfile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/posts/b73e5edc.html"/>
      <url>/posts/b73e5edc.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="Pro-102-二叉树的层序遍历"><a href="#Pro-102-二叉树的层序遍历" class="headerlink" title="Pro 102 二叉树的层序遍历"></a>Pro 102 二叉树的层序遍历</h2><p>递归</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//递归求解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node表示当前节点，level表示第几层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(TreeNode node,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = res.get(level-<span class="number">1</span>);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        levelOrder1(node.left,level);</span><br><span class="line">        levelOrder1(node.right,level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-107-二叉树的层次遍历II"><a href="#Pro-107-二叉树的层次遍历II" class="headerlink" title="Pro 107 二叉树的层次遍历II"></a>Pro 107 二叉树的层次遍历II</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//递归求解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node表示当前节点，level表示第几层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(TreeNode node,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = res.get(level-<span class="number">1</span>);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        levelOrder1(node.left,level);</span><br><span class="line">        levelOrder1(node.right,level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-199-二叉树的右视图"><a href="#Pro-199-二叉树的右视图" class="headerlink" title="Pro 199 二叉树的右视图"></a>Pro 199 二叉树的右视图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归，深度优先遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        rightSideView1(root,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; list : temp)&#123;</span><br><span class="line">            res.add(list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightSideView1</span><span class="params">(TreeNode node,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() &lt; level)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            temp.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = temp.get(level - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        list.add(node.val);</span><br><span class="line">        rightSideView1(node.left,level);</span><br><span class="line">        rightSideView1(node.right,level);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-637-二叉树的平均值"><a href="#Pro-637-二叉树的平均值" class="headerlink" title="Pro 637 二叉树的平均值"></a>Pro 637 二叉树的平均值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        averageOfLevels1(root,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.size();i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = temp.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.add(sum / len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">averageOfLevels1</span><span class="params">(TreeNode root,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            temp.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = temp.get(level-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        averageOfLevels1(root.left,level);</span><br><span class="line">        averageOfLevels1(root.right,level);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-429-N叉树的层序遍历"><a href="#Pro-429-N叉树的层序遍历" class="headerlink" title="Pro 429 N叉树的层序遍历"></a>Pro 429 N叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(Node root,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = res.get(level - <span class="number">1</span>);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            levelOrder1(node,level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-515-在每个树中找出最大值"><a href="#Pro-515-在每个树中找出最大值" class="headerlink" title="Pro 515 在每个树中找出最大值"></a>Pro 515 在每个树中找出最大值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        largestValues1(root,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; list : res)&#123;</span><br><span class="line">            result.add(Collections.max(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">largestValues1</span><span class="params">(TreeNode root,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = res.get(level - <span class="number">1</span>);</span><br><span class="line">        list.add(root.val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        largestValues1(root.left,level);</span><br><span class="line">        largestValues1(root.right,level);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-116和117-填充每个节点的下一个右侧节点指针"><a href="#Pro-116和117-填充每个节点的下一个右侧节点指针" class="headerlink" title="Pro 116和117 填充每个节点的下一个右侧节点指针"></a>Pro 116和117 填充每个节点的下一个右侧节点指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Node&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        connect1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Node&gt; list : res)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                list.get(i).next = list.get(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(size - <span class="number">1</span>).next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect1</span><span class="params">(Node node,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = res.get(level - <span class="number">1</span>);</span><br><span class="line">        list.add(node);</span><br><span class="line">        connect1(node.left,level);</span><br><span class="line">        connect1(node.right,level);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-104-二叉树的最大深度"><a href="#Pro-104-二叉树的最大深度" class="headerlink" title="Pro 104 二叉树的最大深度"></a>Pro 104 二叉树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxDepth1</span><span class="params">(TreeNode root,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        depth = Math.max(depth,level);</span><br><span class="line">        maxDepth1(root.left,level);</span><br><span class="line">        maxDepth1(root.right,level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-二叉树的最小深度"><a href="#Pro-二叉树的最小深度" class="headerlink" title="Pro 二叉树的最小深度"></a>Pro 二叉树的最小深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        minDepth1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//level代表树的当前层次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minDepth1</span><span class="params">(TreeNode node, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        level++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) res = Math.min(res,level);</span><br><span class="line">        minDepth1(node.left,level);</span><br><span class="line">        minDepth1(node.right,level);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//利用迭代进行求解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">//当队列不为空时</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();<span class="comment">//代表当前层的节点数量</span></span><br><span class="line">            <span class="keyword">for</span>(;size &gt; <span class="number">0</span>;size--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><h2 id="Pro-226-翻转二叉树"><a href="#Pro-226-翻转二叉树" class="headerlink" title="Pro 226 翻转二叉树"></a>Pro 226 翻转二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归(前序遍历、后序遍历、中序遍历)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        invertTree1(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invertTree1</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        invertTree1(node.left);</span><br><span class="line">        invertTree1(node.right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span>  <span class="operator">=</span> queue.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//控制每一层的节点数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><h2 id="Pro-101-对称二叉树"><a href="#Pro-101-对称二叉树" class="headerlink" title="Pro 101 对称二叉树"></a>Pro 101 对称二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//采用递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric1(root.left,root.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetric1</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right !=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span> &amp;&amp; left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res1</span> <span class="operator">=</span> isSymmetric1(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> isSymmetric1(left.right,right.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1 &amp;&amp; res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用迭代--层序遍历</span></span><br><span class="line"><span class="comment">//使用普通队列Queue ，也可以使用双端队列Dqueue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1 != <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span> &amp;&amp; node1.val != node2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-100相同的树"><a href="#Pro-100相同的树" class="headerlink" title="Pro 100相同的树"></a>Pro 100相同的树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span> &amp;&amp; p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res1</span> <span class="operator">=</span> isSameTree(p.left,q.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> isSameTree(p.right,q.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1 &amp;&amp; res2; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-572-另一颗树的子树"><a href="#Pro-572-另一颗树的子树" class="headerlink" title="Pro 572 另一颗树的子树"></a>Pro 572 另一颗树的子树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历 + 递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            <span class="comment">//根节点不同，就没有递归比较的必要了</span></span><br><span class="line">            <span class="keyword">if</span>(node.val != subRoot.val)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> isSubtree1(node,subRoot);</span><br><span class="line">                <span class="keyword">if</span>(res) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个root都遍历完了，还没有找到符合对比的子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个树是否相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtree1</span><span class="params">(TreeNode tree1,TreeNode tree2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree1 == <span class="literal">null</span> &amp;&amp; tree2 != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree1 != <span class="literal">null</span> &amp;&amp; tree2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree1 != <span class="literal">null</span> &amp;&amp; tree2 != <span class="literal">null</span> &amp;&amp; tree1.val != tree2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree1 == <span class="literal">null</span> &amp;&amp; tree2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res1</span> <span class="operator">=</span> isSubtree1(tree1.left,tree2.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> isSubtree1(tree1.right,tree2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1 &amp;&amp; res2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="Pro-104-二叉树的最大深度-1"><a href="#Pro-104-二叉树的最大深度-1" class="headerlink" title="Pro 104 二叉树的最大深度"></a>Pro 104 二叉树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftLen,rightLen) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            </span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-559-n叉树的最大深度"><a href="#Pro-559-n叉树的最大深度" class="headerlink" title="Pro 559 n叉树的最大深度"></a>Pro 559 n叉树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> maxDepth(node);</span><br><span class="line">            depth = Math.max(depth,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><h2 id="Pro-111-二叉树的最小深度"><a href="#Pro-111-二叉树的最小深度" class="headerlink" title="Pro 111 二叉树的最小深度"></a>Pro 111 二叉树的最小深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定单层递归的逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span> + rightLen;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span> + leftLen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(leftLen,rightLen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><h2 id="Pro-222-完全二叉树的节点个数"><a href="#Pro-222-完全二叉树的节点个数" class="headerlink" title="Pro 222 完全二叉树的节点个数"></a>Pro 222 完全二叉树的节点个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNodes</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNodes</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftNodes + rightNodes + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="Pro-110-平衡二叉树"><a href="#Pro-110-平衡二叉树" class="headerlink" title="Pro 110 平衡二叉树"></a>Pro 110 平衡二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (isBalanced1(root) != -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">isBalanced1</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> isBalanced1(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftLen == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> isBalanced1(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightLen == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单层递归的逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftLen - rightLen) &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftLen,rightLen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><h2 id="Pro-257-二叉树的所有路径"><a href="#Pro-257-二叉树的所有路径" class="headerlink" title="Pro 257 二叉树的所有路径"></a>Pro 257 二叉树的所有路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        binaryTreePaths1(root,path,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">binaryTreePaths1</span><span class="params">(TreeNode root,List&lt;Integer&gt; path,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size();i++)&#123;</span><br><span class="line">                sb.append(path.get(i));</span><br><span class="line">                <span class="keyword">if</span>(i != path.size() - <span class="number">1</span>) sb.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            binaryTreePaths1(root.left,path,res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            binaryTreePaths1(root.right,path,res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代（利用栈求解没有问题），但是我利用队列就出现超出时间限制的问题</span></span><br><span class="line">不理解Md</span><br></pre></td></tr></table></figure><h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><h3 id="Pro-404-左叶子之和"><a href="#Pro-404-左叶子之和" class="headerlink" title="Pro 404 左叶子之和"></a>Pro 404 左叶子之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前返回，避免进行没必要的递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) leftNum = root.left.val;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftNum + rightNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                res += node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;go</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><h2 id="Pro-513-找树左下角的值"><a href="#Pro-513-找树左下角的值" class="headerlink" title="Pro 513 找树左下角的值"></a>Pro 513 找树左下角的值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//迭代法  最简单能够实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            res = node.val;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        findBottomLeftValue1(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findBottomLeftValue1</span><span class="params">(TreeNode node,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(length &gt; max_length)&#123;</span><br><span class="line">                max_length = length;</span><br><span class="line">                res = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            findBottomLeftValue1(node.left,length);</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            findBottomLeftValue1(node.right,length);</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><h2 id="Pro-112-路径总和"><a href="#Pro-112-路径总和" class="headerlink" title="Pro 112 路径总和"></a>Pro 112 路径总和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">haspathsum</span><span class="params">(treenode root, <span class="type">int</span> targetsum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetsum -= root.val;</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetsum == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> haspathsum(root.left, targetsum);</span><br><span class="line">            <span class="keyword">if</span> (left) &#123;      <span class="comment">// 已经找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> haspathsum(root.right, targetsum);</span><br><span class="line">            <span class="keyword">if</span> (right) &#123;     <span class="comment">// 已经找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stack1.push(root);</span><br><span class="line">        stack2.push(root.val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack1.size();</span><br><span class="line">    </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value == targetSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack1.push(node.right);</span><br><span class="line">                stack2.push(node.right.val + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack1.push(node.left);</span><br><span class="line">                stack2.push(node.left.val + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-113-路经总和II"><a href="#Pro-113-路经总和II" class="headerlink" title="Pro 113 路经总和II"></a>Pro 113 路经总和II</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        pathSum1(root,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pathSum1</span><span class="params">(TreeNode node,List&lt;Integer&gt; list,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">             <span class="comment">//提前比较，实现减枝操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer a : list)&#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            pathSum1(node.left,list,targetSum);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            pathSum1(node.right,list,targetSum);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack1.push(root);</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        stack2.push(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">            List&lt;Integer&gt; temp1 = stack2.pop();</span><br><span class="line">            <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(Integer a : temp1)&#123;</span><br><span class="line">                    sum += a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum == targetSum)&#123;</span><br><span class="line">                    res.add(temp1);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack1.push(node.right);</span><br><span class="line">                List&lt;Integer&gt; temp2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp1);</span><br><span class="line">                temp2.add(node.right.val);</span><br><span class="line">                stack2.push(temp2);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack1.push(node.left);</span><br><span class="line">                List&lt;Integer&gt; temp3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp1);</span><br><span class="line">                temp3.add(node.left.val);</span><br><span class="line">                stack2.push(temp3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-27–6-02"><a href="#5-27–6-02" class="headerlink" title="5.27–6.02"></a>5.27–6.02</h1><h2 id="①-从中序和后序遍历序列构造出对应的二叉树（106）"><a href="#①-从中序和后序遍历序列构造出对应的二叉树（106）" class="headerlink" title="① 从中序和后序遍历序列构造出对应的二叉树（106）"></a>① 从中序和后序遍历序列构造出对应的二叉树（106）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            node.val = postorder[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先从后序遍历中找到中间节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middleNode</span> <span class="operator">=</span> postorder[postorder.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        node.val = middleNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先划分中序的左右部分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == middleNode) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] middleLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] middleRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - index - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; middleLeft.length  ;i++)&#123;</span><br><span class="line">            middleLeft[i] = inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; middleRight.length;i++)&#123;</span><br><span class="line">            middleRight[i] = inorder[index + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在划分后序的左右部分</span></span><br><span class="line">        <span class="type">int</span>[] behindLeft = <span class="keyword">new</span> <span class="title class_">int</span>[middleLeft.length];</span><br><span class="line">        <span class="type">int</span>[] behindRight = <span class="keyword">new</span> <span class="title class_">int</span>[middleRight.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; behindLeft.length;i++)&#123;</span><br><span class="line">            behindLeft[i] = postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; behindRight.length;i++)&#123;</span><br><span class="line">            behindRight[i] = postorder[behindLeft.length + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = buildTree(middleLeft,behindLeft);</span><br><span class="line">        node.right = buildTree(middleRight,behindRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-从中序和前序序列构造出对应的二叉树"><a href="#②-从中序和前序序列构造出对应的二叉树" class="headerlink" title="② 从中序和前序序列构造出对应的二叉树"></a>② 从中序和前序序列构造出对应的二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder == <span class="literal">null</span> || inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先从前序中找出中间的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        node.val = preorder[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(inorder.length == <span class="number">1</span>) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先划分中序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == node.val) index = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] inorderLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] inorderRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - index - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorderLeft.length;i++)&#123;</span><br><span class="line">            inorderLeft[i] = inorder[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorderRight.length;i++)&#123;</span><br><span class="line">            inorderRight[i] = inorder[index + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在划分前序</span></span><br><span class="line">        <span class="type">int</span>[] preorderLeft = <span class="keyword">new</span> <span class="title class_">int</span>[inorderLeft.length];</span><br><span class="line">        <span class="type">int</span>[] preorderRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorderRight.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; preorderLeft.length;i++)&#123;</span><br><span class="line">            preorderLeft[i] = preorder[<span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; preorderRight.length;i++)&#123;</span><br><span class="line">            preorderRight[i] = preorder[preorderLeft.length + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        node.left = buildTree(preorderLeft,inorderLeft);</span><br><span class="line">        node.right = buildTree(preorderRight,inorderRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-最大二叉树-pRO-654"><a href="#③-最大二叉树-pRO-654" class="headerlink" title="③ 最大二叉树(pRO 654)"></a>③ 最大二叉树(pRO 654)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            node.val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出数组中的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            maxNum = Math.max(nums[i],maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == maxNum) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        node.val = maxNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - index - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left.length;i++)&#123;</span><br><span class="line">            left[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; right.length;i++)&#123;</span><br><span class="line">            right[i] = nums[index + i + <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = constructMaximumBinaryTree(left);</span><br><span class="line">        node.right = constructMaximumBinaryTree(right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-合并二叉树-Pro-617"><a href="#④-合并二叉树-Pro-617" class="headerlink" title="④ 合并二叉树(Pro 617)"></a>④ 合并二叉树(Pro 617)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            node = root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            node = root2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            node.val = root1.val + root2.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.left = mergeTrees(<span class="literal">null</span>,root2.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.left = mergeTrees(root1.left,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = mergeTrees(<span class="literal">null</span>,root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = mergeTrees(root1.right,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化的j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都这里代表，root1和root2都不为null</span></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-验证二叉搜索树（Pro-98）"><a href="#⑤-验证二叉搜索树（Pro-98）" class="headerlink" title="⑤ 验证二叉搜索树（Pro 98）"></a>⑤ 验证二叉搜索树（Pro 98）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNum</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历啊</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; maxNum)&#123;</span><br><span class="line">            maxNum = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-二叉搜索树的最小绝对差（Pro-530）"><a href="#⑥-二叉搜索树的最小绝对差（Pro-530）" class="headerlink" title="⑥ 二叉搜索树的最小绝对差（Pro 530）"></a>⑥ 二叉搜索树的最小绝对差（Pro 530）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        getMinimumDifference1(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getMinimumDifference1</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        getMinimumDifference1(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.min(node.val - pre,res);</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinimumDifference1(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转化为有序数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//利用中序遍历获得这个有序的数组</span></span><br><span class="line">        getMinimumDifference1(root);</span><br><span class="line">        Integer nums[] = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            res = Math.min(res,nums[i + <span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getMinimumDifference1</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) getMinimumDifference1(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) getMinimumDifference1(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-03–6-09"><a href="#6-03–6-09" class="headerlink" title="6.03–6.09"></a>6.03–6.09</h1><h2 id="①-Pro-501-二叉搜索树的众数"><a href="#①-Pro-501-二叉搜索树的众数" class="headerlink" title="① Pro 501 二叉搜索树的众数"></a>① Pro 501 二叉搜索树的众数</h2><p>关于二叉搜索树–&gt;中序遍历</p><p>双指针来实现</p><h2 id="②-二叉树的最近公共祖先"><a href="#②-二叉树的最近公共祖先" class="headerlink" title="② 二叉树的最近公共祖先"></a>② 二叉树的最近公共祖先</h2><p>思路：</p><p>从下往上遍历，利用<strong>后序</strong>的回溯特性</p><p>分为两种情况：</p><p>当某个节点node，分别从左右子树各自找到其中一个p,q节点，代表这个节点node就是p,q节点的公共祖先</p><p>某个节点p或者q就是公共祖先，直接返回即可。</p><h2 id="③-二叉排序树的最近公共祖先"><a href="#③-二叉排序树的最近公共祖先" class="headerlink" title="③ 二叉排序树的最近公共祖先"></a>③ 二叉排序树的最近公共祖先</h2><p>也可以使用普通二叉树求解最近公共祖先的思维求解</p><p>最好利用到二叉搜索树的<strong>有序特性</strong></p><p>存在这样的而一个节点，如果这个节点的值在[p,q]之间的话，就代表他一定是二叉搜素树的最近公共祖先。</p><h2 id="④-二叉搜索树中的插入操作-Pro-701"><a href="#④-二叉搜索树中的插入操作-Pro-701" class="headerlink" title="④ 二叉搜索树中的插入操作 Pro 701"></a>④ 二叉搜索树中的插入操作 Pro 701</h2><p>我的解法一：是永远可以插入在叶子节点，只要找到符合条件的叶子节点，在其空的位置插入即可</p><h1 id="6-12-6-19"><a href="#6-12-6-19" class="headerlink" title="6.12-6.19"></a>6.12-6.19</h1><h3 id="①-删除二叉搜索树中的节点"><a href="#①-删除二叉搜索树中的节点" class="headerlink" title="① 删除二叉搜索树中的节点"></a>① 删除二叉搜索树中的节点</h3><p>比二叉搜索树的插入还困难一点，因为删除节点后还涉及到，原来二叉搜索树结构的调整</p><p>分为五种情况讨论：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">//删除的节点是叶子节点，不涉及到结构变化</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//我们选择右子树不动</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>) cur = cur.left;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key) root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; key) root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-修建二叉搜索树-Pro-108"><a href="#②-修建二叉搜索树-Pro-108" class="headerlink" title="② 修建二叉搜索树 Pro 108"></a>② 修建二叉搜索树 Pro 108</h3><p>采用递归</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/posts/9211474f.html"/>
      <url>/posts/9211474f.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><p><a href="https://blog.csdn.net/da_ge_de_nv_ren/article/details/128391575">Linux命令教程</a></p><h2 id="目录相关的命令"><a href="#目录相关的命令" class="headerlink" title="目录相关的命令"></a>目录相关的命令</h2><h3 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h3><ul><li><code>cd usr</code>：切换到该目录下 usr 目录</li><li><code>cd ..（或cd../）</code>：切换到上一层目录</li><li><code>cd /</code>：切换到系统根目录</li><li><code>cd ~</code>：切换到用户主目录</li><li>**<code>cd -</code>*<em>*<em>：</em></em> 切换到上一个操作所在目录</li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><code>ls</code>：显示目录中的文件和子目录的列表。例如：<code>ls /home</code>，显示 <code>/home</code> 目录下的文件和子目录列表</p><ul><li><code>ll</code>：<code>ll</code> 是 <code>ls -l</code> 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息</li><li><code>mkdir [选项] 目录名</code>：创建新目录（增）。例如：<code>mkdir -m 755 my_directory</code>，创建一个名为 <code>my_directory</code> 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。</li><li><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li><li><code>pwd</code>：显示当前工作目录的路径。</li><li><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</li><li><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</li><li><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。例如：<code>cp file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件复制到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>cp -r source destination</code>，将 <code>source</code> 目录及其下的所有子目录和文件复制到 <code>destination</code> 目录下，并保留源文件的属性和目录结构。</li><li><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。例如：<code>mv file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件移动到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>mv</code> 与 <code>cp</code> 的结果不同，<code>mv</code> 好像文件“搬家”，文件个数并未增加。而 <code>cp</code> 对文件进行复制，文件个数增加了。</li></ul><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul><li><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。例如：<code>touch file1.txt file2.txt file3.txt</code> ，创建 3 个文件。</li><li><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。例如：<code>ln -s file.txt file_link</code>，创建名为 <code>file_link</code> 的软链接，指向 <code>file.txt</code> 文件。<code>-s</code> 选项代表的就是创建软链接，s 即 symbolic（软链接又名符号链接） 。</li><li><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><code>vim 文件名</code>：修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li></ul><hr><h1 id="文件解压缩的命令"><a href="#文件解压缩的命令" class="headerlink" title="文件解压缩的命令"></a>文件解压缩的命令</h1><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以 <code>.tar</code> 结尾的，压缩的命令一般是以 <code>.gz</code> 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 <code>.tar.gz</code>。</p><p>命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code> 。</p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中 x 代表解压</p><p>示例：</p><ul><li>将 <code>/test</code> 下的 <code>test.tar.gz</code> 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></li><li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:<code>tar -xvf test.tar.gz -C /usr</code>（<code>-C</code> 代表指定解压的位置）</li></ul><hr><h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ul><li><code>scp [选项] 源文件 远程文件</code> （scp 即 secure copy，安全复制）：用于通过 SSH 协议进行安全的文件传输，可以实现从本地到远程主机的上传和从远程主机到本地的下载。例如：<code>scp -r my_directory user@remote:/home/user</code> ，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。<code>scp -r user@remote:/home/user/my_directory</code> ，将远程服务器的 <code>/home/user</code> 目录下的<code>my_directory</code>目录下载到本地。需要注意的是，<code>scp</code> 命令需要在本地和远程系统之间建立 SSH 连接进行文件传输，因此需要确保远程服务器已经配置了 SSH 服务，并且具有正确的权限和认证方式。</li><li><code>rsync [选项] 源文件 远程文件</code> : 可以在本地和远程系统之间高效地进行文件复制，并且能够智能地处理增量复制，节省带宽和时间。例如：<code>rsync -r my_directory user@remote:/home/user</code>，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。</li><li><code>ftp</code> (File Transfer Protocol)：提供了一种简单的方式来连接到远程 FTP 服务器并进行文件上传、下载、删除等操作。使用之前需要先连接登录远程 FTP 服务器，进入 FTP 命令行界面后，可以使用 <code>put</code> 命令将本地文件上传到远程主机，可以使用<code>get</code>命令将远程主机的文件下载到本地，可以使用 <code>delete</code> 命令删除远程主机的文件。这里就不进行演示了。</li></ul><hr><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><code>ls -lc</code>查看某个目录下的文件或目录的权限</p><p>第一列的信息如下：</p><p>文件类型：</p><ul><li>d：代表目录</li><li>-：代表文件</li><li>l：代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中的权限：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p><ul><li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用<code>ls ‐ahl</code>命令可以看到文件的所有者 ，也可以使用 <code>chown 用户名 文件名</code>来修改文件的所有者 。</li><li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组，也可以使用 <code>chgrp 组名 文件名</code>来修改文件所在的组。</li><li>其它组(o)：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><p>修改文件或目录的权限：利用<code>chmod</code>命令</p><p><code>chmod +x file.name </code>&#x3D;&#x3D; <code>chmod a+x file.name</code> a代表所有用户</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux 系统是一个<code>多用户多任务的分时操作系统</code>，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>相关命令：</p><ul><li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li><li><code>userdel [选项] 用户名</code>:删除用户帐号。</li><li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li><li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li><li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li></ul><hr><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd [选项] 用户组</code> :增加一个新的用户组。</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组。</li><li><code>groupmod [选项] 用户组</code> : 修改用户组的属性。</li></ul><h1 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h1><ul><li><code>top [选项]</code>：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。</li><li><code>htop [选项]</code>：类似于 <code>top</code>，但提供了更加交互式和友好的界面，可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</li><li><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</li><li><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</li><li><code>free [选项]</code>：用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等。</li><li><code>df [选项] [文件系统]</code>：用于查看系统的磁盘空间使用情况，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</li><li><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</li><li><code>sar [选项] [时间间隔] [重复次数]</code>：用于收集、报告和分析系统的性能统计信息，包括系统的 CPU 使用、内存使用、磁盘 I&#x2F;O、网络活动等详细信息。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</li><li><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</li><li><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</li></ul><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><ul><li><code>ping [选项] 目标主机</code>：测试与目标主机的网络连接。</li><li><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</li><li><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</li><li><code>ss [选项]</code>：比 <code>netstat</code> 更好用，提供了更快速、更详细的网络连接信息。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="#%E5%85%B6%E4%BB%96">其他</a></h1><ul><li><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</li><li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，–color 代表高亮显示。</li><li><code>kill -9 进程的pid</code>：杀死进程（-9 表示强制终止）先用 ps 查找进程，然后用 kill 杀掉。</li><li><code>shutdown</code>：<code>shutdown -h now</code>：指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</li><li><code>reboot</code>：<code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</li></ul><h1 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h1><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的主目录（HOME）。</p><h2 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h2><p>按照作用域来分，环境变量可以简单的分成:</p><ul><li>用户级别环境变量 : <code>~/.bashrc</code>、<code>~/.bash_profile</code>。</li><li>系统级别环境变量 : <code>/etc/bashrc</code>、<code>/etc/environment</code>、<code>/etc/profile</code>、<code>/etc/profile.d</code>。</li></ul><p>上述配置文件执行先后顺序为：<code>/etc/environment</code> –&gt; <code>/etc/profile</code> –&gt; <code>/etc/profile.d</code> –&gt; <code>~/.bash_profile</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>~/.bashrc</code></p><p>如果要修改系统级别环境变量文件，需要管理员具备对该文件的写入权限。</p><p>建议用户级别环境变量在 <code>~/.bash_profile</code>中配置，系统级别环境变量在 <code>/etc/profile.d</code> 中配置。</p><p>按照生命周期来分，环境变量可以简单的分成:</p><ul><li>永久的：需要用户修改相关的配置文件，变量永久生效。</li><li>临时的：用户利用 <code>export</code> 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</li></ul><h2 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h2><p>输出当前系统定义的所有环境变量：<code>export -p</code>  or <code>env</code></p><p>输出指定的环境变量的值：<code>echo $环境变量名  </code></p><h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><p>1⃣️ 只针对当前shell终端生效，关闭终端就会失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>2⃣️ 修改环境永久有效</p><p>利用<code>vim命令</code>修改；如果修改的是系统级别环境变量，对所有用户生效；修改的是用户级别环境，只针对当前用户生效</p><p>修改完之后，利用<code>source</code> 命令让其生效   或者。关闭shell终端重新登录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dockerfile的讲解</title>
      <link href="/posts/11b561ff.html"/>
      <url>/posts/11b561ff.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algrothrim/tree</title>
      <link href="/posts/7b209e6f.html"/>
      <url>/posts/7b209e6f.html</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h2 id="Pro-144-二叉树的前序遍历"><a href="#Pro-144-二叉树的前序遍历" class="headerlink" title="Pro 144 二叉树的前序遍历"></a>Pro 144 二叉树的前序遍历</h2><p>利用栈来解决这个问题</p><h2 id="Pro94-二叉树的中序遍历（难点）"><a href="#Pro94-二叉树的中序遍历（难点）" class="headerlink" title="Pro94 二叉树的中序遍历（难点）"></a>Pro94 二叉树的中序遍历（难点）</h2><p>因为先访问的是中节点，但是我们要先处理的是左节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// stack.push(root);  错误的地方，相当于把cur加入了两次</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-145-二叉树的后序遍历"><a href="#Pro-145-二叉树的后序遍历" class="headerlink" title="Pro 145 二叉树的后序遍历"></a>Pro 145 二叉树的后序遍历</h2><p>前序遍历：中左右   </p><p>后序遍历：左右中</p><p>利用前序遍历的一点变化再通过反转结果得到后序遍历的结果</p><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="Pro-102-二叉树的层序遍历"><a href="#Pro-102-二叉树的层序遍历" class="headerlink" title="Pro 102 二叉树的层序遍历"></a>Pro 102 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep用来记录当前遍历的c</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(TreeNode root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; deep)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(deep - <span class="number">1</span>).add(root.val);</span><br><span class="line">        levelOrder1(root.left,deep);</span><br><span class="line">        levelOrder1(root.right,deep);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装常用的软件</title>
      <link href="/posts/ffabeda8.html"/>
      <url>/posts/ffabeda8.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络--HTTP</title>
      <link href="/posts/9610dfa.html"/>
      <url>/posts/9610dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>超文本传输协议</p><h2 id="状态码有哪些？"><a href="#状态码有哪些？" class="headerlink" title="状态码有哪些？"></a>状态码有哪些？</h2><img src="/posts/9610dfa/image-20240506144111577.png" class title="五大类HTTP状态码"><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h2><p>① Host字段</p><p>将请求发往「同一台」服务器上的不同网站。</p><img src="/posts/9610dfa/image-20240506144439951.png" class title="如图"><p>② Content-length字段</p><p>本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>HTTP协议是基于TCP协议的，这个方法解决了TCP 粘包 的问题</p><p>③ Connection字段</p><p>最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。长连接机制指的是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><img src="/posts/9610dfa/image-20240506144934539.png" class title="如图"><p>④ Content-Type字段</p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><img src="/posts/9610dfa/image-20240506145230659.png" class title="如图"><p>上述图片中：</p><p>客户端请求：Accept: * &#x2F; * 代表可以接收任何格式的数据</p><p>服务器端响应： Content-Type : text&#x2F;html;Charset&#x3D;utf-8 代表服务器端响应的数据格式</p><p>⑤ Content-Encoding 字段</p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><img src="/posts/9610dfa/image-20240506145550150.png" class title="如图"><h1 id="GTE和POST"><a href="#GTE和POST" class="headerlink" title="GTE和POST"></a>GTE和POST</h1><h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h2><p>根据RFC规范，</p><p>GET用于从服务器请求资源，请求的参数是写在URL中可见的，并且有长度限制。</p><p>POST用于对服务器的资源进行修改，内容写在报文body中，这个是不可见的。</p><h2 id="GET和POST方式是安全、幂等的嘛？"><a href="#GET和POST方式是安全、幂等的嘛？" class="headerlink" title="GET和POST方式是安全、幂等的嘛？"></a>GET和POST方式是安全、幂等的嘛？</h2><p>安全：请求方法不会破坏服务器上的资源</p><p>幂等：多次执行相同的请求，响应的结果是一致的</p><ul><li>对于RFC的GET和POST请求方式而言，<ul><li>GET是安全、幂等的，所以可以对GET请求的数据进行缓存到本地磁盘上。同时还可以作为书签</li><li>POST是非安全、不幂等的。</li></ul></li></ul><h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>用于避免发送缓存，对于一些重复性的http请求，直接将【请求-响应】的数据缓存在本地磁盘，下次可以直接读取本地磁盘中的数据。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>只要浏览器判断本地缓存没有过期，直接使用本地磁盘上的缓存。</p><p>通过设置在HTTP响应头部的2个字段来实现的：Cache-Control(相对时间，优先级高)；Expires（绝对时间）</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会 重复上面的步骤</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>服务器端向客户端发送304 的响应，通知客户端可以继续使用本地缓存。</p><p>协商缓存是在强制缓存发现本地缓存已经过期的情况下，开展的。主要流程如下</p><img src="/posts/9610dfa/image-20240506171152086.png" class title="如图"><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="HTTP和HTTPS有哪些区别？"><a href="#HTTP和HTTPS有哪些区别？" class="headerlink" title="HTTP和HTTPS有哪些区别？"></a>HTTP和HTTPS有哪些区别？</h2><ul><li>HTTP是明文传输，HTTPS在TCP和HTTP之间加了一个SSL&#x2F;TLS安全协议，进行加密传输</li><li>HTTP需要通过TCP三次握手建立连接，而HTTPS除了TCP三次握手后，还要进行SSL&#x2F;TLS的四次握手</li><li>HTTPS协议需要向CA申请数字证书，来保证服务器的身份是可信的</li></ul><h2 id="HTTPS解决了HTTP的哪些问题？"><a href="#HTTPS解决了HTTP的哪些问题？" class="headerlink" title="HTTPS解决了HTTP的哪些问题？"></a>HTTPS解决了HTTP的哪些问题？</h2><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容</li></ul><p>​<img src="/posts/9610dfa/image-20240506182200049.png" class title="如图"></p><p>​在通信建立前，采用非对称加密的方式交换会话密钥，后续就不再使用非对称加密</p><p>​在通信过程中全部使用对称加密的会话密钥加密明文数据</p><ul><li><strong>篡改风险</strong>，比如服务器端返回的数据被植入垃圾广告</li></ul><p>​摘要算法（利用哈希运算得到哈希值）+ 数字签名（避免在传输过程中的内容会被替换掉，利用私钥加密、公钥解密）</p><p>​<img src="/posts/9610dfa/image-20240506184356572.png" class title="如图"></p><ul><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>将服务器的公钥注册到数字证书中，数字证书认证机构CA利用自己的私钥将服务器的公钥数字签名并颁发数字证书（服务器的公钥+ CA的数字签名）给客户端。</p><p>客户端拿到数字证书后，利用CA的公钥进行解密确认数字证书的合法性，然后才能获取服务器的公钥。使用它对报文加密后发送。</p><p>服务器利用私钥进行解密。</p><img src="/posts/9610dfa/image-20240507144616740.png" class title="如图"><h2 id="HTTPS是如何建立连接的？"><a href="#HTTPS是如何建立连接的？" class="headerlink" title="HTTPS是如何建立连接的？"></a>HTTPS是如何建立连接的？</h2><p>① 首先进行TCP的三次握手</p><p>② 然后可以基于<strong>RSA或者ECHDE</strong>进行<strong>SSL&#x2F;TLS</strong>的四次握手通信。客户端向服务器端索要并且验证服务器的公钥（验证数字签名的合法性）；客户端和服务器端协商生产【会话密钥】。</p><ul><li><p>第一次握手：</p><ul><li>客户端向服务器发送加密通信请求，也就是<strong>ClientHello</strong>请求，请求内容为TLS协议版本+客户端的随机数+支持的密码套件列表</li></ul></li><li><p>第二次握手：</p><ul><li>服务器端给客户端返回响应，确认的TLS协议版本+ 服务器端的随机数 + 确定的密码套件列表 + 数字证书（通过CA的私钥对服务器的公钥加密后得到数字签名 + 服务器端的公钥）</li></ul></li><li><p>第三次握手：</p><ul><li><p>客户端收到服务器端的回应之后，通过CA的公钥进行解密，确认数字证书的合法性，然后利用数字证书中传递过来的服务器的公钥对一个<strong>随机数pre-master-key</strong>进行加密发送给服务器端。</p></li><li><img src="/posts/9610dfa/image-20240508152033447.png" class title="如图"></li><li><p>服务器端利用 服务器的私钥 对发送过来的pre-master-key进行解密得到pre-master-key</p></li><li><p>客户端、服务器端   分别利用 客户端随机数 + 服务器端随机数 + pre-master-key得到会话密钥</p></li><li><p>紧接着，客户端会通知服务器端使用加密方式进行通信，并且对之前发送的所有信息做个摘要并且进行加密，让服务器做个验证</p></li></ul></li><li><p>第四次握手：</p><ul><li>服务器如果验证双方加解密都没有问题，那么返回相同的响应，代表握手正式完成。</li></ul></li></ul><p>③ 接下来，就是利用http的方式请求和响应消息，只不过这个消息是经过会话密钥加密之后的</p><h2 id="HTTPS一定是安全可靠的吗？"><a href="#HTTPS一定是安全可靠的吗？" class="headerlink" title="HTTPS一定是安全可靠的吗？"></a>HTTPS一定是安全可靠的吗？</h2><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h1 id="HTTP-1-1-、HTTP-2、-HTTP-3演变"><a href="#HTTP-1-1-、HTTP-2、-HTTP-3演变" class="headerlink" title="HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变"></a>HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变</h1><h2 id="HTTPS-1-1-的优化？"><a href="#HTTPS-1-1-的优化？" class="headerlink" title="HTTPS&#x2F;1.1 的优化？"></a>HTTPS&#x2F;1.1 的优化？</h2><ul><li>优点<ul><li>长连接</li><li>管道传输</li></ul></li><li>缺点：<ul><li>服务器端存在队头阻塞的现象</li><li>请求只能从客户端发起，服务器端只能被动接受冰箱并响应</li></ul></li></ul><h2 id="HTTPS-2的优化？"><a href="#HTTPS-2的优化？" class="headerlink" title="HTTPS&#x2F;2的优化？"></a>HTTPS&#x2F;2的优化？</h2><p>基于HTTPS进行优化的</p><ul><li><p>优点</p><ul><li>是安全的</li><li>l利用HPACK算法实现头部压缩，因为对于很多请求而言，他们的头部是一样，我们在客户端和服务器端共同维护一个头部表</li><li>内部使用二进制格式，比如说响应http状态吗200原来是三个字符‘2’0‘0’保存的，现在利用二进制进行保存</li><li>利用stream解决HTTP服务器端的队头阻塞问题，以及实现了服务器端的主动推送功能</li></ul></li><li><p>缺点</p><ul><li>仍然存在这个TCP层的队头阻塞问题</li></ul></li></ul><h2 id="HTTPS-3的优化"><a href="#HTTPS-3的优化" class="headerlink" title="HTTPS&#x2F;3的优化"></a>HTTPS&#x2F;3的优化</h2><ul><li>优点：<ul><li>UDP替换TCP，彻底解决了队头阻塞的问题</li><li>没有TCP 的三次握手，建立连接更快。对于之前的连接：先进行TCP三次握手和四次挥手，以及TLS的四次握手；而现在QUIC协议包含TLS协议，只需要根据<strong>连接id</strong>进行QUIC三次握手即可</li><li>便于连接迁移，基于TCP的是通过一个TCP四元组（源ip,源port,目的ip，目的端口）确定一个TCP连接的，如果一旦网络发生变化，就需要重新建立连接。对于基于UDP，只需要通过连接ID标记通信的两个端点即可。</li></ul></li></ul><h1 id="HTTP1-1如何优化？"><a href="#HTTP1-1如何优化？" class="headerlink" title="HTTP1.1如何优化？"></a>HTTP1.1如何优化？</h1><ul><li>分为三个方面进行优化：<ul><li>缓存方面：利用  强制缓存   和    协商缓存   这2个技术实现避免发送http请求</li><li>减少http请求的次数<ul><li>将原本有客户端的处理的重定向请求，交给中间的代理服务器进行处理，减少重定向带来的请求的次数</li><li>将访问多个小文件的请求合并成一个大的请求，和并请求就是合并资源，以一个大资源的请求替换多个小资源的请求</li><li>请求网页的时候，没必要一口气将所有的资源都获取到，只需要先获取当前用户所看到的页面资源即可。</li></ul></li><li>减少HTTP响应的数据大小<ul><li>无损压缩：解压之后能够完全恢复到压缩前的原样，比如说gzip</li><li>有所压缩：通过牺牲一定的质量来提高压缩比，</li></ul></li></ul></li></ul><h1 id="HTTPS如何进行优化？"><a href="#HTTPS如何进行优化？" class="headerlink" title="HTTPS如何进行优化？"></a>HTTPS如何进行优化？</h1><h1 id="HTTPS的RSA握手解析"><a href="#HTTPS的RSA握手解析" class="headerlink" title="HTTPS的RSA握手解析"></a>HTTPS的RSA握手解析</h1><p>握手过程参考前面的内容</p><p>一般不使用它，因为它不可以前向加密的操作。</p><p>意思就是：客户端再通过验证数字证书的合法性之后，取出数字签名中的公钥，对新生成的随机数pre-master-key进行加密发送给服务器端，如果说服务器端的这个私钥被窃取了，那么回到发送的全部TSL消息全都被解密。</p><h1 id="HTTPS的ECDHE握手解析"><a href="#HTTPS的ECDHE握手解析" class="headerlink" title="HTTPS的ECDHE握手解析"></a>HTTPS的ECDHE握手解析</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器卷</title>
      <link href="/posts/e0d41e40.html"/>
      <url>/posts/e0d41e40.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是容器卷"><a href="#什么是容器卷" class="headerlink" title="什么是容器卷?"></a>什么是容器卷?</h1><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><ul><li><p>一句话：有点类似我们Redis里面的rdb和aof文件</p></li><li><p>·将docker容器内的数据保存进宿主机的磁盘中</p></li><li><p>那么如何运行一个带有容器卷存储功能的容器实例？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</span><br></pre></td></tr></table></figure></li></ul><h1 id="容器卷的作用？"><a href="#容器卷的作用？" class="headerlink" title="容器卷的作用？"></a>容器卷的作用？</h1><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p>为了能保存数据，在docker中我们使用卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据</p><p>2：卷中的更改可以直接实时生效，爽</p><p>3：数据卷中的更改不会包含在镜像的更新中</p><p>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h1 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h1><ul><li><p>默认是<strong>rw</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</span><br></pre></td></tr></table></figure></li><li><p><strong>ro</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</span><br></pre></td></tr></table></figure><p>容器自己只能读取不能写 </p><p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p></li></ul><h1 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h1><ul><li>容器1完成和宿主机的映射</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure><ul><li>容器2继承容器1的卷规则</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu</span><br></pre></td></tr></table></figure><p>注意：这里继承的是规则，代表即使容器1挂了，容器了还是能够和宿主机进行同步的。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像</title>
      <link href="/posts/890cc775.html"/>
      <url>/posts/890cc775.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是镜像？"><a href="#什么是镜像？" class="headerlink" title="什么是镜像？"></a>什么是镜像？</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><h2 id="联合文件系统UnionFS"><a href="#联合文件系统UnionFS" class="headerlink" title="联合文件系统UnionFS"></a>联合文件系统UnionFS</h2><p><strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="Docker镜像的加载原理"><a href="#Docker镜像的加载原理" class="headerlink" title="Docker镜像的加载原理"></a>Docker镜像的加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p><img src="/posts/890cc775/image-20240504225354426.png" class title="docker镜像的分层"><p>&#x3D;&#x3D;平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？？&#x3D;&#x3D;</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="Docker镜像采用分层结构的好处"><a href="#Docker镜像采用分层结构的好处" class="headerlink" title="Docker镜像采用分层结构的好处"></a>Docker镜像采用分层结构的好处</h2><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><p><strong>Docker镜像层都是只读的，容器层是可写的</strong> 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p>通俗来讲：</p><p>​Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>​新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建docker私有仓库</title>
      <link href="/posts/4f71e385.html"/>
      <url>/posts/4f71e385.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><p><a href="https://www.yuque.com/tmfl/cloud/zbegdm">https://www.yuque.com/tmfl/cloud/zbegdm</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/posts/749ad7d8.html"/>
      <url>/posts/749ad7d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、启动类命令"><a href="#1、启动类命令" class="headerlink" title="1、启动类命令"></a>1、启动类命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">//查看状态</span><br><span class="line">systemctl status docker</span><br><span class="line">//设为开机自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看docker版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="2、镜像相关的命令"><a href="#2、镜像相关的命令" class="headerlink" title="2、镜像相关的命令"></a>2、镜像相关的命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//列出本地主机上的镜像</span><br><span class="line">docker images</span><br><span class="line">//在远程仓库中搜索镜像</span><br><span class="line">docker search 镜像名称 (-f 过滤 --limit 只展示前几项)</span><br><span class="line">//下载镜像   不加 tag 时，默认下载最新的镜像（即tag为latest）。</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line">//查看占据的空间 查看镜像/容器/数据卷所占的空间：</span><br><span class="line">docker system df</span><br><span class="line">//删除镜像</span><br><span class="line">docker rmi 镜像名称/ID</span><br><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br><span class="line">docker rmi -f $&#123;docker images -qa&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h1><h2 id="3-1-新建启动容器"><a href="#3-1-新建启动容器" class="headerlink" title="3.1 新建启动容器"></a>3.1 新建启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：指定端口映射，具有几种不同形式</p><ul><li><p><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code> </p></li><li><p><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></p></li><li><p><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></p></li><li><p><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></p></li></ul></li></ul><h3 id="3-1-1-启动、退出-交互式容器"><a href="#3-1-1-启动、退出-交互式容器" class="headerlink" title="3.1.1 启动、退出 交互式容器"></a>3.1.1 启动、退出 交互式容器</h3><p>① 启动交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>② 退出交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit;  //退出后，容器会停止；</span><br><span class="line"></span><br><span class="line">使用快捷键 ctrl + P + Q  //退出后容器仍然在运行</span><br></pre></td></tr></table></figure><h3 id="3-1-2-启动、退出守护式容器"><a href="#3-1-2-启动、退出守护式容器" class="headerlink" title="3.1.2 启动、退出守护式容器"></a>3.1.2 启动、退出守护式容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：</span></span><br><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h2 id="3-2-列出正在运行的容器"><a href="#3-2-列出正在运行的容器" class="headerlink" title="3.2 列出正在运行的容器"></a>3.2 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><h2 id="3-3-容器其他启动、停止操作"><a href="#3-3-容器其他启动、停止操作" class="headerlink" title="3.3 容器其他启动、停止操作"></a>3.3 容器其他启动、停止操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已经停止的容器</span></span><br><span class="line">docker start 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已经停止的容器：</span></span><br><span class="line">docker rm 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器：</span></span><br><span class="line">docker rm -f 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次删除多个容器实例：</span></span><br><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line">或者</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="3-5-查看容器的日志"><a href="#3-5-查看容器的日志" class="headerlink" title="3.5  查看容器的日志"></a>3.5  查看容器的日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-6-查看容器内运行的进程"><a href="#3-6-查看容器内运行的进程" class="headerlink" title="3.6 查看容器内运行的进程"></a>3.6 查看容器内运行的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-7-查看容器内部细节"><a href="#3-7-查看容器内部细节" class="headerlink" title="3.7 查看容器内部细节"></a>3.7 查看容器内部细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-8-进入正在运行的容器"><a href="#3-8-进入正在运行的容器" class="headerlink" title="3.8 进入正在运行的容器"></a>3.8 进入正在运行的容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入正在运行的容器，并以命令行交互：</span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"># 重新进入</span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p><ul><li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p></li><li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p></li></ul><p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="3-9-容器和宿主机文件拷贝"><a href="#3-9-容器和宿主机文件拷贝" class="headerlink" title="3.9 容器和宿主机文件拷贝"></a>3.9 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>宿主机文件拷贝到容器中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure><h2 id="3-10-导入和导出容器"><a href="#3-10-导入和导出容器" class="headerlink" title="3.10 导入和导出容器"></a>3.10 导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p><p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"># docker export 容器ID &gt; tar文件名</span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"></span><br><span class="line"># 导入</span><br><span class="line"># cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure><h2 id="3-11-将容器生成新镜像"><a href="#3-11-将容器生成新镜像" class="headerlink" title="3.11 将容器生成新镜像"></a>3.11 将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure><p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p><p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="3-12-容器数据卷"><a href="#3-12-容器数据卷" class="headerlink" title="3.12 容器数据卷"></a>3.12 容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>●数据卷可以在容器之间共享或重用数据<br>●卷中的更改可以直接实施生效<br>●数据卷中的更改不会包含在镜像的更新中<br>●数据卷的生命周期一直持续到没有容器使用它为止</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p><p>权限：</p><ul><li><p><code>rw</code>：读写 </p></li><li><p><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</p></li></ul><p>容器卷的继承：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动一个容器</span><br><span class="line">docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"># 使用 --volumes-from 继承 u1的容器卷映射配置</span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h1 id="4、所有命令示意图"><a href="#4、所有命令示意图" class="headerlink" title="4、所有命令示意图"></a>4、所有命令示意图</h1><img src="/posts/749ad7d8/image-20240504210851162.png" class title="所有命令示意图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、centos安装docker"><a href="#1、centos安装docker" class="headerlink" title="1、centos安装docker"></a>1、centos安装docker</h1><h2 id="1-1-配置yum资源库"><a href="#1-1-配置yum资源库" class="headerlink" title="1.1 配置yum资源库"></a>1.1 配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>配置docker的资源库地址：阿里云镜像地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><strong>创建缓存（可选）：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="1-2-安装Docker引擎"><a href="#1-2-安装Docker引擎" class="headerlink" title="1.2 安装Docker引擎"></a>1.2 安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>此时，默认安装的docker引擎、客户端都是最新版本。</p><p>如果要安装指定版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="1-3-启动Docker引擎"><a href="#1-3-启动Docker引擎" class="headerlink" title="1.3 启动Docker引擎"></a>1.3 启动Docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。启动Docker引擎：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="1-4-卸载docker"><a href="#1-4-卸载docker" class="headerlink" title="1.4 卸载docker"></a>1.4 卸载docker</h2><ol><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>使用&#x3D;&#x3D;yum&#x3D;&#x3D;删除docker引擎</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="3"><li>删除镜像、容器、卷、自定义配置等文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="1-5-运行Hello-world-进行测试"><a href="#1-5-运行Hello-world-进行测试" class="headerlink" title="1.5 运行Hello world 进行测试"></a>1.5 运行Hello world 进行测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h1 id="2、docker-下载加速"><a href="#2、docker-下载加速" class="headerlink" title="2、docker 下载加速"></a>2、docker 下载加速</h1><p>我这里使用的是阿里云加速</p><p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。</p><p>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务生态技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1-Docker概述"></a>1-Docker概述</h1><h2 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 Docker简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>   –&gt; 将源码 + 配置 + 环境 + 版本打包成为一个镜像文件</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>传统虚拟机（virtual machine）：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与<strong>系统其他部分分隔开的一系列进程</strong>，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><img src="/posts/f255ffad/image-20240504144850924.png" class title="虚拟机和容器的区别"><p>对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>大小</td><td>一般为Mb</td><td>一般为Gb</td></tr><tr><td>速度</td><td>接近原生</td><td>比较慢</td></tr><tr><td>系统支持数量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="1-3-Docker运行快的原因"><a href="#1-3-Docker运行快的原因" class="headerlink" title="1.3 Docker运行快的原因"></a>1.3 Docker运行快的原因</h2><p>Docker<strong>利用的是宿主机的内核</strong>，而不需要加载操作系统OS内核：</p><p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p><p>Docker容器的<strong>本质就是一个进程</strong>。</p><h2 id="1-4-Docker的组成"><a href="#1-4-Docker的组成" class="headerlink" title="1.4 Docker的组成"></a>1.4 Docker的组成</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分：</p><ul><li><p>镜像（image）</p></li><li><p>容器（container）</p></li><li><p>仓库（repository）</p></li></ul><h3 id="1-4-1-镜像"><a href="#1-4-1-镜像" class="headerlink" title="1.4.1 镜像"></a>1.4.1 镜像</h3><p>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><h3 id="1-4-2-容器"><a href="#1-4-2-容器" class="headerlink" title="1.4.2 容器"></a>1.4.2 容器</h3><p>Docker利用<strong>容器</strong>独立运行的一个或一组应用，应用程序或服务运行在容器里面，<strong>容器就类似于一个虚拟化的运行环境</strong>，容器是用镜像创建的<strong>运行实例</strong>。</p><h3 id="1-4-3-仓库"><a href="#1-4-3-仓库" class="headerlink" title="1.4.3 仓库"></a>1.4.3 仓库</h3><p>Docker仓库是<strong>集中存放镜像文件</strong>的场所。</p><p>仓库分为<strong>公开仓库</strong>和<strong>私有仓库</strong>两种。</p><p>最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><img src="/posts/f255ffad/image-20240504145832567.png" class title="docker架构图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务生态技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job_基础学习</title>
      <link href="/posts/2b2e40e1.html"/>
      <url>/posts/2b2e40e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1什么是任务调度"><a href="#1-1什么是任务调度" class="headerlink" title="1.1什么是任务调度"></a>1.1什么是任务调度</h3><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="1-2-为什么需要分布式调度"><a href="#1-2-为什么需要分布式调度" class="headerlink" title="1.2 为什么需要分布式调度"></a>1.2 为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能</p><p>在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>感觉Spring给我们提供的这个注解可以完成任务调度的功能，好像已经完美解决问题了，为什么还需要分布式呢?</p><p>主要有如下这几点原因:</p><ol><li>高可用：单机版的定式任务调度只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用。</li><li>防止重复执行: 在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，这时，定时执行的结果就可能存在混乱和错误了</li><li>单机处理极限：原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。你也许会说，你也可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况。</li></ol><h3 id="1-3-XXL-JOB介绍"><a href="#1-3-XXL-JOB介绍" class="headerlink" title="1.3 XXL-JOB介绍"></a>1.3 XXL-JOB介绍</h3><p>XXL-Job：是大众点评的分布式任务调度平台，是一个**<code>轻量级分布式任务调度平台,</code>** 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p>大众点评目前已接入XXL-JOB，该系统在内部已调度约100万次，表现优异。</p><p>目前已有多家公司接入xxl-job，包括比较知名的大众点评，京东，优信二手车，360金融 (360)，联想集团 (联想)，易信 (网易)等等</p><p>官网地址 <a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><p><strong>系统架构图</strong></p><img src="/posts/image.png" width="75%" height="75%"><p><strong>设计思想</strong></p><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><h3 id="2-1-下载源码"><a href="#2-1-下载源码" class="headerlink" title="2.1 下载源码"></a>2.1 下载源码</h3><p><strong>源码下载地址:</strong></p><p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p><a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><h3 id="2-1-初始化调度数据库"><a href="#2-1-初始化调度数据库" class="headerlink" title="2.1 初始化调度数据库"></a>2.1 初始化调度数据库</h3><p>请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。</p><p>“调度数据库初始化SQL脚本” 位置为:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/xxl-job/doc/db/tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h3 id="2-2-编译源码"><a href="#2-2-编译源码" class="headerlink" title="2.2 编译源码"></a>2.2 编译源码</h3><p>解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558831.png" alt="img"></p><h3 id="2-3-配置部署调度中心"><a href="#2-3-配置部署调度中心" class="headerlink" title="2.3 配置部署调度中心"></a>2.3 配置部署调度中心</h3><h4 id="2-3-1-调度中心配置"><a href="#2-3-1-调度中心配置" class="headerlink" title="2.3.1 调度中心配置"></a>2.3.1 调度中心配置</h4><p>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### web</span><br><span class="line">server.port=8080    ###配置了端口号</span><br><span class="line">server.servlet.context-path=/xxl-job-admin</span><br><span class="line"></span><br><span class="line">### actuator</span><br><span class="line">management.server.servlet.context-path=/actuator</span><br><span class="line">management.health.mail.enabled=false</span><br><span class="line"></span><br><span class="line">### resources</span><br><span class="line">spring.mvc.servlet.load-on-startup=0</span><br><span class="line">spring.mvc.static-path-pattern=/static/**</span><br><span class="line">spring.resources.static-locations=classpath:/static/</span><br><span class="line"></span><br><span class="line">### freemarker</span><br><span class="line">spring.freemarker.templateLoaderPath=classpath:/templates/</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.request-context-attribute=request</span><br><span class="line">spring.freemarker.settings.number_format=0.##########</span><br><span class="line"></span><br><span class="line">### mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml</span><br><span class="line">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span><br><span class="line"></span><br><span class="line">### xxl-job, datasource</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.202.200:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">### datasource-pool</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.auto-commit=true</span><br><span class="line">spring.datasource.hikari.idle-timeout=30000</span><br><span class="line">spring.datasource.hikari.pool-name=HikariCP</span><br><span class="line">spring.datasource.hikari.max-lifetime=900000</span><br><span class="line">spring.datasource.hikari.connection-timeout=10000</span><br><span class="line">spring.datasource.hikari.connection-test-query=SELECT 1</span><br><span class="line">spring.datasource.hikari.validation-timeout=1000</span><br><span class="line"></span><br><span class="line">### xxl-job, email</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.username=xxx@qq.com</span><br><span class="line">spring.mail.from=xxx@qq.com</span><br><span class="line">spring.mail.password=xxx</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory</span><br><span class="line"></span><br><span class="line">### xxl-job, access token</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line"></span><br><span class="line">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span><br><span class="line">xxl.job.i18n=zh_CN</span><br><span class="line"></span><br><span class="line">## xxl-job, triggerpool max size</span><br><span class="line">xxl.job.triggerpool.fast.max=200</span><br><span class="line">xxl.job.triggerpool.slow.max=100</span><br><span class="line"></span><br><span class="line">### xxl-job, log retention days</span><br><span class="line">xxl.job.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-3-2-部署项目"><a href="#2-3-2-部署项目" class="headerlink" title="2.3.2 部署项目"></a>2.3.2 部署项目</h4><p>运行<code>XxlJobAdminApplication</code>程序即可.</p><p>调度中心访问地址: <a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a></p><p>默认登录账号 “admin&#x2F;123456”, 登录后运行界面如下图所示。</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558842.png" alt="img"></p><p>至此“调度中心”项目已经部署成功。</p><h3 id="2-4-配置部署执行器项目"><a href="#2-4-配置部署执行器项目" class="headerlink" title="2.4 配置部署执行器项目"></a>2.4 配置部署执行器项目</h3><h4 id="2-4-1-添加Maven依赖"><a href="#2-4-1-添加Maven依赖" class="headerlink" title="2.4.1 添加Maven依赖"></a>2.4.1 添加Maven依赖</h4><p>创建SpringBoot项目并且添加如下依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-执行器配置"><a href="#2-4-2-执行器配置" class="headerlink" title="2.4.2 执行器配置"></a>2.4.2 执行器配置</h4><p>在配置文件中添加如下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span><br><span class="line">xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin</span><br><span class="line">### 执行器通讯TOKEN [选填]：非空时启用；</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span><br><span class="line">xxl.job.executor.appname=xxl-job-executor-sample</span><br><span class="line">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span><br><span class="line">xxl.job.executor.address=</span><br><span class="line">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span><br><span class="line">xxl.job.executor.ip=127.0.0.1</span><br><span class="line">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span><br><span class="line">xxl.job.executor.port=9999</span><br><span class="line">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span><br><span class="line">xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler</span><br><span class="line">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span><br><span class="line">xxl.job.executor.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-4-3-添加执行器配置"><a href="#2-4-3-添加执行器配置" class="headerlink" title="2.4.3 添加执行器配置"></a>2.4.3 添加执行器配置</h4><p>创建<code>XxlJobConfig</code>配置对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-添加任务处理类"><a href="#2-4-4-添加任务处理类" class="headerlink" title="2.4.4 添加任务处理类"></a>2.4.4 添加任务处理类</h4><p>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-运行HelloWorld程序"><a href="#2-5-运行HelloWorld程序" class="headerlink" title="2.5 运行HelloWorld程序"></a>2.5 运行HelloWorld程序</h3><h4 id="2-5-1-任务配置-触发执行"><a href="#2-5-1-任务配置-触发执行" class="headerlink" title="2.5.1 任务配置&amp;触发执行"></a>2.5.1 任务配置&amp;触发执行</h4><p>登录调度中心,在任务管理中新增任务,配置内容如下:</p><img src="/posts/image-17147915558843.png"><p>新增后界面如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558844.png" alt="img"></p><p>接着启动定时调度任务</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558845.png" alt="img"></p><h4 id="2-5-2-查看日志"><a href="#2-5-2-查看日志" class="headerlink" title="2.5.2 查看日志"></a>2.5.2 查看日志</h4><p>在调度中心的调度日志中就可以看到，任务的执行结果.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558846.png" alt="img"></p><p>管控台也可以看到任务的执行信息.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558857.png" alt="img"></p><h3 id="2-6-GLUE模式-Java"><a href="#2-6-GLUE模式-Java" class="headerlink" title="2.6 GLUE模式(Java)"></a>2.6 GLUE模式(Java)</h3><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定**<code>JobHandler</code>**。</p><p>（ “GLUE模式(Java)” 运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，可使用<a href="https://github.com/Resource">@Resource</a>&#x2F;<a href="https://github.com/Autowire">@Autowire</a>注入执行器里中的其他服务.</p><p><strong>添加Service</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodB的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加任务配置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558858.png" alt="img"></p><p><strong>通过GLUE IDE在线编辑代码</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558859.png" alt="img"></p><hr><p>编写内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.service.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.wolfcode.xxljobdemo.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.IJobHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGlueJobHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        helloService.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动并执行程序</strong></p><h3 id="2-6-执行器集群"><a href="#2-6-执行器集群" class="headerlink" title="2.6 执行器集群"></a>2.6 执行器集群</h3><h4 id="2-6-1-集群环境搭建"><a href="#2-6-1-集群环境搭建" class="headerlink" title="2.6.1 集群环境搭建"></a>2.6.1 集群环境搭建</h4><p>在IDEA中设置SpringBoot项目运行开启多个集群</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588510.png" alt="img"></p><p>启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588511.png" alt="img"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><ul><li><p>8090端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588512.png" alt="img"></p></li><li><p>8091端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588513.png" alt="img"></p></li></ul><h4 id="2-6-2-调度路由算法讲解"><a href="#2-6-2-调度路由算法讲解" class="headerlink" title="2.6.2 调度路由算法讲解"></a>2.6.2 调度路由算法讲解</h4><p>当执行器集群部署时，提供丰富的路由策略，包括:</p><ol><li><code>FIRST（第一个）：固定选择第一个机器</code></li><li><code>LAST（最后一个）：固定选择最后一个机器；</code></li><li><code>ROUND（轮询）：依次的选择在线的机器发起调度</code></li><li><code>RANDOM（随机）：随机选择在线的机器；</code></li><li><code>CONSISTENT_HASH（一致性HASH）：</code> <code>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</code></li><li><code>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</code></li><li><code>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</code></li><li><code>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>SHARDING_BROADCAST(分片广播)：</code> <code>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</code></li></ol><h2 id="3-分片功能讲解"><a href="#3-分片功能讲解" class="headerlink" title="3. 分片功能讲解"></a>3. 分片功能讲解</h2><h3 id="3-1-案例需求讲解"><a href="#3-1-案例需求讲解" class="headerlink" title="3.1 案例需求讲解"></a>3.1 案例需求讲解</h3><p>需求:我们现在实现这样的需求，在指定节假日，需要给平台的所有用户去发送祝福的短信.</p><h4 id="3-1-1-初始化数据"><a href="#3-1-1-初始化数据" class="headerlink" title="3.1.1 初始化数据"></a>3.1.1 初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="3-1-2-集成Druid-MyBatis"><a href="#3-1-2-集成Druid-MyBatis" class="headerlink" title="3.1.2 集成Druid&amp;MyBatis"></a>3.1.2 集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-业务功能实现"><a href="#3-1-3-业务功能实现" class="headerlink" title="3.1.3 业务功能实现"></a>3.1.3 业务功能实现</h4><p><strong>任务处理方法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务配置信息</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588514.png" alt="img"></p><h3 id="3-2-分片概念讲解"><a href="#3-2-分片概念讲解" class="headerlink" title="3.2 分片概念讲解"></a>3.2 分片概念讲解</h3><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务.</p><p>如果采取<code>分片广播</code>的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度.</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h3 id="3-3-案例改造成任务分片"><a href="#3-3-案例改造成任务分片" class="headerlink" title="3.3 案例改造成任务分片"></a>3.3 案例改造成任务分片</h3><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务设置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588515.png" alt="img"></p><h2 id="4-退役军人在线培训app项目搭建XXL-JOB"><a href="#4-退役军人在线培训app项目搭建XXL-JOB" class="headerlink" title="4. 退役军人在线培训app项目搭建XXL-JOB"></a>4. 退役军人在线培训app项目搭建XXL-JOB</h2><h3 id="4-1-配置调度中心"><a href="#4-1-配置调度中心" class="headerlink" title="4.1 配置调度中心"></a>4.1 配置调度中心</h3><p>① 配置xxl-job的数据库</p><p>首先下载XXL-JOB</p><p>GitHub：<a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p>码云：<a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><p>导入里面提供的.sql文件</p><p>② 启动xxl-job工程，可以将其部署到docker上面</p><p>③ 访问xxl-job的网页管理端，<a href="http://192.168.101.65:8088/xxl-job-admin/">http://192.168.101.65:8088/xxl-job-admin/</a></p><h3 id="4-2-配置执行器"><a href="#4-2-配置执行器" class="headerlink" title="4.2 配置执行器"></a>4.2 配置执行器</h3><p>1、下边进入调度中心添加执行器</p><img src="/posts/2b2e40e1/image-20240615102952246.png" class title="如图"><img src="/posts/2b2e40e1/image-20240615103041412.png" class title="如图"><h3 id="4-3-springboot集成xxl-job"><a href="#4-3-springboot集成xxl-job" class="headerlink" title="4.3 springboot集成xxl-job"></a>4.3 springboot集成xxl-job</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span> </span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.101.65:8088/xxl-job-admin</span>    <span class="comment">#调度中心的地址</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">media-process-service</span>    <span class="comment">#执行器的应用名</span></span><br><span class="line">      <span class="attr">address:</span> </span><br><span class="line">      <span class="attr">ip:</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span>    <span class="comment">#自己选择一个执行器启动的端口，多个本地的执行器的端口是不能重复的</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><p>运行xxl-job所在的服务模块并启动，观察日志：</p><img src="/posts/2b2e40e1/image-20240615103041412.png" class title="如图"><p>同时观察调度中心中的 执行器界面 ：在线机器地址处已显示1个执行器。</p><img src="/posts/2b2e40e1/image-20240615104010173.png" class title="如图"><h3 id="4-5-添加任务并且执行任务"><a href="#4-5-添加任务并且执行任务" class="headerlink" title="4.5  添加任务并且执行任务"></a>4.5  添加任务并且执行任务</h3><p>一般都放在<strong>jobhandler包</strong>下面，任务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.media.service.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.context.XxlJobHelper;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XxlJob开发示例（Bean模式）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开发步骤：</span></span><br><span class="line"><span class="comment"> *      1、任务开发：在Spring Bean实例中，开发Job方法；</span></span><br><span class="line"><span class="comment"> *      2、注解配置：为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。</span></span><br><span class="line"><span class="comment"> *      3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志；</span></span><br><span class="line"><span class="comment"> *      4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2019-12-11 21:52:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXxlJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SampleXxlJob.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理视频.......&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理文档.......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default success</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、分片广播任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分片参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();<span class="comment">//执行器的序号，从0开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();<span class="comment">//执行器总数</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;shardIndex=&quot;</span>+shardIndex+<span class="string">&quot;,shardTotal=&quot;</span>+shardTotal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边在<strong>调度中心</strong>添加任务，进入<strong>任务管理</strong>：</p><img src="/posts/2b2e40e1/image-20240615104917851.png" class title="如图"><p>点击<strong>新增</strong>，填写任务信息：</p><img src="/posts/2b2e40e1/image-20240615105006085.png" class title="如图"><p>添加成功，启动任务：</p><img src="/posts/2b2e40e1/image-20240615105542324.png" class title="如图"><h3 id="4-6-分片广播"><a href="#4-6-分片广播" class="headerlink" title="4.6 分片广播"></a>4.6 分片广播</h3><p>掌握了xxl-job的基本使用，下边思考如何进行分布式任务处理呢？如下图，我们会启动多个执行器组成一个集群（实际上就是针对某一个执行器配置，有个执行器实例集群的方式注册到上面），去执行任务。</p><img src="/posts/2b2e40e1/image-20240615105748442.png" class title="如图"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SQL</span><br><span class="line">高级配置：</span><br><span class="line">    - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括；</span><br><span class="line">        FIRST（第一个）：固定选择第一个机器；</span><br><span class="line">        LAST（最后一个）：固定选择最后一个机器；</span><br><span class="line">        ROUND（轮询）：；</span><br><span class="line">        RANDOM（随机）：随机选择在线的机器；</span><br><span class="line">        CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</span><br><span class="line">        LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</span><br><span class="line">        LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</span><br><span class="line">        FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</span><br><span class="line"></span><br><span class="line">    - 子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度，通过子任务可以实现一个任务执行完成去执行另一个任务。</span><br><span class="line">    </span><br><span class="line">    - 调度过期策略：</span><br><span class="line">        - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</span><br><span class="line">        - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</span><br><span class="line">        </span><br><span class="line">    - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</span><br><span class="line">        单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</span><br><span class="line">        丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</span><br><span class="line">        覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</span><br><span class="line">        </span><br><span class="line">    - 任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</span><br><span class="line">    </span><br><span class="line">    - 失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</span><br></pre></td></tr></table></figure><p>分片是指是调度中心以执行器为维度进行分片，将集群中的执行器标上序号：0，1，2，3…，广播是指每次调度会<strong>向集群中的所有执行器</strong>发送任务调度，请求中携带分片参数。</p><img src="/posts/2b2e40e1/image-20240615142331715.png" class title="如图"><p>当一次分片广播到来，各执行器如何根据分片参数去分布式执行任务，保证执行器之间执行的任务不重复呢？</p>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog-introduction</title>
      <link href="/posts/7574726c.html"/>
      <url>/posts/7574726c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、解决HEXO图片无法显示问题"><a href="#1、解决HEXO图片无法显示问题" class="headerlink" title="1、解决HEXO图片无法显示问题"></a>1、解决HEXO图片无法显示问题</h1><p>版本：Hexo 3以上　　</p><p>最近搭建hexo博客时遇到了图片部署后不显示的问题，如图：</p><p>上网找了很多方式都没有完美解决问题，后来查看了官方文档后终于解决了问题（完美解决），现在贴出来如下。建议以后大家遇到了问题也先去看看官方文档：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p><p>解决方案如下：</p><p>　　1. 在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。</p><p>　　2. git bash安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</p><p>　　3. 插入图片时用这种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img jpg文件 文件描述 %&#125;</span><br></pre></td></tr></table></figure><img src="/posts/7574726c/image-20240503162414559.png" class title="图片描述"><p>　　4. 这样就能成功显示了，测试下吧：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
