<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker常用命令</title>
      <link href="/posts/749ad7d8.html"/>
      <url>/posts/749ad7d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、启动类命令"><a href="#1、启动类命令" class="headerlink" title="1、启动类命令"></a>1、启动类命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">//查看状态</span><br><span class="line">systemctl status docker</span><br><span class="line">//设为开机自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看docker版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="2、镜像相关的命令"><a href="#2、镜像相关的命令" class="headerlink" title="2、镜像相关的命令"></a>2、镜像相关的命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//列出本地主机上的镜像</span><br><span class="line">docker images</span><br><span class="line">//在远程仓库中搜索镜像</span><br><span class="line">docker search 镜像名称 (-f 过滤 --limit 只展示前几项)</span><br><span class="line">//下载镜像   不加 tag 时，默认下载最新的镜像（即tag为latest）。</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line">//查看占据的空间 查看镜像/容器/数据卷所占的空间：</span><br><span class="line">docker system df</span><br><span class="line">//删除镜像</span><br><span class="line">docker rmi 镜像名称/ID</span><br><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br><span class="line">docker rmi -f $&#123;docker images -qa&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h1><h2 id="3-1-新建启动容器"><a href="#3-1-新建启动容器" class="headerlink" title="3.1 新建启动容器"></a>3.1 新建启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：指定端口映射，具有几种不同形式</p><ul><li><p><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code> </p></li><li><p><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></p></li><li><p><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></p></li><li><p><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></p></li></ul></li></ul><h3 id="3-1-1-启动、退出-交互式容器"><a href="#3-1-1-启动、退出-交互式容器" class="headerlink" title="3.1.1 启动、退出 交互式容器"></a>3.1.1 启动、退出 交互式容器</h3><p>① 启动交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>② 退出交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit;  //退出后，容器会停止；</span><br><span class="line"></span><br><span class="line">使用快捷键 ctrl + P + Q  //退出后容器仍然在运行</span><br></pre></td></tr></table></figure><h3 id="3-1-2-启动、退出守护式容器"><a href="#3-1-2-启动、退出守护式容器" class="headerlink" title="3.1.2 启动、退出守护式容器"></a>3.1.2 启动、退出守护式容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：</span></span><br><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h2 id="3-2-列出正在运行的容器"><a href="#3-2-列出正在运行的容器" class="headerlink" title="3.2 列出正在运行的容器"></a>3.2 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><h2 id="3-3-容器其他启动、停止操作"><a href="#3-3-容器其他启动、停止操作" class="headerlink" title="3.3 容器其他启动、停止操作"></a>3.3 容器其他启动、停止操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已经停止的容器</span></span><br><span class="line">docker start 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已经停止的容器：</span></span><br><span class="line">docker rm 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器：</span></span><br><span class="line">docker rm -f 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次删除多个容器实例：</span></span><br><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line">或者</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="3-5-查看容器的日志"><a href="#3-5-查看容器的日志" class="headerlink" title="3.5  查看容器的日志"></a>3.5  查看容器的日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-6-查看容器内运行的进程"><a href="#3-6-查看容器内运行的进程" class="headerlink" title="3.6 查看容器内运行的进程"></a>3.6 查看容器内运行的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-7-查看容器内部细节"><a href="#3-7-查看容器内部细节" class="headerlink" title="3.7 查看容器内部细节"></a>3.7 查看容器内部细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-8-进入正在运行的容器"><a href="#3-8-进入正在运行的容器" class="headerlink" title="3.8 进入正在运行的容器"></a>3.8 进入正在运行的容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入正在运行的容器，并以命令行交互：</span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"># 重新进入</span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p><ul><li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p></li><li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p></li></ul><p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="3-9-容器和宿主机文件拷贝"><a href="#3-9-容器和宿主机文件拷贝" class="headerlink" title="3.9 容器和宿主机文件拷贝"></a>3.9 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>宿主机文件拷贝到容器中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure><h2 id="3-10-导入和导出容器"><a href="#3-10-导入和导出容器" class="headerlink" title="3.10 导入和导出容器"></a>3.10 导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p><p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"># docker export 容器ID &gt; tar文件名</span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"></span><br><span class="line"># 导入</span><br><span class="line"># cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure><h2 id="3-11-将容器生成新镜像"><a href="#3-11-将容器生成新镜像" class="headerlink" title="3.11 将容器生成新镜像"></a>3.11 将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure><p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p><p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="3-12-容器数据卷"><a href="#3-12-容器数据卷" class="headerlink" title="3.12 容器数据卷"></a>3.12 容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>●数据卷可以在容器之间共享或重用数据<br>●卷中的更改可以直接实施生效<br>●数据卷中的更改不会包含在镜像的更新中<br>●数据卷的生命周期一直持续到没有容器使用它为止</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p><p>权限：</p><ul><li><p><code>rw</code>：读写 </p></li><li><p><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</p></li></ul><p>容器卷的继承：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动一个容器</span><br><span class="line">docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"># 使用 --volumes-from 继承 u1的容器卷映射配置</span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h1 id="4、所有命令示意图"><a href="#4、所有命令示意图" class="headerlink" title="4、所有命令示意图"></a>4、所有命令示意图</h1><img src="/posts/undefined/image-20240504210851162.png" class title="所有命令示意图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、centos安装docker"><a href="#1、centos安装docker" class="headerlink" title="1、centos安装docker"></a>1、centos安装docker</h1><h2 id="1-1-配置yum资源库"><a href="#1-1-配置yum资源库" class="headerlink" title="1.1 配置yum资源库"></a>1.1 配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>配置docker的资源库地址：阿里云镜像地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><strong>创建缓存（可选）：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="1-2-安装Docker引擎"><a href="#1-2-安装Docker引擎" class="headerlink" title="1.2 安装Docker引擎"></a>1.2 安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>此时，默认安装的docker引擎、客户端都是最新版本。</p><p>如果要安装指定版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="1-3-启动Docker引擎"><a href="#1-3-启动Docker引擎" class="headerlink" title="1.3 启动Docker引擎"></a>1.3 启动Docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。启动Docker引擎：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="1-4-卸载docker"><a href="#1-4-卸载docker" class="headerlink" title="1.4 卸载docker"></a>1.4 卸载docker</h2><ol><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>使用&#x3D;&#x3D;yum&#x3D;&#x3D;删除docker引擎</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="3"><li>删除镜像、容器、卷、自定义配置等文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="1-5-运行Hello-world-进行测试"><a href="#1-5-运行Hello-world-进行测试" class="headerlink" title="1.5 运行Hello world 进行测试"></a>1.5 运行Hello world 进行测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h1 id="2、docker-下载加速"><a href="#2、docker-下载加速" class="headerlink" title="2、docker 下载加速"></a>2、docker 下载加速</h1><p>我这里使用的是阿里云加速</p><p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。</p><p>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1-Docker概述"></a>1-Docker概述</h1><h2 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 Docker简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>   –&gt; 将源码 + 配置 + 环境 + 版本打包成为一个镜像文件</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>传统虚拟机（virtual machine）：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与<strong>系统其他部分分隔开的一系列进程</strong>，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><img src="/posts/f255ffad/image-20240504144850924.png" class title="虚拟机和容器的区别"><p>对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>大小</td><td>一般为Mb</td><td>一般为Gb</td></tr><tr><td>速度</td><td>接近原生</td><td>比较慢</td></tr><tr><td>系统支持数量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="1-3-Docker运行快的原因"><a href="#1-3-Docker运行快的原因" class="headerlink" title="1.3 Docker运行快的原因"></a>1.3 Docker运行快的原因</h2><p>Docker<strong>利用的是宿主机的内核</strong>，而不需要加载操作系统OS内核：</p><p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p><p>Docker容器的<strong>本质就是一个进程</strong>。</p><h2 id="1-4-Docker的组成"><a href="#1-4-Docker的组成" class="headerlink" title="1.4 Docker的组成"></a>1.4 Docker的组成</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分：</p><ul><li><p>镜像（image）</p></li><li><p>容器（container）</p></li><li><p>仓库（repository）</p></li></ul><h3 id="1-4-1-镜像"><a href="#1-4-1-镜像" class="headerlink" title="1.4.1 镜像"></a>1.4.1 镜像</h3><p>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><h3 id="1-4-2-容器"><a href="#1-4-2-容器" class="headerlink" title="1.4.2 容器"></a>1.4.2 容器</h3><p>Docker利用<strong>容器</strong>独立运行的一个或一组应用，应用程序或服务运行在容器里面，<strong>容器就类似于一个虚拟化的运行环境</strong>，容器是用镜像创建的<strong>运行实例</strong>。</p><h3 id="1-4-3-仓库"><a href="#1-4-3-仓库" class="headerlink" title="1.4.3 仓库"></a>1.4.3 仓库</h3><p>Docker仓库是<strong>集中存放镜像文件</strong>的场所。</p><p>仓库分为<strong>公开仓库</strong>和<strong>私有仓库</strong>两种。</p><p>最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><img src="/posts/f255ffad/image-20240504145832567.png" class title="docker架构图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job_基础学习</title>
      <link href="/posts/2b2e40e1.html"/>
      <url>/posts/2b2e40e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1什么是任务调度"><a href="#1-1什么是任务调度" class="headerlink" title="1.1什么是任务调度"></a>1.1什么是任务调度</h3><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="1-2-为什么需要分布式调度"><a href="#1-2-为什么需要分布式调度" class="headerlink" title="1.2 为什么需要分布式调度"></a>1.2 为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能</p><p>在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>感觉Spring给我们提供的这个注解可以完成任务调度的功能，好像已经完美解决问题了，为什么还需要分布式呢?</p><p>主要有如下这几点原因:</p><ol><li>高可用：单机版的定式任务调度只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用。</li><li>防止重复执行: 在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，这时，定时执行的结果就可能存在混乱和错误了</li><li>单机处理极限：原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。你也许会说，你也可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况。</li></ol><h3 id="1-3-XXL-JOB介绍"><a href="#1-3-XXL-JOB介绍" class="headerlink" title="1.3 XXL-JOB介绍"></a>1.3 XXL-JOB介绍</h3><p>XXL-Job：是大众点评的分布式任务调度平台，是一个**<code>轻量级分布式任务调度平台,</code>** 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p>大众点评目前已接入XXL-JOB，该系统在内部已调度约100万次，表现优异。</p><p>目前已有多家公司接入xxl-job，包括比较知名的大众点评，京东，优信二手车，360金融 (360)，联想集团 (联想)，易信 (网易)等等</p><p>官网地址 <a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><p><strong>系统架构图</strong></p><img src="/posts/image.png" width="75%" height="75%"><p><strong>设计思想</strong></p><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><h3 id="2-1-下载源码"><a href="#2-1-下载源码" class="headerlink" title="2.1 下载源码"></a>2.1 下载源码</h3><p><strong>源码下载地址:</strong></p><p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p><a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><h3 id="2-1-初始化调度数据库"><a href="#2-1-初始化调度数据库" class="headerlink" title="2.1 初始化调度数据库"></a>2.1 初始化调度数据库</h3><p>请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。</p><p>“调度数据库初始化SQL脚本” 位置为:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/xxl-job/doc/db/tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h3 id="2-2-编译源码"><a href="#2-2-编译源码" class="headerlink" title="2.2 编译源码"></a>2.2 编译源码</h3><p>解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558831.png" alt="img"></p><h3 id="2-3-配置部署调度中心"><a href="#2-3-配置部署调度中心" class="headerlink" title="2.3 配置部署调度中心"></a>2.3 配置部署调度中心</h3><h4 id="2-3-1-调度中心配置"><a href="#2-3-1-调度中心配置" class="headerlink" title="2.3.1 调度中心配置"></a>2.3.1 调度中心配置</h4><p>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### web</span><br><span class="line">server.port=8080    ###配置了端口号</span><br><span class="line">server.servlet.context-path=/xxl-job-admin</span><br><span class="line"></span><br><span class="line">### actuator</span><br><span class="line">management.server.servlet.context-path=/actuator</span><br><span class="line">management.health.mail.enabled=false</span><br><span class="line"></span><br><span class="line">### resources</span><br><span class="line">spring.mvc.servlet.load-on-startup=0</span><br><span class="line">spring.mvc.static-path-pattern=/static/**</span><br><span class="line">spring.resources.static-locations=classpath:/static/</span><br><span class="line"></span><br><span class="line">### freemarker</span><br><span class="line">spring.freemarker.templateLoaderPath=classpath:/templates/</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.request-context-attribute=request</span><br><span class="line">spring.freemarker.settings.number_format=0.##########</span><br><span class="line"></span><br><span class="line">### mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml</span><br><span class="line">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span><br><span class="line"></span><br><span class="line">### xxl-job, datasource</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.202.200:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">### datasource-pool</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.auto-commit=true</span><br><span class="line">spring.datasource.hikari.idle-timeout=30000</span><br><span class="line">spring.datasource.hikari.pool-name=HikariCP</span><br><span class="line">spring.datasource.hikari.max-lifetime=900000</span><br><span class="line">spring.datasource.hikari.connection-timeout=10000</span><br><span class="line">spring.datasource.hikari.connection-test-query=SELECT 1</span><br><span class="line">spring.datasource.hikari.validation-timeout=1000</span><br><span class="line"></span><br><span class="line">### xxl-job, email</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.username=xxx@qq.com</span><br><span class="line">spring.mail.from=xxx@qq.com</span><br><span class="line">spring.mail.password=xxx</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory</span><br><span class="line"></span><br><span class="line">### xxl-job, access token</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line"></span><br><span class="line">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span><br><span class="line">xxl.job.i18n=zh_CN</span><br><span class="line"></span><br><span class="line">## xxl-job, triggerpool max size</span><br><span class="line">xxl.job.triggerpool.fast.max=200</span><br><span class="line">xxl.job.triggerpool.slow.max=100</span><br><span class="line"></span><br><span class="line">### xxl-job, log retention days</span><br><span class="line">xxl.job.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-3-2-部署项目"><a href="#2-3-2-部署项目" class="headerlink" title="2.3.2 部署项目"></a>2.3.2 部署项目</h4><p>运行<code>XxlJobAdminApplication</code>程序即可.</p><p>调度中心访问地址: <a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a></p><p>默认登录账号 “admin&#x2F;123456”, 登录后运行界面如下图所示。</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558842.png" alt="img"></p><p>至此“调度中心”项目已经部署成功。</p><h3 id="2-4-配置部署执行器项目"><a href="#2-4-配置部署执行器项目" class="headerlink" title="2.4 配置部署执行器项目"></a>2.4 配置部署执行器项目</h3><h4 id="2-4-1-添加Maven依赖"><a href="#2-4-1-添加Maven依赖" class="headerlink" title="2.4.1 添加Maven依赖"></a>2.4.1 添加Maven依赖</h4><p>创建SpringBoot项目并且添加如下依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-执行器配置"><a href="#2-4-2-执行器配置" class="headerlink" title="2.4.2 执行器配置"></a>2.4.2 执行器配置</h4><p>在配置文件中添加如下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span><br><span class="line">xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin</span><br><span class="line">### 执行器通讯TOKEN [选填]：非空时启用；</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span><br><span class="line">xxl.job.executor.appname=xxl-job-executor-sample</span><br><span class="line">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span><br><span class="line">xxl.job.executor.address=</span><br><span class="line">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span><br><span class="line">xxl.job.executor.ip=127.0.0.1</span><br><span class="line">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span><br><span class="line">xxl.job.executor.port=9999</span><br><span class="line">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span><br><span class="line">xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler</span><br><span class="line">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span><br><span class="line">xxl.job.executor.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-4-3-添加执行器配置"><a href="#2-4-3-添加执行器配置" class="headerlink" title="2.4.3 添加执行器配置"></a>2.4.3 添加执行器配置</h4><p>创建<code>XxlJobConfig</code>配置对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-添加任务处理类"><a href="#2-4-4-添加任务处理类" class="headerlink" title="2.4.4 添加任务处理类"></a>2.4.4 添加任务处理类</h4><p>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-运行HelloWorld程序"><a href="#2-5-运行HelloWorld程序" class="headerlink" title="2.5 运行HelloWorld程序"></a>2.5 运行HelloWorld程序</h3><h4 id="2-5-1-任务配置-触发执行"><a href="#2-5-1-任务配置-触发执行" class="headerlink" title="2.5.1 任务配置&amp;触发执行"></a>2.5.1 任务配置&amp;触发执行</h4><p>登录调度中心,在任务管理中新增任务,配置内容如下:</p><img src="/posts/image-17147915558843.png"><p>新增后界面如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558844.png" alt="img"></p><p>接着启动定时调度任务</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558845.png" alt="img"></p><h4 id="2-5-2-查看日志"><a href="#2-5-2-查看日志" class="headerlink" title="2.5.2 查看日志"></a>2.5.2 查看日志</h4><p>在调度中心的调度日志中就可以看到，任务的执行结果.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558846.png" alt="img"></p><p>管控台也可以看到任务的执行信息.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558857.png" alt="img"></p><h3 id="2-6-GLUE模式-Java"><a href="#2-6-GLUE模式-Java" class="headerlink" title="2.6 GLUE模式(Java)"></a>2.6 GLUE模式(Java)</h3><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定**<code>JobHandler</code>**。</p><p>（ “GLUE模式(Java)” 运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，可使用<a href="https://github.com/Resource">@Resource</a>&#x2F;<a href="https://github.com/Autowire">@Autowire</a>注入执行器里中的其他服务.</p><p><strong>添加Service</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodB的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加任务配置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558858.png" alt="img"></p><p><strong>通过GLUE IDE在线编辑代码</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558859.png" alt="img"></p><hr><p>编写内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.service.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.wolfcode.xxljobdemo.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.IJobHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGlueJobHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        helloService.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动并执行程序</strong></p><h3 id="2-6-执行器集群"><a href="#2-6-执行器集群" class="headerlink" title="2.6 执行器集群"></a>2.6 执行器集群</h3><h4 id="2-6-1-集群环境搭建"><a href="#2-6-1-集群环境搭建" class="headerlink" title="2.6.1 集群环境搭建"></a>2.6.1 集群环境搭建</h4><p>在IDEA中设置SpringBoot项目运行开启多个集群</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588510.png" alt="img"></p><p>启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588511.png" alt="img"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><ul><li><p>8090端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588512.png" alt="img"></p></li><li><p>8091端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588513.png" alt="img"></p></li></ul><h4 id="2-6-2-调度路由算法讲解"><a href="#2-6-2-调度路由算法讲解" class="headerlink" title="2.6.2 调度路由算法讲解"></a>2.6.2 调度路由算法讲解</h4><p>当执行器集群部署时，提供丰富的路由策略，包括:</p><ol><li><code>FIRST（第一个）：固定选择第一个机器</code></li><li><code>LAST（最后一个）：固定选择最后一个机器；</code></li><li><code>ROUND（轮询）：依次的选择在线的机器发起调度</code></li><li><code>RANDOM（随机）：随机选择在线的机器；</code></li><li><code>CONSISTENT_HASH（一致性HASH）：</code> <code>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</code></li><li><code>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</code></li><li><code>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</code></li><li><code>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>SHARDING_BROADCAST(分片广播)：</code> <code>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</code></li></ol><h2 id="3-分片功能讲解"><a href="#3-分片功能讲解" class="headerlink" title="3. 分片功能讲解"></a>3. 分片功能讲解</h2><h3 id="3-1-案例需求讲解"><a href="#3-1-案例需求讲解" class="headerlink" title="3.1 案例需求讲解"></a>3.1 案例需求讲解</h3><p>需求:我们现在实现这样的需求，在指定节假日，需要给平台的所有用户去发送祝福的短信.</p><h4 id="3-1-1-初始化数据"><a href="#3-1-1-初始化数据" class="headerlink" title="3.1.1 初始化数据"></a>3.1.1 初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="3-1-2-集成Druid-MyBatis"><a href="#3-1-2-集成Druid-MyBatis" class="headerlink" title="3.1.2 集成Druid&amp;MyBatis"></a>3.1.2 集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-业务功能实现"><a href="#3-1-3-业务功能实现" class="headerlink" title="3.1.3 业务功能实现"></a>3.1.3 业务功能实现</h4><p><strong>任务处理方法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务配置信息</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588514.png" alt="img"></p><h3 id="3-2-分片概念讲解"><a href="#3-2-分片概念讲解" class="headerlink" title="3.2 分片概念讲解"></a>3.2 分片概念讲解</h3><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务.</p><p>如果采取<code>分片广播</code>的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度.</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h3 id="3-3-案例改造成任务分片"><a href="#3-3-案例改造成任务分片" class="headerlink" title="3.3 案例改造成任务分片"></a>3.3 案例改造成任务分片</h3><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务设置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588515.png" alt="img"></p><h2 id="4-项目集成XXL-JOB"><a href="#4-项目集成XXL-JOB" class="headerlink" title="4. 项目集成XXL-JOB"></a>4. 项目集成XXL-JOB</h2>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog-introduction</title>
      <link href="/posts/7574726c.html"/>
      <url>/posts/7574726c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、解决HEXO图片无法显示问题"><a href="#1、解决HEXO图片无法显示问题" class="headerlink" title="1、解决HEXO图片无法显示问题"></a>1、解决HEXO图片无法显示问题</h1><p>版本：Hexo 3以上　　</p><p>最近搭建hexo博客时遇到了图片部署后不显示的问题，如图：</p><p>上网找了很多方式都没有完美解决问题，后来查看了官方文档后终于解决了问题（完美解决），现在贴出来如下。建议以后大家遇到了问题也先去看看官方文档：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p><p>解决方案如下：</p><p>　　1. 在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。</p><p>　　2. git bash安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</p><p>　　3. 插入图片时用这种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img jpg文件 文件描述 %&#125;</span><br></pre></td></tr></table></figure><img src="/posts/7574726c/image-20240503162414559.png" class title="图片描述"><p>　　4. 这样就能成功显示了，测试下吧：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
