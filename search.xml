<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker_portainer管理docker环境</title>
      <link href="/posts/bcb39b5.html"/>
      <url>/posts/bcb39b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Portainer"><a href="#什么是Portainer" class="headerlink" title="什么是Portainer?"></a>什么是Portainer?</h1><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h1 id="Portainer的安装？"><a href="#Portainer的安装？" class="headerlink" title="Portainer的安装？"></a>Portainer的安装？</h1><p>① 在官网下载</p><p>· <a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p>· <a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p><p>② 利用命令配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name portainer     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v portainer_data:/data     portainer/portainer</span><br></pre></td></tr></table></figure><img src="/posts/bcb39b5/image-20240517124453765.png" class title="如图"><p>③ 访问地址</p><p>· 第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> portainer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker_network</title>
      <link href="/posts/d90544d5.html"/>
      <url>/posts/d90544d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker是什么？"><a href="#docker是什么？" class="headerlink" title="docker是什么？"></a>docker是什么？</h1><h2 id="docker未启动的时候的网络情况"><a href="#docker未启动的时候的网络情况" class="headerlink" title="docker未启动的时候的网络情况"></a>docker未启动的时候的网络情况</h2><img src="/posts/d90544d5/image-20240515150711669.png" class title="如图"><ul><li>virbr0</li></ul><p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，<strong>yum remove libvirt-libs.x86_64</strong></p><h2 id="docker启动后的网络情况"><a href="#docker启动后的网络情况" class="headerlink" title="docker启动后的网络情况"></a>docker启动后的网络情况</h2><p>额外产生一个名为docker0的虚拟网桥</p><img src="/posts/d90544d5/image-20240515150950961.png" class title="如图"><h1 id="docker网络的常用命令"><a href="#docker网络的常用命令" class="headerlink" title="docker网络的常用命令"></a>docker网络的常用命令</h1><ul><li>查看docker 网络模式命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br></pre></td></tr></table></figure><ul><li>查看网络命令的相关帮助</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network --help</span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line">Manage networks</span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br></pre></td></tr></table></figure><p>① 创建一个docker网络(如果未显示指定的话，默认为bridge模式的)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network create aa_network</span><br><span class="line">b4547ce02dd53c330c57cd69ea0b3308656d29079d21491005af278005ca4e03</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class="line">b4547ce02dd5   aa_network   bridge    local</span><br><span class="line">809aef73100e   bridge       bridge    local</span><br><span class="line">edd2f9cef171   host         host      local</span><br><span class="line">248254a65046   none         null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 删除一个docker网络</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network rm aa_network</span><br><span class="line">aa_network</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>③ 查看网络源数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network inspect XXX网络名字</span><br></pre></td></tr></table></figure><h1 id="docker网络的作用"><a href="#docker网络的作用" class="headerlink" title="docker网络的作用"></a>docker网络的作用</h1><p>① 容器间的互联和通信以及端口映射</p><p>② 容器IP变动时候可以通过<strong>服务名</strong>直接网络通信而不受到影响</p><h1 id="docker网络模式有哪几种？"><a href="#docker网络模式有哪几种？" class="headerlink" title="docker网络模式有哪几种？"></a>docker网络模式有哪几种？</h1><p>一共有五种，除了下面常用的<strong>bridge、host、null</strong>,还有<strong>容器模式、自定义模式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">809aef73100e   bridge    bridge    local</span><br><span class="line">edd2f9cef171   host      host      local</span><br><span class="line">248254a65046   none      null      local</span><br></pre></td></tr></table></figure><img src="/posts/d90544d5/image-20240515155306298.png" class title="如图"><ul><li><p>在运行容器的时候，docker run -d -p 宿主机端口号:容器端口号 –network 网络模式 –name 容器名 镜像名</p><ul><li><p>bridge模式：使用–network  bridge指定，默认使用docker0</p></li><li><p>host模式：使用**–network host**指定</p></li><li><p>none模式：使用–network none指定</p></li><li><p>container模式：使用–network container:NAME或者容器ID指定</p></li><li><p>自定义模式：使用 –network 自定义网络名</p></li></ul></li></ul><h2 id="容器实例内默认网络IP的生产规则"><a href="#容器实例内默认网络IP的生产规则" class="headerlink" title="容器实例内默认网络IP的生产规则"></a>容器实例内默认网络IP的生产规则</h2><p>① 首先启动两个ubuntu容器实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name u1 ubuntu bash</span><br><span class="line">docker run -it --name u1 ubuntu bash</span><br></pre></td></tr></table></figure><p>② docker inspect 容器ID or 容器名字</p><p>主要关注GateWay 和 IPAddress</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker inspect u1 | tail -n 20</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:05&quot;,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;809aef73100e83c199ebb5c8f5eaaf29760e95bfaef5cd35e9e1f470ed77a083&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;0022bb94ab788053271c0763769124bb5ab52da44d04a7b057764e2eea5bce47&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.5&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;DriverOpts&quot;: null,</span><br><span class="line">                    &quot;DNSNames&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>③ 当我们关闭u2,创建u3，发现ip发生了变化</p><p>​docker容器内部的ip是有可能会发生改变的</p><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><img src="/posts/d90544d5/image-20240516085838064.png" class title="如图"><p>每个宿主机上面都会虚拟出一个Docker容器网桥docker0，docker每启动一个容器，根据docjer网桥的网段分配给容器一个IP地址（docker网桥也就是每个容器的默认网关）。</p><p>docker0容器网桥类似一个交换机，上面有一堆接口veth，对应于各自容器的eth0接口，两两匹配</p><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><img src="/posts/d90544d5/image-20240516102952757.png" class title="如图"><ul><li>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</li><li>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于host模式，如何自己在额外设置port映射，会出现警告。 -p 已经不起作用了，端口号会以主机端口号为主，重复时递增</span><br><span class="line"></span><br><span class="line">docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d  --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><ul><li><p>没有之前的端口映射了，那么如何访问启动的tomcat83呢？</p><ul><li><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p></li></ul></li></ul><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>在容器内部查看：</p><img src="/posts/d90544d5/image-20240516110451685.png" class title="如图"><p>在容器外部查看：</p><img src="/posts/d90544d5/image-20240516110520278.png" class title="如图"><h2 id="container网络模式"><a href="#container网络模式" class="headerlink" title="container网络模式"></a>container网络模式</h2><p>新建的容器和<strong>已经存在的一个容器</strong>共享一个网络ip配置而不是和宿主机共享。</p><p>新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p><p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><img src="/posts/d90544d5/image-20240516110856641.png" class title="如图"><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it                                                    --name alpine1  alpine /bin/sh</span><br><span class="line">docker run -it --network container:alpine1 --name alpine2  alpine /bin/sh</span><br></pre></td></tr></table></figure><img src="/posts/d90544d5/image-20240516111113201.png" class title="如图"><p>此时关闭alpine1容器，再查看alpine2的内部网路情况：</p><img src="/posts/d90544d5/image-20240516111326755.png" class title="如图"><h2 id="自定义网络模式"><a href="#自定义网络模式" class="headerlink" title="自定义网络模式"></a>自定义网络模式</h2><p>之前的问题：当我们采用 默认的bridge模式时，各个容器间可以通过ip地址进行相互通信，但是通过服务名无法进行通信。这样存在的问题：一旦网络发生变动，写死ip就无法通信了</p><p>那么采用自定义网络的方式：</p><p>① 创建自定义网络</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost stu]# docker network create define-network1</span><br><span class="line">afb5e8dc9025d3bf1e7957b2ccc1fd018651d1a9d90b8f0552c24480f613ddc0</span><br><span class="line">[root@localhost stu]# docker network ls</span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">b743c8a41ece   bridge            bridge    local</span><br><span class="line">afb5e8dc9025   define-network1   bridge    local</span><br><span class="line">edd2f9cef171   host              host      local</span><br><span class="line">248254a65046   none              null      local</span><br></pre></td></tr></table></figure><p>② 将容器加入到自定义网络</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>③ 容器之间通过服务名可以相互ping通的</p><p>自定义网络本身就维护好了<strong>主机名和ip的对应关系</strong>（ip和域名都能通）</p><h1 id="docker-平台架构图解"><a href="#docker-平台架构图解" class="headerlink" title="docker 平台架构图解"></a>docker 平台架构图解</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="/posts/d90544d5/image-20240516112440017.png" class title="如图"><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><ul><li>整体说明</li></ul><p>从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p><p>Docker 运行的基本流程为：</p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p><p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p><p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p><p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</p><p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p><p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p><p>7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker_network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务实战</title>
      <link href="/posts/a219ce80.html"/>
      <url>/posts/a219ce80.html</url>
      
        <content type="html"><![CDATA[<p>步骤1：利用maven的package打包生成jar包文件（springboot达成的jar天生内嵌了tomcat）</p><p>步骤2：将jar包上传到docker所在的宿主机上面</p><p>步骤3：利用dockerfile（要打包的jar包最好和我们的dockerfile在同一个路径下面）将宿主机中的jar包进行发布，并且部署到docker容器中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dockerfile的内容</span><br><span class="line">#the basis use of java8</span><br><span class="line">FROM openjdk:17</span><br><span class="line">#author</span><br><span class="line">MAINTAINER shenpei</span><br><span class="line"># VOLUME</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># add jar</span><br><span class="line">ADD jwlz-application-sjjczstp.jar zstp.jar</span><br><span class="line"># run jar</span><br><span class="line">RUN bash -c &#x27;touch /zstp.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zstp.jar&quot;]</span><br><span class="line"># expose port</span><br><span class="line">EXPOSE 8897</span><br></pre></td></tr></table></figure><p>​构建镜像（docker build -t 镜像名称:版本号 **.**） ,将其打包成镜像文件</p><p>步骤四：启动镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8897:8897（端口映射） 022e7ef5a58b（镜像id）</span><br></pre></td></tr></table></figure><p>步骤五：测试微服务</p><img src="/posts/a219ce80/image-20240515144412844.png" class title="如图"><p>​</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程</title>
      <link href="/posts/e5954c2f.html"/>
      <url>/posts/e5954c2f.html</url>
      
        <content type="html"><![CDATA[<p>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的<code>运维自动化语言</code>就是 <code>Shell</code> 和 <code>Python</code> 了。</p><p>Shell在运维工作中的服务监控、业务迅速部署、数据备份及其处理中，shell是不可或缺的。</p><p>shell是一个命令解释器，解释执行用户所输入的命令和程序，一输入命令，就立即回应的交互的对话方式。</p><h1 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h1><p>Shell 编程就是对一堆 Linux 命令的逻辑化处理</p><p><img src="/shell%E7%BC%96%E7%A8%8B/image.png" alt="img"></p><h1 id="shell编程的hello-world"><a href="#shell编程的hello-world" class="headerlink" title="shell编程的hello world"></a>shell编程的hello world</h1><p>1⃣️ <a href="http://创建一个helloworld.sh/">创建一个helloworld.sh</a>,扩展名随便写并不影响脚本执行，见名知意就好。</p><p>2⃣️ 使脚本具有执行权限： <code>chmod +x helloworld.sh</code></p><p>3⃣️ 修改helloworld.sh的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 表示单行注释</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><p>shell 中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以</strong>**<code>#!</code>**<strong>开始来指定使用的 shell 类型。在 linux 中，除了 bash shell 以外，还有很多版本的 shell， 例如 zsh、dash 等等…不过 bash shell 还是我们使用最多的。</strong></p><p>4⃣️ 运行脚本文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure><p>（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 <a href="http://helloworld.sh/">helloworld.shopen in new window</a> 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p><h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><p>1⃣️ 分类</p><ul><li><code>自己在shell实例中定义的变量：</code>仅在当前shell实力中有效，其他shell启动的程序</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#自定义变量hello</span></span><br><span class="line">hello=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld!&quot;</span></span><br><span class="line">**Shell 编程中的变量名的命名的注意事项：**</span><br><span class="line"></span><br><span class="line">- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</span><br><span class="line">- 中间不能有空格，可以使用下划线（_）。</span><br><span class="line">- 不能使用标点符号。</span><br><span class="line">- 不能使用 bash 里的关键字（可用 <span class="built_in">help</span> 命令查看保留关键字）。</span><br></pre></td></tr></table></figure><ul><li><p><code>linux已经定义好的环境变量：</code>比如说PATH、HOME等…使用env查看所有的环境变量、set命令既可以查看所有的环境变量又可以查看自定义变量。</p><p><strong>常用的环境变量：</strong></p><p>PATH 决定了 shell 将到哪些目录中寻找命令或程序<br> HOME 当前用户主目录<br> HISTSIZE 　历史记录数<br> LOGNAME 当前用户的登录名<br> HOSTNAME 　指主机的名称<br> SHELL 当前用户 Shell 类型<br> LANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br> MAIL 　当前用户的邮件存放目录<br> PS1 　基本提示符，对于 root 用户是#，对于普通用户是$</p></li><li><p><code>shell变量</code>：shell变量是由shell程序内部提前设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量。</p></li></ul><h1 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h1><ul><li>字符串是shell中最有用的数据类型，字符串可以是单引号，也可以用双引号。</li><li>单引号字符串</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&#x27;SnailClimb&#x27;</span></span><br><span class="line">hello=<span class="string">&#x27;Hello, I am $name!&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">Hello, I am <span class="variable">$name</span>!</span><br></pre></td></tr></table></figure><ul><li>双引号字符串</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&#x27;SnailClimb&#x27;</span></span><br><span class="line">hello=<span class="string">&quot;Hello, I am <span class="variable">$name</span>!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure><ul><li><p>字符串常见操作</p><p>1⃣️ 拼接字符串</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;SnailClimb&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;name&#125; !&#x27;</span>   输出原样</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br><span class="line">2⃣️ 获取字符串长度</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#获取字符串长度</span></span><br><span class="line">name=<span class="string">&quot;SnailClimb&quot;</span></span><br><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span> <span class="comment">#输出 10</span></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line"><span class="built_in">expr</span> length <span class="string">&quot;<span class="variable">$name</span>&quot;</span>;  <span class="comment">#输出10</span></span><br><span class="line">其中，关于这个`<span class="built_in">expr</span>`命令，表达式中的运算符必须包含空格，如果不包含空格，将会输出表达式本身。同时，对于某些运算符，我们需要利用 `符号\ ` 进行转义，否则提示语法错误</span><br><span class="line"><span class="built_in">expr</span> 5 \* 6 <span class="comment">#输出30</span></span><br><span class="line"><span class="built_in">expr</span> 5*6 <span class="comment">#输出5*6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">expr</span> 5 + 6 <span class="comment"># 输出11</span></span><br><span class="line"><span class="built_in">expr</span> 5+6 <span class="comment"># 输出5+6</span></span><br><span class="line">3⃣️ 截取子字符串</span><br><span class="line"></span><br><span class="line">根据下标进行截取</span><br><span class="line"></span><br><span class="line">string：表示源字符串</span><br><span class="line"></span><br><span class="line">start：截取字符串的起始位置，注意第一个字符下标为0</span><br><span class="line"></span><br><span class="line">length：截取字符串的长度</span><br><span class="line"><span class="comment">#从字符串第 1 个字符开始往后截取 10 个字符</span></span><br><span class="line">str=<span class="string">&quot;SnailClimb is a great man&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0:10&#125;</span> <span class="comment">#输出:SnailClimb</span></span><br><span class="line">根据表达式进行截取</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h1><p>1⃣️ 显示普通字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>2⃣️ 显示转义字符</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\&quot;It is a test\&quot;&quot;</span>   <span class="comment"># 结果将是:&quot;It is a test&quot;  同样，双引号也可以省略</span></span><br></pre></td></tr></table></figure><p>3⃣️ 显示变量</p><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span> It is a test&quot;</span></span><br><span class="line"><span class="comment"># 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span></span><br><span class="line">[root@www ~]<span class="comment"># sh test.sh</span></span><br><span class="line">OK                     <span class="comment">#标准输入</span></span><br><span class="line">OK It is a <span class="built_in">test</span>        <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>4⃣ 显示换行 、不换行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \n&quot;</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \c&quot;</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"><span class="comment"># 输出结果：OK! It is a test</span></span><br></pre></td></tr></table></figure><p>5⃣ 将显示结果重定向到文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内容&quot;</span> &gt; 文件名</span><br></pre></td></tr></table></figure><p>6⃣️ 原样输出字符串，不进行转义或者取变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$name\&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 输出结果： $name\&quot;</span></span><br></pre></td></tr></table></figure><p>7⃣️ 显示命令执行结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">cat</span> test.sh`</span><br></pre></td></tr></table></figure><h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p>read 命令<code>一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔</code>；如果<code>输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。</code></p><p>测试文件 <a href="http://test.sh/">test.sh</a> 代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> firstStr secondStr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数:<span class="variable">$firstStr</span>; 第二个参数:<span class="variable">$secondStr</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行测试：</span></span><br><span class="line">$ sh test.sh </span><br><span class="line">一 二 三 四</span><br><span class="line">第一个参数:一; 第二个参数:二 三 四</span><br></pre></td></tr></table></figure><p>read常用参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一段文字:&quot;</span> -n 6 -t 5 -s password</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\npassword is <span class="variable">$password</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>-p 输入提示文字</li><li>-n 输入字符长度限制(达到6位，自动结束)</li><li>-t 输入限时</li><li>-s 隐藏输入内容</li></ul><h1 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h1><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p><p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，可以手动添加 \n。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">🔦 printf 命令的语法： printf format-string [arguments...]</span><br></pre></td></tr></table></figure><p>%s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。</p><p>%-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中 .2 指保留2位小数</p><h1 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><p><strong>数值</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p><strong>字符串</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于则为真</td></tr><tr><td>!&#x3D;</td><td>不相等则为真</td></tr><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><p><strong>文件</strong></p><p>参数  说明 -e 文件名  如果文件存在则为真 -r 文件名  如果文件存在且可读则为真 -w 文件名  如果文件存在且可写则为真 -x 文件名  如果文件存在且可执行则为真 -s 文件名  如果文件存在且至少有一个字符则为真 -d 文件名  如果文件存在且为目录则为真 -f 文件名  如果文件存在且为普通文件则为真 -c 文件名  如果文件存在且为字符型特殊文件则为真 -b 文件名  如果文件存在且为块特殊文件则为真</p><h1 id="IF判断"><a href="#IF判断" class="headerlink" title="IF判断"></a>IF判断</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>📍 if else 的 […] 判断语句中大于使用 -gt，小于使用 -lt。</p><p>📍 如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $(ps -ef | grep -c <span class="string">&quot;ssh&quot;</span>) -gt 1 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;true&quot;</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if-else语法格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if-elseif-else语法格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> condition</span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line">   commond1</span><br><span class="line">   commond2</span><br><span class="line"> elseif condition</span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">   commond3</span><br><span class="line"> elseif condition</span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">   commond4</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  commond5</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &gt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &lt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="while语法"><a href="#while语法" class="headerlink" title="while语法"></a>while语法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=<span class="number">5</span> ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;int++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h1><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p><strong>until 语法格式</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> condition  <span class="comment">#condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>📃 参考实例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为：</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>case 取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;; 。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;输入 1 到 4 之间的数字:&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;你输入的数字为:&#x27;</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 1&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 2&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 3&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">&#x27;你选择了 4&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">&#x27;你没有输入 1 到 4 之间的数字&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h1 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h1><p>break 命令允许跳出所有循环（终止执行后面的所有循环）。</p><p>continue 命令与 break 命令类似，它不会跳出所有循环，仅仅跳出当前循环。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字:&quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;结束&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>basename 基本语法： <strong>basename [string &#x2F; pathname] [suffix]</strong></p><p>basename 命令会删掉所有的前缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。</p><p>basename 可以理解为取路径里的文件名称.</p><p>suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 截取该/home/user1/banzhang.txt 路径的文件名称</span></span><br><span class="line">[root@Demo shells]$ <span class="built_in">basename</span> /home/user1/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[root@Demo shells]$ <span class="built_in">basename</span> /home/user1/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname 文件绝对路径</span><br></pre></td></tr></table></figure><p>从给定的包含绝对路径的文件名中去除文件名，然后返回剩下的路径。</p><p><code>dirname</code> 可以理解为<strong>取文件路径的绝对路径名称。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 banzhang.txt 文件的路径</span></span><br><span class="line">[atguigu@hadoop101 ~]$ <span class="built_in">dirname</span> /home/user1/banzhang.txt</span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>带function</strong> fun() 定义，也可以<strong>直接fun() 定义</strong>,不带任何参数。</p><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这个函数会对输入的两个数字进行相加运算...&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第一个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第二个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入的两个数字之和为 $? !&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类似下面：</span></span><br><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br><span class="line"></span><br><span class="line"><span class="comment"># $10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当n&gt;=10时，需要使用$&#123;n&#125;来获取参数。</span></span><br></pre></td></tr></table></figure><p><img src="/shell%E7%BC%96%E7%A8%8B/image-17155867092981.png" alt="img"></p><h1 id="输入、输出重定向"><a href="#输入、输出重定向" class="headerlink" title="输入、输出重定向"></a>输入、输出重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p><strong>语法：</strong><code>command1 &gt; file1</code></p><p>上面这个命令执行command1然后将输出的内容存入file1。</p><p>任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;AAAAA&quot;</span> &gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">AAAAA</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;AAAAA&quot;</span> &gt;&gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">AAAAA</span><br><span class="line">AAAAA</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p><strong>语法：</strong> <code>command1 &lt; file1</code></p><p>📃 参考实例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</span></span><br><span class="line">$ <span class="built_in">wc</span> -l <span class="built_in">users</span></span><br><span class="line">       2 <span class="built_in">users</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">#也可以将输入重定向到 users 文件：</span></span><br><span class="line"></span><br><span class="line">$  <span class="built_in">wc</span> -l &lt; <span class="built_in">users</span></span><br><span class="line">       2        </span><br><span class="line"><span class="comment"># 上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</span></span><br><span class="line">command1 &lt; infile &gt; outfile </span><br></pre></td></tr></table></figure><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><p>👉 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</p><p>👉 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</p><p>👉 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;file</span><br></pre></td></tr></table></figure><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;&gt;file</span><br></pre></td></tr></table></figure><p>表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><p>$ command &gt; file 2&gt;&amp;1</p><p>$ command &gt;&gt; file 2&gt;&amp;1</p><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><p>$ command &lt; file1 &gt;file2</p><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><h1 id="简单正则式"><a href="#简单正则式" class="headerlink" title="简单正则式"></a>简单正则式</h1><p>正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在 Linux 中，grep，sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。</p><p><strong>^匹配一行的开头字母</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep ^a </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会匹配出所有以 a 开头的行</span></span><br></pre></td></tr></table></figure><p><strong>$匹配一行的结束</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep t$</span><br><span class="line"># 会匹配出所有以 t 结尾的行</span><br></pre></td></tr></table></figure><p><strong>.匹配一个任意的字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep r..t</span><br><span class="line"># 会匹配包含 rabt,rbbt,rxdt,root 等的所有行</span><br></pre></td></tr></table></figure><p>*<strong>不单独使用，他和上一个字符连用，表示匹配上一个字符0次或多次</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep ro*t</span><br><span class="line"># 会匹配 rt, rot, root, rooot, roooot 等所有行</span><br></pre></td></tr></table></figure><p><strong>字符区间（中括号）：[ ]</strong></p><ul><li><code>[ ] 表示匹配某个范围内的一个字符</code></li><li>[6,8] —— 匹配 6 或者 8</li><li>[0-9] —— 匹配一个 0-9 的数字</li><li>[0-9]* —— 匹配任意长度的数字字符串</li><li>[a-z] ——匹配一个 a-z 之间的字符</li><li>[a-z]* —— 匹配任意长度的字母字符串</li><li>[a-c, e-f] —– 匹配 a-c 或者 e-f 之间的任意字符</li></ul><p><strong>\代表转义</strong></p><p>由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Demo shells]$ cat /etc/passwd | grep ‘a\$b’ </span><br><span class="line"># 就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来</span><br></pre></td></tr></table></figure><h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a><strong>cut命令</strong></h2><p>cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。</p><p>cut 命令：从文件的每一行剪切<strong>字节、字符和字段</strong>并将这些字节、字符和字段<strong>输出</strong>。</p><p>🌊 <strong>语法：</strong> <code>cut [参数] [file]</code></p><p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p><ul><li>-b   以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<ul><li>-n 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li></ul></li><li>-c 以字符为单位进行分割。</li><li>-d 自定义分隔符 ，默认为制表符<ul><li>-f 与-d一起使用，指定显示哪个区域</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当执行<span class="built_in">who</span>命令时，会输出类似如下的内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span></span></span><br><span class="line">rocrocket :0           2009-01-08 11:07</span><br><span class="line">rocrocket pts/0        2009-01-08 11:23 (:0.0)</span><br><span class="line">rocrocket pts/1        2009-01-08 14:15 (:0.0)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我们想提取每一行的第3个字节，如下：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>|<span class="built_in">cut</span> -b 3</span></span><br><span class="line">c</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><strong>文件包含（被包含的文件不需要具有可执行权限）</strong></p><p>Shell 脚本文件内部也可以<strong>包含外部脚本</strong>。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. filename # 注意 . 和 文件名之间有一个空格</span><br><span class="line">source filename c</span><br></pre></td></tr></table></figure><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a><strong>sed命令</strong></h2><p>作用：利用脚本文件或者脚本指令 来处理输入的<strong>文本文件</strong></p><p>🌊 <strong>语法：</strong> <code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e &lt;script脚本命令&gt;</td><td>以选项中指定的script来处理输入的文本文件,如果省略的话，默认采用’ ‘</td></tr><tr><td>-f&lt;script文件&gt;</td><td>以选项中指定的script文件来处理输入的文本文件</td></tr><tr><td>-h</td><td>显示帮助</td></tr><tr><td>-n</td><td>仅显示script处理后的结果</td></tr><tr><td>-V</td><td>显示版本信息</td></tr></tbody></table><p>动作说明<br>a           新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>c           取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d    删除，因为是删除，所以 d 后面通常不接任何东西；<br>i插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)<br>p打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行<br>s取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式</p><p>① 行为单位进行新增 &#x2F; 删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -e 4a\newLine 输入的文件名</span><br><span class="line">nl testfile | sed &#x27;2a drink tea&#x27; # 在第2行加入一行内容为 drink tea</span><br><span class="line">nl testfile | sed &#x27;2a drink tea or ...\drink bean&#x27; #在第2行加入2行</span><br><span class="line"># 在文件的第4行新增一行内容--newline</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sed 的动作为 2,5d， d 是删除的意思，因为删除了 2-5 行，所以显示的数据就没有 2-5 行，原本应该是要下达 sed -e 才对，但没有 -e 也是可以的，同时也要注意的是， sed 后面接的动作，请以 ‘…’ 两个单引号括住</span><br><span class="line">nl testfile | sed &#x27;2,5d&#x27;  # 将testfile的内容列出并且列出行号，同时将2，5行的内容删除</span><br><span class="line">nl testfile | sed &#x27;2d&#x27;</span><br><span class="line">nl testfile | sed &#x27;2,$d&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 以行为单位进行替换和显示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed &#x27;2,5c 替换的内容&#x27;</span><br><span class="line">nl testfile | sed -n &#x27;5,7p&#x27;</span><br></pre></td></tr></table></figure><p>③ 数据的搜索并  显示 || 删除 || 执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed -n &#x27;/oo/p&#x27;  #搜索testfile有oo关键字的行</span><br><span class="line">nl testfile | sed -n &#x27;/oo/d&#x27; #搜索testfile所有包含oo的行并且删除，其他行进行显示</span><br><span class="line">nl testfile | sed -n &#x27;/oo&#123;s/oo/kk/;p;q&#125;&#x27;  # 所有所有包含oo的内容。利用kk替换oo，在执行p;在执行q退出命令</span><br></pre></td></tr></table></figure><p>④ 数据的查找和替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sed 的查找与替换的与 vi 命令类似，语法格式如下</span><br><span class="line">sed &#x27;s/要被取代的字串/新的字串/g&#x27;  </span><br><span class="line"></span><br><span class="line"># 将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换</span><br><span class="line">sed -e &#x27;s/oo/kk/&#x27; testfile</span><br><span class="line"></span><br><span class="line"># 将 testfile 文件中所有符合条件出现的 oo 用字符串 kk 替换</span><br><span class="line">sed -e &#x27;s/oo/kk/g&#x27; testfile </span><br><span class="line"></span><br><span class="line"># 选项i使sed 修改文件</span><br><span class="line">sed -i &#x27;s/oo/kk/g&#x27; testfile</span><br><span class="line">sed -i &#x27;s/oo/kk/g&#x27; ./test*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⑤ 多点编辑 （-e）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl testfile | sed -e &#x27;3,$d&#x27; -e &#x27;s/HEELO/RUNOOB/&#x27; # 先删除第三行到末尾的数据，再进行指定内容的替换</span><br></pre></td></tr></table></figure><p>⑥ 直接修改文件内容 (-i)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\.$/\!/g&#x27; testfile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/posts/b73e5edc.html"/>
      <url>/posts/b73e5edc.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/posts/9211474f.html"/>
      <url>/posts/9211474f.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><p><a href="https://blog.csdn.net/da_ge_de_nv_ren/article/details/128391575">Linux命令教程</a></p><h2 id="目录相关的命令"><a href="#目录相关的命令" class="headerlink" title="目录相关的命令"></a>目录相关的命令</h2><h3 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h3><ul><li><code>cd usr</code>：切换到该目录下 usr 目录</li><li><code>cd ..（或cd../）</code>：切换到上一层目录</li><li><code>cd /</code>：切换到系统根目录</li><li><code>cd ~</code>：切换到用户主目录</li><li>**<code>cd -</code>*<em>*<em>：</em></em> 切换到上一个操作所在目录</li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><code>ls</code>：显示目录中的文件和子目录的列表。例如：<code>ls /home</code>，显示 <code>/home</code> 目录下的文件和子目录列表</p><ul><li><code>ll</code>：<code>ll</code> 是 <code>ls -l</code> 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息</li><li><code>mkdir [选项] 目录名</code>：创建新目录（增）。例如：<code>mkdir -m 755 my_directory</code>，创建一个名为 <code>my_directory</code> 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。</li><li><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li><li><code>pwd</code>：显示当前工作目录的路径。</li><li><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</li><li><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</li><li><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。例如：<code>cp file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件复制到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>cp -r source destination</code>，将 <code>source</code> 目录及其下的所有子目录和文件复制到 <code>destination</code> 目录下，并保留源文件的属性和目录结构。</li><li><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。例如：<code>mv file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件移动到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>mv</code> 与 <code>cp</code> 的结果不同，<code>mv</code> 好像文件“搬家”，文件个数并未增加。而 <code>cp</code> 对文件进行复制，文件个数增加了。</li></ul><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul><li><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。例如：<code>touch file1.txt file2.txt file3.txt</code> ，创建 3 个文件。</li><li><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。例如：<code>ln -s file.txt file_link</code>，创建名为 <code>file_link</code> 的软链接，指向 <code>file.txt</code> 文件。<code>-s</code> 选项代表的就是创建软链接，s 即 symbolic（软链接又名符号链接） 。</li><li><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><code>vim 文件名</code>：修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li></ul><hr><h1 id="文件解压缩的命令"><a href="#文件解压缩的命令" class="headerlink" title="文件解压缩的命令"></a>文件解压缩的命令</h1><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以 <code>.tar</code> 结尾的，压缩的命令一般是以 <code>.gz</code> 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 <code>.tar.gz</code>。</p><p>命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code> 。</p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中 x 代表解压</p><p>示例：</p><ul><li>将 <code>/test</code> 下的 <code>test.tar.gz</code> 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></li><li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:<code>tar -xvf test.tar.gz -C /usr</code>（<code>-C</code> 代表指定解压的位置）</li></ul><hr><h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ul><li><code>scp [选项] 源文件 远程文件</code> （scp 即 secure copy，安全复制）：用于通过 SSH 协议进行安全的文件传输，可以实现从本地到远程主机的上传和从远程主机到本地的下载。例如：<code>scp -r my_directory user@remote:/home/user</code> ，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。<code>scp -r user@remote:/home/user/my_directory</code> ，将远程服务器的 <code>/home/user</code> 目录下的<code>my_directory</code>目录下载到本地。需要注意的是，<code>scp</code> 命令需要在本地和远程系统之间建立 SSH 连接进行文件传输，因此需要确保远程服务器已经配置了 SSH 服务，并且具有正确的权限和认证方式。</li><li><code>rsync [选项] 源文件 远程文件</code> : 可以在本地和远程系统之间高效地进行文件复制，并且能够智能地处理增量复制，节省带宽和时间。例如：<code>rsync -r my_directory user@remote:/home/user</code>，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。</li><li><code>ftp</code> (File Transfer Protocol)：提供了一种简单的方式来连接到远程 FTP 服务器并进行文件上传、下载、删除等操作。使用之前需要先连接登录远程 FTP 服务器，进入 FTP 命令行界面后，可以使用 <code>put</code> 命令将本地文件上传到远程主机，可以使用<code>get</code>命令将远程主机的文件下载到本地，可以使用 <code>delete</code> 命令删除远程主机的文件。这里就不进行演示了。</li></ul><hr><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><code>ls -lc</code>查看某个目录下的文件或目录的权限</p><p>第一列的信息如下：</p><p>文件类型：</p><ul><li>d：代表目录</li><li>-：代表文件</li><li>l：代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中的权限：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p><ul><li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用<code>ls ‐ahl</code>命令可以看到文件的所有者 ，也可以使用 <code>chown 用户名 文件名</code>来修改文件的所有者 。</li><li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组，也可以使用 <code>chgrp 组名 文件名</code>来修改文件所在的组。</li><li>其它组(o)：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><p>修改文件或目录的权限：利用<code>chmod</code>命令</p><p><code>chmod +x file.name </code>&#x3D;&#x3D; <code>chmod a+x file.name</code> a代表所有用户</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux 系统是一个<code>多用户多任务的分时操作系统</code>，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>相关命令：</p><ul><li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li><li><code>userdel [选项] 用户名</code>:删除用户帐号。</li><li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li><li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li><li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li></ul><hr><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd [选项] 用户组</code> :增加一个新的用户组。</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组。</li><li><code>groupmod [选项] 用户组</code> : 修改用户组的属性。</li></ul><h1 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h1><ul><li><code>top [选项]</code>：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。</li><li><code>htop [选项]</code>：类似于 <code>top</code>，但提供了更加交互式和友好的界面，可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</li><li><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</li><li><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</li><li><code>free [选项]</code>：用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等。</li><li><code>df [选项] [文件系统]</code>：用于查看系统的磁盘空间使用情况，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</li><li><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</li><li><code>sar [选项] [时间间隔] [重复次数]</code>：用于收集、报告和分析系统的性能统计信息，包括系统的 CPU 使用、内存使用、磁盘 I&#x2F;O、网络活动等详细信息。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</li><li><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</li><li><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</li></ul><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><ul><li><code>ping [选项] 目标主机</code>：测试与目标主机的网络连接。</li><li><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</li><li><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</li><li><code>ss [选项]</code>：比 <code>netstat</code> 更好用，提供了更快速、更详细的网络连接信息。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="#%E5%85%B6%E4%BB%96">其他</a></h1><ul><li><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</li><li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，–color 代表高亮显示。</li><li><code>kill -9 进程的pid</code>：杀死进程（-9 表示强制终止）先用 ps 查找进程，然后用 kill 杀掉。</li><li><code>shutdown</code>：<code>shutdown -h now</code>：指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</li><li><code>reboot</code>：<code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</li></ul><h1 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h1><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的主目录（HOME）。</p><h2 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h2><p>按照作用域来分，环境变量可以简单的分成:</p><ul><li>用户级别环境变量 : <code>~/.bashrc</code>、<code>~/.bash_profile</code>。</li><li>系统级别环境变量 : <code>/etc/bashrc</code>、<code>/etc/environment</code>、<code>/etc/profile</code>、<code>/etc/profile.d</code>。</li></ul><p>上述配置文件执行先后顺序为：<code>/etc/environment</code> –&gt; <code>/etc/profile</code> –&gt; <code>/etc/profile.d</code> –&gt; <code>~/.bash_profile</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>~/.bashrc</code></p><p>如果要修改系统级别环境变量文件，需要管理员具备对该文件的写入权限。</p><p>建议用户级别环境变量在 <code>~/.bash_profile</code>中配置，系统级别环境变量在 <code>/etc/profile.d</code> 中配置。</p><p>按照生命周期来分，环境变量可以简单的分成:</p><ul><li>永久的：需要用户修改相关的配置文件，变量永久生效。</li><li>临时的：用户利用 <code>export</code> 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</li></ul><h2 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h2><p>输出当前系统定义的所有环境变量：<code>export -p</code>  or <code>env</code></p><p>输出指定的环境变量的值：<code>echo $环境变量名  </code></p><h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><p>1⃣️ 只针对当前shell终端生效，关闭终端就会失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>2⃣️ 修改环境永久有效</p><p>利用<code>vim命令</code>修改；如果修改的是系统级别环境变量，对所有用户生效；修改的是用户级别环境，只针对当前用户生效</p><p>修改完之后，利用<code>source</code> 命令让其生效   或者。关闭shell终端重新登录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dockerfile的讲解</title>
      <link href="/posts/11b561ff.html"/>
      <url>/posts/11b561ff.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algrothrim/tree</title>
      <link href="/posts/7b209e6f.html"/>
      <url>/posts/7b209e6f.html</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h2 id="Pro-144-二叉树的前序遍历"><a href="#Pro-144-二叉树的前序遍历" class="headerlink" title="Pro 144 二叉树的前序遍历"></a>Pro 144 二叉树的前序遍历</h2><p>利用栈来解决这个问题</p><h2 id="Pro94-二叉树的中序遍历（难点）"><a href="#Pro94-二叉树的中序遍历（难点）" class="headerlink" title="Pro94 二叉树的中序遍历（难点）"></a>Pro94 二叉树的中序遍历（难点）</h2><p>因为先访问的是中节点，但是我们要先处理的是左节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// stack.push(root);  错误的地方，相当于把cur加入了两次</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pro-145-二叉树的后序遍历"><a href="#Pro-145-二叉树的后序遍历" class="headerlink" title="Pro 145 二叉树的后序遍历"></a>Pro 145 二叉树的后序遍历</h2><p>前序遍历：中左右   </p><p>后序遍历：左右中</p><p>利用前序遍历的一点变化再通过反转结果得到后序遍历的结果</p><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="Pro-102-二叉树的层序遍历"><a href="#Pro-102-二叉树的层序遍历" class="headerlink" title="Pro 102 二叉树的层序遍历"></a>Pro 102 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        levelOrder1(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep用来记录当前遍历的c</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrder1</span><span class="params">(TreeNode root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; deep)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(deep - <span class="number">1</span>).add(root.val);</span><br><span class="line">        levelOrder1(root.left,deep);</span><br><span class="line">        levelOrder1(root.right,deep);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装常用的软件</title>
      <link href="/posts/ffabeda8.html"/>
      <url>/posts/ffabeda8.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络--HTTP</title>
      <link href="/posts/9610dfa.html"/>
      <url>/posts/9610dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>超文本传输协议</p><h2 id="状态码有哪些？"><a href="#状态码有哪些？" class="headerlink" title="状态码有哪些？"></a>状态码有哪些？</h2><img src="/posts/9610dfa/image-20240506144111577.png" class title="五大类HTTP状态码"><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h2><p>① Host字段</p><p>将请求发往「同一台」服务器上的不同网站。</p><img src="/posts/9610dfa/image-20240506144439951.png" class title="如图"><p>② Content-length字段</p><p>本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>HTTP协议是基于TCP协议的，这个方法解决了TCP 粘包 的问题</p><p>③ Connection字段</p><p>最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。长连接机制指的是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><img src="/posts/9610dfa/image-20240506144934539.png" class title="如图"><p>④ Content-Type字段</p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><img src="/posts/9610dfa/image-20240506145230659.png" class title="如图"><p>上述图片中：</p><p>客户端请求：Accept: * &#x2F; * 代表可以接收任何格式的数据</p><p>服务器端响应： Content-Type : text&#x2F;html;Charset&#x3D;utf-8 代表服务器端响应的数据格式</p><p>⑤ Content-Encoding 字段</p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><img src="/posts/9610dfa/image-20240506145550150.png" class title="如图"><h1 id="GTE和POST"><a href="#GTE和POST" class="headerlink" title="GTE和POST"></a>GTE和POST</h1><h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h2><p>根据RFC规范，</p><p>GET用于从服务器请求资源，请求的参数是写在URL中可见的，并且有长度限制。</p><p>POST用于对服务器的资源进行修改，内容写在报文body中，这个是不可见的。</p><h2 id="GET和POST方式是安全、幂等的嘛？"><a href="#GET和POST方式是安全、幂等的嘛？" class="headerlink" title="GET和POST方式是安全、幂等的嘛？"></a>GET和POST方式是安全、幂等的嘛？</h2><p>安全：请求方法不会破坏服务器上的资源</p><p>幂等：多次执行相同的请求，响应的结果是一致的</p><ul><li>对于RFC的GET和POST请求方式而言，<ul><li>GET是安全、幂等的，所以可以对GET请求的数据进行缓存到本地磁盘上。同时还可以作为书签</li><li>POST是非安全、不幂等的。</li></ul></li></ul><h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>用于避免发送缓存，对于一些重复性的http请求，直接将【请求-响应】的数据缓存在本地磁盘，下次可以直接读取本地磁盘中的数据。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>只要浏览器判断本地缓存没有过期，直接使用本地磁盘上的缓存。</p><p>通过设置在HTTP响应头部的2个字段来实现的：Cache-Control(相对时间，优先级高)；Expires（绝对时间）</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>服务器端向客户端发送304 的响应，通知客户端可以继续使用本地缓存。</p><p>协商缓存是在强制缓存发现本地缓存已经过期的情况下，开展的。主要流程如下</p><img src="/posts/9610dfa/image-20240506171152086.png" class title="如图"><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="HTTP和HTTPS有哪些区别？"><a href="#HTTP和HTTPS有哪些区别？" class="headerlink" title="HTTP和HTTPS有哪些区别？"></a>HTTP和HTTPS有哪些区别？</h2><ul><li>HTTP是明文传输，HTTPS在TCP和HTTP之间加了一个SSL&#x2F;TLS安全协议，进行加密传输</li><li>HTTP需要通过TCP三次握手建立连接，而HTTPS除了TCP三次握手后，还要进行SSL&#x2F;TLS的四次握手</li><li>HTTPS协议需要向CA申请数字证书，来保证服务器的身份是可信的</li></ul><h2 id="HTTPS解决了HTTP的哪些问题？"><a href="#HTTPS解决了HTTP的哪些问题？" class="headerlink" title="HTTPS解决了HTTP的哪些问题？"></a>HTTPS解决了HTTP的哪些问题？</h2><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容</li></ul><p>​<img src="/posts/9610dfa/image-20240506182200049.png" class title="如图"></p><p>​在通信建立前，采用非对称加密的方式交换会话密钥，后续就不再使用非对称加密</p><p>​在通信过程中全部使用对称加密的会话密钥加密明文数据</p><ul><li><strong>篡改风险</strong>，比如服务器端返回的数据被植入垃圾广告</li></ul><p>​摘要算法（利用哈希运算得到哈希值）+ 数字签名（避免在传输过程中的内容会被替换掉，利用私钥加密、公钥解密）</p><p>​<img src="/posts/9610dfa/image-20240506184356572.png" class title="如图"></p><ul><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>将服务器的公钥注册到数字证书中，数字证书认证机构CA利用自己的私钥将服务器的公钥数字签名并颁发数字证书（服务器的公钥+ CA的数字签名）给客户端。</p><p>客户端拿到数字证书后，利用CA的公钥进行解密确认数字证书的合法性，然后才能获取服务器的公钥。使用它对报文加密后发送。</p><p>服务器利用私钥进行解密。</p><img src="/posts/9610dfa/image-20240507144616740.png" class title="如图"><h2 id="HTTPS是如何建立连接的？"><a href="#HTTPS是如何建立连接的？" class="headerlink" title="HTTPS是如何建立连接的？"></a>HTTPS是如何建立连接的？</h2><p>① 首先进行TCP的三次握手</p><p>② 然后可以基于<strong>RSA或者ECHDE</strong>进行<strong>SSL&#x2F;TLS</strong>的四次握手通信。客户端向服务器端索要并且验证服务器的公钥（验证数字签名的合法性）；客户端和服务器端协商生产【会话密钥】。</p><ul><li><p>第一次握手：</p><ul><li>客户端向服务器发送加密通信请求，也就是<strong>ClientHello</strong>请求，请求内容为TLS协议版本+客户端的随机数+支持的密码套件列表</li></ul></li><li><p>第二次握手：</p><ul><li>服务器端给客户端返回响应，确认的TLS协议版本+ 服务器端的随机数 + 确定的密码套件列表 + 数字证书（通过CA的私钥对服务器的公钥加密后得到数字签名 + 服务器端的公钥）</li></ul></li><li><p>第三次握手：</p><ul><li><p>客户端收到服务器端的回应之后，通过CA的公钥进行解密，确认数字证书的合法性，然后利用数字证书中传递过来的服务器的公钥对一个<strong>随机数pre-master-key</strong>进行加密发送给服务器端。</p></li><li><img src="/posts/9610dfa/image-20240508152033447.png" class title="如图"></li><li><p>服务器端利用 服务器的私钥 对发送过来的pre-master-key进行解密得到pre-master-key</p></li><li><p>客户端、服务器端   分别利用 客户端随机数 + 服务器端随机数 + pre-master-key得到会话密钥</p></li><li><p>紧接着，客户端会通知服务器端使用加密方式进行通信，并且对之前发送的所有信息做个摘要并且进行加密，让服务器做个验证</p></li></ul></li><li><p>第四次握手：</p><ul><li>服务器如果验证双方加解密都没有问题，那么返回相同的响应，代表握手正式完成。</li></ul></li></ul><p>③ 接下来，就是利用http的方式请求和响应消息，只不过这个消息是经过会话密钥加密之后的</p><h2 id="HTTPS一定是安全可靠的吗？"><a href="#HTTPS一定是安全可靠的吗？" class="headerlink" title="HTTPS一定是安全可靠的吗？"></a>HTTPS一定是安全可靠的吗？</h2><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h1 id="HTTP-1-1-、HTTP-2、-HTTP-3演变"><a href="#HTTP-1-1-、HTTP-2、-HTTP-3演变" class="headerlink" title="HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变"></a>HTTP&#x2F;1.1  、HTTP&#x2F;2、 HTTP&#x2F;3演变</h1><h2 id="HTTPS-1-1-的优化？"><a href="#HTTPS-1-1-的优化？" class="headerlink" title="HTTPS&#x2F;1.1 的优化？"></a>HTTPS&#x2F;1.1 的优化？</h2><ul><li>优点<ul><li>长连接</li><li>管道传输</li></ul></li><li>缺点：<ul><li>服务器端存在队头阻塞的现象</li><li>请求只能从客户端发起，服务器端只能被动接受冰箱并响应</li></ul></li></ul><h2 id="HTTPS-2的优化？"><a href="#HTTPS-2的优化？" class="headerlink" title="HTTPS&#x2F;2的优化？"></a>HTTPS&#x2F;2的优化？</h2><p>基于HTTPS进行优化的</p><ul><li><p>优点</p><ul><li>是安全的</li><li>l利用HPACK算法实现头部压缩，因为对于很多请求而言，他们的头部是一样，我们在客户端和服务器端共同维护一个头部表</li><li>内部使用二进制格式，比如说响应http状态吗200原来是三个字符‘2’0‘0’保存的，现在利用二进制进行保存</li><li>利用stream解决HTTP服务器端的队头阻塞问题，以及实现了服务器端的主动推送功能</li></ul></li><li><p>缺点</p><ul><li>仍然存在这个TCP层的队头阻塞问题</li></ul></li></ul><h2 id="HTTPS-3的优化"><a href="#HTTPS-3的优化" class="headerlink" title="HTTPS&#x2F;3的优化"></a>HTTPS&#x2F;3的优化</h2><ul><li>优点：<ul><li>UDP替换TCP，彻底解决了队头阻塞的问题</li><li>没有TCP 的三次握手，建立连接更快。对于之前的连接：先进行TCP三次握手和四次挥手，以及TLS的四次握手；而现在QUIC协议包含TLS协议，只需要根据<strong>连接id</strong>进行QUIC三次握手即可</li><li>便于连接迁移，基于TCP的是通过一个TCP四元组（源ip,源port,目的ip，目的端口）确定一个TCP连接的，如果一旦网络发生变化，就需要重新建立连接。对于基于UDP，只需要通过连接ID标记通信的两个端点即可。</li></ul></li></ul><h1 id="HTTP1-1如何优化？"><a href="#HTTP1-1如何优化？" class="headerlink" title="HTTP1.1如何优化？"></a>HTTP1.1如何优化？</h1><ul><li>分为三个方面进行优化：<ul><li>缓存方面：利用  强制缓存   和    协商缓存   这2个技术实现避免发送http请求</li><li>减少http请求的次数<ul><li>将原本有客户端的处理的重定向请求，交给中间的代理服务器进行处理，减少重定向带来的请求的次数</li><li>将访问多个小文件的请求合并成一个大的请求，和并请求就是合并资源，以一个大资源的请求替换多个小资源的请求</li><li>请求网页的时候，没必要一口气将所有的资源都获取到，只需要先获取当前用户所看到的页面资源即可。</li></ul></li><li>减少HTTP响应的数据大小<ul><li>无损压缩：解压之后能够完全恢复到压缩前的原样，比如说gzip</li><li>有所压缩：通过牺牲一定的质量来提高压缩比，</li></ul></li></ul></li></ul><h1 id="HTTPS如何进行优化？"><a href="#HTTPS如何进行优化？" class="headerlink" title="HTTPS如何进行优化？"></a>HTTPS如何进行优化？</h1><h1 id="HTTPS的RSA握手解析"><a href="#HTTPS的RSA握手解析" class="headerlink" title="HTTPS的RSA握手解析"></a>HTTPS的RSA握手解析</h1><p>握手过程参考前面的内容</p><p>一般不使用它，因为它不可以前向加密的操作。</p><p>意思就是：客户端再通过验证数字证书的合法性之后，取出数字签名中的公钥，对新生成的随机数pre-master-key进行加密发送给服务器端，如果说服务器端的这个私钥被窃取了，那么回到发送的全部TSL消息全都被解密。</p><h1 id="HTTPS的ECDHE握手解析"><a href="#HTTPS的ECDHE握手解析" class="headerlink" title="HTTPS的ECDHE握手解析"></a>HTTPS的ECDHE握手解析</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器卷</title>
      <link href="/posts/e0d41e40.html"/>
      <url>/posts/e0d41e40.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是容器卷"><a href="#什么是容器卷" class="headerlink" title="什么是容器卷?"></a>什么是容器卷?</h1><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><ul><li><p>一句话：有点类似我们Redis里面的rdb和aof文件</p></li><li><p>·将docker容器内的数据保存进宿主机的磁盘中</p></li><li><p>那么如何运行一个带有容器卷存储功能的容器实例？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</span><br></pre></td></tr></table></figure></li></ul><h1 id="容器卷的作用？"><a href="#容器卷的作用？" class="headerlink" title="容器卷的作用？"></a>容器卷的作用？</h1><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p>为了能保存数据，在docker中我们使用卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据</p><p>2：卷中的更改可以直接实时生效，爽</p><p>3：数据卷中的更改不会包含在镜像的更新中</p><p>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h1 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h1><ul><li><p>默认是<strong>rw</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</span><br></pre></td></tr></table></figure></li><li><p><strong>ro</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</span><br></pre></td></tr></table></figure><p>容器自己只能读取不能写 </p><p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p></li></ul><h1 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h1><ul><li>容器1完成和宿主机的映射</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure><ul><li>容器2继承容器1的卷规则</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu</span><br></pre></td></tr></table></figure><p>注意：这里继承的是规则，代表即使容器1挂了，容器了还是能够和宿主机进行同步的。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像</title>
      <link href="/posts/890cc775.html"/>
      <url>/posts/890cc775.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是镜像？"><a href="#什么是镜像？" class="headerlink" title="什么是镜像？"></a>什么是镜像？</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><h2 id="联合文件系统UnionFS"><a href="#联合文件系统UnionFS" class="headerlink" title="联合文件系统UnionFS"></a>联合文件系统UnionFS</h2><p><strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="Docker镜像的加载原理"><a href="#Docker镜像的加载原理" class="headerlink" title="Docker镜像的加载原理"></a>Docker镜像的加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p><img src="/posts/890cc775/image-20240504225354426.png" class title="docker镜像的分层"><p>&#x3D;&#x3D;平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？？&#x3D;&#x3D;</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="Docker镜像采用分层结构的好处"><a href="#Docker镜像采用分层结构的好处" class="headerlink" title="Docker镜像采用分层结构的好处"></a>Docker镜像采用分层结构的好处</h2><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><p><strong>Docker镜像层都是只读的，容器层是可写的</strong> 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p>通俗来讲：</p><p>​Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>​新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建docker私有仓库</title>
      <link href="/posts/4f71e385.html"/>
      <url>/posts/4f71e385.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><p><a href="https://www.yuque.com/tmfl/cloud/zbegdm">https://www.yuque.com/tmfl/cloud/zbegdm</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/posts/749ad7d8.html"/>
      <url>/posts/749ad7d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、启动类命令"><a href="#1、启动类命令" class="headerlink" title="1、启动类命令"></a>1、启动类命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">//查看状态</span><br><span class="line">systemctl status docker</span><br><span class="line">//设为开机自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看docker版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="2、镜像相关的命令"><a href="#2、镜像相关的命令" class="headerlink" title="2、镜像相关的命令"></a>2、镜像相关的命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//列出本地主机上的镜像</span><br><span class="line">docker images</span><br><span class="line">//在远程仓库中搜索镜像</span><br><span class="line">docker search 镜像名称 (-f 过滤 --limit 只展示前几项)</span><br><span class="line">//下载镜像   不加 tag 时，默认下载最新的镜像（即tag为latest）。</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line">//查看占据的空间 查看镜像/容器/数据卷所占的空间：</span><br><span class="line">docker system df</span><br><span class="line">//删除镜像</span><br><span class="line">docker rmi 镜像名称/ID</span><br><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br><span class="line">docker rmi -f $&#123;docker images -qa&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h1><h2 id="3-1-新建启动容器"><a href="#3-1-新建启动容器" class="headerlink" title="3.1 新建启动容器"></a>3.1 新建启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：指定端口映射，具有几种不同形式</p><ul><li><p><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code> </p></li><li><p><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></p></li><li><p><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></p></li><li><p><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></p></li></ul></li></ul><h3 id="3-1-1-启动、退出-交互式容器"><a href="#3-1-1-启动、退出-交互式容器" class="headerlink" title="3.1.1 启动、退出 交互式容器"></a>3.1.1 启动、退出 交互式容器</h3><p>① 启动交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>② 退出交互式容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit;  //退出后，容器会停止；</span><br><span class="line"></span><br><span class="line">使用快捷键 ctrl + P + Q  //退出后容器仍然在运行</span><br></pre></td></tr></table></figure><h3 id="3-1-2-启动、退出守护式容器"><a href="#3-1-2-启动、退出守护式容器" class="headerlink" title="3.1.2 启动、退出守护式容器"></a>3.1.2 启动、退出守护式容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：</span></span><br><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h2 id="3-2-列出正在运行的容器"><a href="#3-2-列出正在运行的容器" class="headerlink" title="3.2 列出正在运行的容器"></a>3.2 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><h2 id="3-3-容器其他启动、停止操作"><a href="#3-3-容器其他启动、停止操作" class="headerlink" title="3.3 容器其他启动、停止操作"></a>3.3 容器其他启动、停止操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已经停止的容器</span></span><br><span class="line">docker start 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已经停止的容器：</span></span><br><span class="line">docker rm 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器：</span></span><br><span class="line">docker rm -f 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次删除多个容器实例：</span></span><br><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line">或者</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="3-5-查看容器的日志"><a href="#3-5-查看容器的日志" class="headerlink" title="3.5  查看容器的日志"></a>3.5  查看容器的日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-6-查看容器内运行的进程"><a href="#3-6-查看容器内运行的进程" class="headerlink" title="3.6 查看容器内运行的进程"></a>3.6 查看容器内运行的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-7-查看容器内部细节"><a href="#3-7-查看容器内部细节" class="headerlink" title="3.7 查看容器内部细节"></a>3.7 查看容器内部细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="3-8-进入正在运行的容器"><a href="#3-8-进入正在运行的容器" class="headerlink" title="3.8 进入正在运行的容器"></a>3.8 进入正在运行的容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入正在运行的容器，并以命令行交互：</span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"># 重新进入</span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p><ul><li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p></li><li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p></li></ul><p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="3-9-容器和宿主机文件拷贝"><a href="#3-9-容器和宿主机文件拷贝" class="headerlink" title="3.9 容器和宿主机文件拷贝"></a>3.9 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>宿主机文件拷贝到容器中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure><h2 id="3-10-导入和导出容器"><a href="#3-10-导入和导出容器" class="headerlink" title="3.10 导入和导出容器"></a>3.10 导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p><p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"># docker export 容器ID &gt; tar文件名</span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"></span><br><span class="line"># 导入</span><br><span class="line"># cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure><h2 id="3-11-将容器生成新镜像"><a href="#3-11-将容器生成新镜像" class="headerlink" title="3.11 将容器生成新镜像"></a>3.11 将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure><p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p><p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="3-12-容器数据卷"><a href="#3-12-容器数据卷" class="headerlink" title="3.12 容器数据卷"></a>3.12 容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>●数据卷可以在容器之间共享或重用数据<br>●卷中的更改可以直接实施生效<br>●数据卷中的更改不会包含在镜像的更新中<br>●数据卷的生命周期一直持续到没有容器使用它为止</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p><p>权限：</p><ul><li><p><code>rw</code>：读写 </p></li><li><p><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</p></li></ul><p>容器卷的继承：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动一个容器</span><br><span class="line">docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"># 使用 --volumes-from 继承 u1的容器卷映射配置</span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h1 id="4、所有命令示意图"><a href="#4、所有命令示意图" class="headerlink" title="4、所有命令示意图"></a>4、所有命令示意图</h1><img src="/posts/749ad7d8/image-20240504210851162.png" class title="所有命令示意图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、centos安装docker"><a href="#1、centos安装docker" class="headerlink" title="1、centos安装docker"></a>1、centos安装docker</h1><h2 id="1-1-配置yum资源库"><a href="#1-1-配置yum资源库" class="headerlink" title="1.1 配置yum资源库"></a>1.1 配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>配置docker的资源库地址：阿里云镜像地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><strong>创建缓存（可选）：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="1-2-安装Docker引擎"><a href="#1-2-安装Docker引擎" class="headerlink" title="1.2 安装Docker引擎"></a>1.2 安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>此时，默认安装的docker引擎、客户端都是最新版本。</p><p>如果要安装指定版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="1-3-启动Docker引擎"><a href="#1-3-启动Docker引擎" class="headerlink" title="1.3 启动Docker引擎"></a>1.3 启动Docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。启动Docker引擎：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="1-4-卸载docker"><a href="#1-4-卸载docker" class="headerlink" title="1.4 卸载docker"></a>1.4 卸载docker</h2><ol><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>使用&#x3D;&#x3D;yum&#x3D;&#x3D;删除docker引擎</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="3"><li>删除镜像、容器、卷、自定义配置等文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="1-5-运行Hello-world-进行测试"><a href="#1-5-运行Hello-world-进行测试" class="headerlink" title="1.5 运行Hello world 进行测试"></a>1.5 运行Hello world 进行测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h1 id="2、docker-下载加速"><a href="#2、docker-下载加速" class="headerlink" title="2、docker 下载加速"></a>2、docker 下载加速</h1><p>我这里使用的是阿里云加速</p><p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。</p><p>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/posts/f255ffad.html"/>
      <url>/posts/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1-Docker概述"></a>1-Docker概述</h1><h2 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 Docker简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>   –&gt; 将源码 + 配置 + 环境 + 版本打包成为一个镜像文件</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>传统虚拟机（virtual machine）：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与<strong>系统其他部分分隔开的一系列进程</strong>，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><img src="/posts/f255ffad/image-20240504144850924.png" class title="虚拟机和容器的区别"><p>对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>大小</td><td>一般为Mb</td><td>一般为Gb</td></tr><tr><td>速度</td><td>接近原生</td><td>比较慢</td></tr><tr><td>系统支持数量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="1-3-Docker运行快的原因"><a href="#1-3-Docker运行快的原因" class="headerlink" title="1.3 Docker运行快的原因"></a>1.3 Docker运行快的原因</h2><p>Docker<strong>利用的是宿主机的内核</strong>，而不需要加载操作系统OS内核：</p><p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p><p>Docker容器的<strong>本质就是一个进程</strong>。</p><h2 id="1-4-Docker的组成"><a href="#1-4-Docker的组成" class="headerlink" title="1.4 Docker的组成"></a>1.4 Docker的组成</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分：</p><ul><li><p>镜像（image）</p></li><li><p>容器（container）</p></li><li><p>仓库（repository）</p></li></ul><h3 id="1-4-1-镜像"><a href="#1-4-1-镜像" class="headerlink" title="1.4.1 镜像"></a>1.4.1 镜像</h3><p>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><h3 id="1-4-2-容器"><a href="#1-4-2-容器" class="headerlink" title="1.4.2 容器"></a>1.4.2 容器</h3><p>Docker利用<strong>容器</strong>独立运行的一个或一组应用，应用程序或服务运行在容器里面，<strong>容器就类似于一个虚拟化的运行环境</strong>，容器是用镜像创建的<strong>运行实例</strong>。</p><h3 id="1-4-3-仓库"><a href="#1-4-3-仓库" class="headerlink" title="1.4.3 仓库"></a>1.4.3 仓库</h3><p>Docker仓库是<strong>集中存放镜像文件</strong>的场所。</p><p>仓库分为<strong>公开仓库</strong>和<strong>私有仓库</strong>两种。</p><p>最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><img src="/posts/f255ffad/image-20240504145832567.png" class title="docker架构图">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务生态技术 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job_基础学习</title>
      <link href="/posts/2b2e40e1.html"/>
      <url>/posts/2b2e40e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1什么是任务调度"><a href="#1-1什么是任务调度" class="headerlink" title="1.1什么是任务调度"></a>1.1什么是任务调度</h3><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="1-2-为什么需要分布式调度"><a href="#1-2-为什么需要分布式调度" class="headerlink" title="1.2 为什么需要分布式调度"></a>1.2 为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能</p><p>在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>感觉Spring给我们提供的这个注解可以完成任务调度的功能，好像已经完美解决问题了，为什么还需要分布式呢?</p><p>主要有如下这几点原因:</p><ol><li>高可用：单机版的定式任务调度只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用。</li><li>防止重复执行: 在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，这时，定时执行的结果就可能存在混乱和错误了</li><li>单机处理极限：原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。你也许会说，你也可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况。</li></ol><h3 id="1-3-XXL-JOB介绍"><a href="#1-3-XXL-JOB介绍" class="headerlink" title="1.3 XXL-JOB介绍"></a>1.3 XXL-JOB介绍</h3><p>XXL-Job：是大众点评的分布式任务调度平台，是一个**<code>轻量级分布式任务调度平台,</code>** 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p>大众点评目前已接入XXL-JOB，该系统在内部已调度约100万次，表现优异。</p><p>目前已有多家公司接入xxl-job，包括比较知名的大众点评，京东，优信二手车，360金融 (360)，联想集团 (联想)，易信 (网易)等等</p><p>官网地址 <a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><p><strong>系统架构图</strong></p><img src="/posts/image.png" width="75%" height="75%"><p><strong>设计思想</strong></p><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><h3 id="2-1-下载源码"><a href="#2-1-下载源码" class="headerlink" title="2.1 下载源码"></a>2.1 下载源码</h3><p><strong>源码下载地址:</strong></p><p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p><a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></p><h3 id="2-1-初始化调度数据库"><a href="#2-1-初始化调度数据库" class="headerlink" title="2.1 初始化调度数据库"></a>2.1 初始化调度数据库</h3><p>请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。</p><p>“调度数据库初始化SQL脚本” 位置为:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/xxl-job/doc/db/tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h3 id="2-2-编译源码"><a href="#2-2-编译源码" class="headerlink" title="2.2 编译源码"></a>2.2 编译源码</h3><p>解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558831.png" alt="img"></p><h3 id="2-3-配置部署调度中心"><a href="#2-3-配置部署调度中心" class="headerlink" title="2.3 配置部署调度中心"></a>2.3 配置部署调度中心</h3><h4 id="2-3-1-调度中心配置"><a href="#2-3-1-调度中心配置" class="headerlink" title="2.3.1 调度中心配置"></a>2.3.1 调度中心配置</h4><p>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### web</span><br><span class="line">server.port=8080    ###配置了端口号</span><br><span class="line">server.servlet.context-path=/xxl-job-admin</span><br><span class="line"></span><br><span class="line">### actuator</span><br><span class="line">management.server.servlet.context-path=/actuator</span><br><span class="line">management.health.mail.enabled=false</span><br><span class="line"></span><br><span class="line">### resources</span><br><span class="line">spring.mvc.servlet.load-on-startup=0</span><br><span class="line">spring.mvc.static-path-pattern=/static/**</span><br><span class="line">spring.resources.static-locations=classpath:/static/</span><br><span class="line"></span><br><span class="line">### freemarker</span><br><span class="line">spring.freemarker.templateLoaderPath=classpath:/templates/</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.request-context-attribute=request</span><br><span class="line">spring.freemarker.settings.number_format=0.##########</span><br><span class="line"></span><br><span class="line">### mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml</span><br><span class="line">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span><br><span class="line"></span><br><span class="line">### xxl-job, datasource</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.202.200:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">### datasource-pool</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.auto-commit=true</span><br><span class="line">spring.datasource.hikari.idle-timeout=30000</span><br><span class="line">spring.datasource.hikari.pool-name=HikariCP</span><br><span class="line">spring.datasource.hikari.max-lifetime=900000</span><br><span class="line">spring.datasource.hikari.connection-timeout=10000</span><br><span class="line">spring.datasource.hikari.connection-test-query=SELECT 1</span><br><span class="line">spring.datasource.hikari.validation-timeout=1000</span><br><span class="line"></span><br><span class="line">### xxl-job, email</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.username=xxx@qq.com</span><br><span class="line">spring.mail.from=xxx@qq.com</span><br><span class="line">spring.mail.password=xxx</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory</span><br><span class="line"></span><br><span class="line">### xxl-job, access token</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line"></span><br><span class="line">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span><br><span class="line">xxl.job.i18n=zh_CN</span><br><span class="line"></span><br><span class="line">## xxl-job, triggerpool max size</span><br><span class="line">xxl.job.triggerpool.fast.max=200</span><br><span class="line">xxl.job.triggerpool.slow.max=100</span><br><span class="line"></span><br><span class="line">### xxl-job, log retention days</span><br><span class="line">xxl.job.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-3-2-部署项目"><a href="#2-3-2-部署项目" class="headerlink" title="2.3.2 部署项目"></a>2.3.2 部署项目</h4><p>运行<code>XxlJobAdminApplication</code>程序即可.</p><p>调度中心访问地址: <a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a></p><p>默认登录账号 “admin&#x2F;123456”, 登录后运行界面如下图所示。</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558842.png" alt="img"></p><p>至此“调度中心”项目已经部署成功。</p><h3 id="2-4-配置部署执行器项目"><a href="#2-4-配置部署执行器项目" class="headerlink" title="2.4 配置部署执行器项目"></a>2.4 配置部署执行器项目</h3><h4 id="2-4-1-添加Maven依赖"><a href="#2-4-1-添加Maven依赖" class="headerlink" title="2.4.1 添加Maven依赖"></a>2.4.1 添加Maven依赖</h4><p>创建SpringBoot项目并且添加如下依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-执行器配置"><a href="#2-4-2-执行器配置" class="headerlink" title="2.4.2 执行器配置"></a>2.4.2 执行器配置</h4><p>在配置文件中添加如下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span><br><span class="line">xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin</span><br><span class="line">### 执行器通讯TOKEN [选填]：非空时启用；</span><br><span class="line">xxl.job.accessToken=default_token</span><br><span class="line">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span><br><span class="line">xxl.job.executor.appname=xxl-job-executor-sample</span><br><span class="line">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span><br><span class="line">xxl.job.executor.address=</span><br><span class="line">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span><br><span class="line">xxl.job.executor.ip=127.0.0.1</span><br><span class="line">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span><br><span class="line">xxl.job.executor.port=9999</span><br><span class="line">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span><br><span class="line">xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler</span><br><span class="line">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span><br><span class="line">xxl.job.executor.logretentiondays=30</span><br></pre></td></tr></table></figure><h4 id="2-4-3-添加执行器配置"><a href="#2-4-3-添加执行器配置" class="headerlink" title="2.4.3 添加执行器配置"></a>2.4.3 添加执行器配置</h4><p>创建<code>XxlJobConfig</code>配置对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-添加任务处理类"><a href="#2-4-4-添加任务处理类" class="headerlink" title="2.4.4 添加任务处理类"></a>2.4.4 添加任务处理类</h4><p>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-运行HelloWorld程序"><a href="#2-5-运行HelloWorld程序" class="headerlink" title="2.5 运行HelloWorld程序"></a>2.5 运行HelloWorld程序</h3><h4 id="2-5-1-任务配置-触发执行"><a href="#2-5-1-任务配置-触发执行" class="headerlink" title="2.5.1 任务配置&amp;触发执行"></a>2.5.1 任务配置&amp;触发执行</h4><p>登录调度中心,在任务管理中新增任务,配置内容如下:</p><img src="/posts/image-17147915558843.png"><p>新增后界面如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558844.png" alt="img"></p><p>接着启动定时调度任务</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558845.png" alt="img"></p><h4 id="2-5-2-查看日志"><a href="#2-5-2-查看日志" class="headerlink" title="2.5.2 查看日志"></a>2.5.2 查看日志</h4><p>在调度中心的调度日志中就可以看到，任务的执行结果.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558846.png" alt="img"></p><p>管控台也可以看到任务的执行信息.</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558857.png" alt="img"></p><h3 id="2-6-GLUE模式-Java"><a href="#2-6-GLUE模式-Java" class="headerlink" title="2.6 GLUE模式(Java)"></a>2.6 GLUE模式(Java)</h3><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定**<code>JobHandler</code>**。</p><p>（ “GLUE模式(Java)” 运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，可使用<a href="https://github.com/Resource">@Resource</a>&#x2F;<a href="https://github.com/Autowire">@Autowire</a>注入执行器里中的其他服务.</p><p><strong>添加Service</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MethodB的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加任务配置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558858.png" alt="img"></p><p><strong>通过GLUE IDE在线编辑代码</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-17147915558859.png" alt="img"></p><hr><p>编写内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.service.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.wolfcode.xxljobdemo.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.IJobHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGlueJobHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        helloService.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动并执行程序</strong></p><h3 id="2-6-执行器集群"><a href="#2-6-执行器集群" class="headerlink" title="2.6 执行器集群"></a>2.6 执行器集群</h3><h4 id="2-6-1-集群环境搭建"><a href="#2-6-1-集群环境搭建" class="headerlink" title="2.6.1 集群环境搭建"></a>2.6.1 集群环境搭建</h4><p>在IDEA中设置SpringBoot项目运行开启多个集群</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588510.png" alt="img"></p><p>启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure><ul><li>Tomcat端口8090程序的命令行参数如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588511.png" alt="img"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><ul><li><p>8090端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588512.png" alt="img"></p></li><li><p>8091端口的控制台日志如下:</p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588513.png" alt="img"></p></li></ul><h4 id="2-6-2-调度路由算法讲解"><a href="#2-6-2-调度路由算法讲解" class="headerlink" title="2.6.2 调度路由算法讲解"></a>2.6.2 调度路由算法讲解</h4><p>当执行器集群部署时，提供丰富的路由策略，包括:</p><ol><li><code>FIRST（第一个）：固定选择第一个机器</code></li><li><code>LAST（最后一个）：固定选择最后一个机器；</code></li><li><code>ROUND（轮询）：依次的选择在线的机器发起调度</code></li><li><code>RANDOM（随机）：随机选择在线的机器；</code></li><li><code>CONSISTENT_HASH（一致性HASH）：</code> <code>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</code></li><li><code>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</code></li><li><code>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</code></li><li><code>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</code></li><li><code>SHARDING_BROADCAST(分片广播)：</code> <code>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</code></li></ol><h2 id="3-分片功能讲解"><a href="#3-分片功能讲解" class="headerlink" title="3. 分片功能讲解"></a>3. 分片功能讲解</h2><h3 id="3-1-案例需求讲解"><a href="#3-1-案例需求讲解" class="headerlink" title="3.1 案例需求讲解"></a>3.1 案例需求讲解</h3><p>需求:我们现在实现这样的需求，在指定节假日，需要给平台的所有用户去发送祝福的短信.</p><h4 id="3-1-1-初始化数据"><a href="#3-1-1-初始化数据" class="headerlink" title="3.1.1 初始化数据"></a>3.1.1 初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="3-1-2-集成Druid-MyBatis"><a href="#3-1-2-集成Druid-MyBatis" class="headerlink" title="3.1.2 集成Druid&amp;MyBatis"></a>3.1.2 集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=WolfCode_2017</span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-业务功能实现"><a href="#3-1-3-业务功能实现" class="headerlink" title="3.1.3 业务功能实现"></a>3.1.3 业务功能实现</h4><p><strong>任务处理方法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务配置信息</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588514.png" alt="img"></p><h3 id="3-2-分片概念讲解"><a href="#3-2-分片概念讲解" class="headerlink" title="3.2 分片概念讲解"></a>3.2 分片概念讲解</h3><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务.</p><p>如果采取<code>分片广播</code>的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度.</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h3 id="3-3-案例改造成任务分片"><a href="#3-3-案例改造成任务分片" class="headerlink" title="3.3 案例改造成任务分片"></a>3.3 案例改造成任务分片</h3><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务设置</strong></p><p><img src="/xxl-job-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-171479155588515.png" alt="img"></p><h2 id="4-项目集成XXL-JOB"><a href="#4-项目集成XXL-JOB" class="headerlink" title="4. 项目集成XXL-JOB"></a>4. 项目集成XXL-JOB</h2>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog-introduction</title>
      <link href="/posts/7574726c.html"/>
      <url>/posts/7574726c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、解决HEXO图片无法显示问题"><a href="#1、解决HEXO图片无法显示问题" class="headerlink" title="1、解决HEXO图片无法显示问题"></a>1、解决HEXO图片无法显示问题</h1><p>版本：Hexo 3以上　　</p><p>最近搭建hexo博客时遇到了图片部署后不显示的问题，如图：</p><p>上网找了很多方式都没有完美解决问题，后来查看了官方文档后终于解决了问题（完美解决），现在贴出来如下。建议以后大家遇到了问题也先去看看官方文档：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p><p>解决方案如下：</p><p>　　1. 在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。</p><p>　　2. git bash安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</p><p>　　3. 插入图片时用这种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img jpg文件 文件描述 %&#125;</span><br></pre></td></tr></table></figure><img src="/posts/7574726c/image-20240503162414559.png" class title="图片描述"><p>　　4. 这样就能成功显示了，测试下吧：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
